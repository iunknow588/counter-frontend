"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportReplayer = void 0;
const rxjs_1 = require("rxjs");
const hw_transport_1 = __importDefault(require("@ledgerhq/hw-transport"));
const logs_1 = require("@ledgerhq/logs");
class TransportReplayer extends hw_transport_1.default {
    recordStore;
    artificialExchangeDelay = 0;
    exchangeBlocker;
    constructor(recordStore) {
        super();
        this.recordStore = recordStore;
        this.exchangeBlocker = null;
    }
    static isSupported = () => Promise.resolve(true);
    static list = () => Promise.resolve([null]);
    static listen = o => {
        let unsubscribed;
        setTimeout(() => {
            if (unsubscribed)
                return;
            o.next({
                type: "add",
                descriptor: null,
            });
            o.complete();
        }, 0);
        return {
            unsubscribe: () => {
                unsubscribed = true;
            },
        };
    };
    static open = (recordStore) => Promise.resolve(new TransportReplayer(recordStore));
    setArtificialExchangeDelay(delay) {
        this.artificialExchangeDelay = delay;
    }
    setScrambleKey() { }
    close() {
        return Promise.resolve();
    }
    /**
     * Sets an observable blocking an exchange until `unblockExchange` is called
     */
    enableExchangeBlocker() {
        this.exchangeBlocker = new rxjs_1.Subject();
    }
    /**
     * Unblock exchange by emitting an event (if enabled), and remove the exchange blocker
     */
    unblockExchange() {
        if (this.exchangeBlocker) {
            this.exchangeBlocker.next(1);
            this.exchangeBlocker = null;
        }
    }
    exchange(apdu) {
        (0, logs_1.log)("apdu", apdu.toString("hex"));
        try {
            const buffer = this.recordStore.replayExchange(apdu);
            (0, logs_1.log)("apdu", buffer.toString("hex"));
            if (this.artificialExchangeDelay) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(buffer);
                        this.setArtificialExchangeDelay(0);
                    }, this.artificialExchangeDelay);
                });
            }
            else if (this.exchangeBlocker) {
                return (0, rxjs_1.firstValueFrom)(
                // The exchange is unblocked once `exchangeBlocker` emits a value
                this.exchangeBlocker.pipe((0, rxjs_1.map)(_ => {
                    return buffer;
                })));
            }
            else {
                return Promise.resolve(buffer);
            }
        }
        catch (e) {
            (0, logs_1.log)("apdu-error", String(e));
            return Promise.reject(e);
        }
    }
}
exports.TransportReplayer = TransportReplayer;
/**
 * create a transport replayer with a record store.
 * @param recordStore
 */
const openTransportReplayer = (recordStore) => {
    return TransportReplayer.open(recordStore);
};
exports.default = openTransportReplayer;
//# sourceMappingURL=openTransportReplayer.js.map