"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAddress = exports.resolveDomain = void 0;
const axios_1 = __importDefault(require("axios"));
const eip55_1 = __importDefault(require("eip55"));
const logs_1 = require("@ledgerhq/logs");
const utils_1 = require("../utils");
const registries_1 = require("../registries");
/**
 * Get an array of addresses for a domain
 *
 * @param {string} domain
 * @returns {Promise<DomainServiceResolution[]>}
 */
const resolveDomain = async (domain, registryName) => {
    const registries = await (async () => {
        if (registryName) {
            const registries = await (0, registries_1.getRegistries)();
            const registry = registries.find(r => r.name === registryName && r.patterns.forward.test(domain));
            return registry
                ? [registry]
                : /* istanbul ignore next: don't test emptiness of resolutions */ [];
        }
        return (0, registries_1.getRegistriesForDomain)(domain);
    })();
    const responses = (0, utils_1.allSettled)(registries.map(registry => axios_1.default.request({
        method: "GET",
        url: registry.resolvers.forward.replace("{name}", domain),
    })));
    return responses.then(promises => promises.reduce((result, promise, index) => {
        if (promise.status !== "fulfilled") {
            // ignore 404 error
            /* istanbul ignore next: don't test logs */
            if (axios_1.default.isAxiosError(promise.reason) && promise.reason.response?.status !== 404) {
                (0, logs_1.log)("domain-service", "failed to resolve a domain", {
                    domain,
                    error: promise.reason,
                });
            }
            return result;
        }
        if (!promise.value.data)
            return result;
        const checksummedAddress = (() => {
            try {
                return eip55_1.default.encode(promise.value.data);
            }
            catch (e) {
                return promise.value.data;
            }
        })();
        result.push({
            registry: registries[index].name,
            address: checksummedAddress,
            domain,
            type: "forward",
        });
        return result;
    }, []));
};
exports.resolveDomain = resolveDomain;
/**
 * Get an array of domains for an address
 *
 * @param {string} address
 * @returns {Promise<DomainServiceResolution[]>}
 */
const resolveAddress = async (address, registryName) => {
    const registries = await (async () => {
        if (registryName) {
            const registries = await (0, registries_1.getRegistries)();
            const registry = registries.find(r => r.name === registryName && r.patterns.reverse.test(address));
            return registry
                ? [registry]
                : /* istanbul ignore next: don't test emptiness of resolutions */ [];
        }
        return (0, registries_1.getRegistriesForAddress)(address);
    })();
    const checksummedAddress = (() => {
        try {
            return eip55_1.default.encode(address);
        }
        catch (e) {
            return address;
        }
    })();
    const responses = (0, utils_1.allSettled)(registries.map(registry => axios_1.default.request({
        method: "GET",
        url: registry.resolvers.reverse.replace("{address}", address),
    })));
    return responses.then(promises => promises.reduce((result, promise, index) => {
        if (promise.status !== "fulfilled") {
            // ignore 404 error
            /* istanbul ignore next: don't test logs */
            if (axios_1.default.isAxiosError(promise.reason) && promise.reason.response?.status !== 404) {
                (0, logs_1.log)("domain-service", "failed to resolve a address", {
                    address,
                    error: promise.reason,
                });
            }
            return result;
        }
        if (!promise.value.data)
            return result;
        result.push({
            registry: registries[index].name,
            domain: promise.value.data,
            address: checksummedAddress,
            type: "reverse",
        });
        return result;
    }, []));
};
exports.resolveAddress = resolveAddress;
//# sourceMappingURL=index.js.map