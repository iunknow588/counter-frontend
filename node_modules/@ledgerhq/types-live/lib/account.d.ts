import type { BigNumber } from "bignumber.js";
import type { CryptoCurrency, CryptoOrTokenCurrency, TokenCurrency } from "@ledgerhq/types-cryptoassets";
import type { OperationRaw, Operation } from "./operation";
import type { DerivationMode } from "./derivation";
import type { SwapOperation, SwapOperationRaw } from "./swap";
import { ProtoNFT, ProtoNFTRaw } from "./nft";
export type GranularityId = "HOUR" | "DAY" | "WEEK";
export type BalanceHistoryCache = Record<GranularityId, BalanceHistoryDataCache>;
export type BalanceHistoryDataCache = {
    latestDate: number | null | undefined;
    balances: number[];
};
/** A token belongs to an Account and share the parent account address */
export type TokenAccount = {
    type: "TokenAccount";
    id: string;
    parentId: string;
    token: TokenCurrency;
    balance: BigNumber;
    spendableBalance: BigNumber;
    creationDate: Date;
    operationsCount: number;
    operations: Operation[];
    pendingOperations: Operation[];
    balanceHistoryCache: BalanceHistoryCache;
    swapHistory: SwapOperation[];
};
/** */
export type Address = {
    address: string;
    derivationPath: string;
};
/**
 * Account type is the main level account of a blockchain currency.
 * Each family maybe need an extra field, to solve this, you can have some subtyping like this:


    export type BitcoinAccount = Account & { bitcoinResources: BitcoinResources }

and all parts where we would need it, we would need to cast,

    const bitcoinAccount = account as BitcoinAccount;

and that BitcoinAccount type would be part of a coin integration family specific indeed.
 */
export type Account = {
    type: "Account";
    id: string;
    seedIdentifier: string;
    xpub?: string;
    derivationMode: DerivationMode;
    index: number;
    freshAddress: string;
    freshAddressPath: string;
    used: boolean;
    balance: BigNumber;
    spendableBalance: BigNumber;
    creationDate: Date;
    blockHeight: number;
    currency: CryptoCurrency;
    feesCurrency?: CryptoCurrency | TokenCurrency | undefined;
    operationsCount: number;
    operations: Operation[];
    pendingOperations: Operation[];
    lastSyncDate: Date;
    subAccounts?: TokenAccount[];
    balanceHistoryCache: BalanceHistoryCache;
    swapHistory: SwapOperation[];
    syncHash?: string | undefined;
    nfts?: ProtoNFT[];
};
/** One of the Account type */
export type AccountLike<A extends Account = Account> = A | TokenAccount;
/**
 * An array of AccountLikes
 */
export type AccountLikeArray = AccountLike[] | TokenAccount[] | Account[];
/** */
export type TokenAccountRaw = {
    type: "TokenAccountRaw";
    id: string;
    starred?: boolean;
    parentId: string;
    tokenId: string;
    creationDate?: string;
    operationsCount?: number;
    operations: OperationRaw[];
    pendingOperations: OperationRaw[];
    balance: string;
    spendableBalance?: string;
    balanceHistoryCache?: BalanceHistoryCache;
    swapHistory?: SwapOperationRaw[];
};
/** */
export type AccountRaw = {
    id: string;
    seedIdentifier: string;
    xpub?: string;
    derivationMode: DerivationMode;
    index: number;
    freshAddress: string;
    freshAddressPath: string;
    name?: string;
    starred?: boolean;
    used?: boolean;
    balance: string;
    spendableBalance?: string;
    blockHeight: number;
    creationDate?: string;
    operationsCount?: number;
    currencyId: string;
    feesCurrencyId?: string;
    operations: OperationRaw[];
    pendingOperations: OperationRaw[];
    lastSyncDate: string;
    subAccounts?: TokenAccountRaw[];
    balanceHistoryCache?: BalanceHistoryCache;
    swapHistory?: SwapOperationRaw[];
    syncHash?: string | undefined;
    nfts?: ProtoNFTRaw[];
};
/** */
export type AccountRawLike = AccountRaw | TokenAccountRaw;
/** */
export type AccountIdParams = {
    type: string;
    version: string;
    currencyId: string;
    xpubOrAddress: string;
    derivationMode: DerivationMode;
};
/**
 * This represent the user's data part of an account which contains all user's custom information that aren't part of on-chain data
 * The object is serializable.
 */
export type AccountUserData = {
    id: string;
    name: string;
    starredIds: string[];
};
export declare function getCurrencyForAccount(account: AccountLike): CryptoOrTokenCurrency;
//# sourceMappingURL=account.d.ts.map