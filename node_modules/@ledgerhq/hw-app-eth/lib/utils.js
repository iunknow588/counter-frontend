"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeResolutions = exports.nftSelectors = exports.tokenSelectors = exports.intAsHexBytes = exports.decodeTxInfo = exports.maybeHexBuffer = exports.hexBuffer = exports.splitPath = exports.padHexString = exports.ERC1155_CLEAR_SIGNED_SELECTORS = exports.ERC721_CLEAR_SIGNED_SELECTORS = exports.ERC20_CLEAR_SIGNED_SELECTORS = void 0;
const bignumber_js_1 = require("bignumber.js");
const index_1 = require("@ledgerhq/evm-tools/selectors/index");
Object.defineProperty(exports, "ERC20_CLEAR_SIGNED_SELECTORS", { enumerable: true, get: function () { return index_1.ERC20_CLEAR_SIGNED_SELECTORS; } });
Object.defineProperty(exports, "ERC721_CLEAR_SIGNED_SELECTORS", { enumerable: true, get: function () { return index_1.ERC721_CLEAR_SIGNED_SELECTORS; } });
Object.defineProperty(exports, "ERC1155_CLEAR_SIGNED_SELECTORS", { enumerable: true, get: function () { return index_1.ERC1155_CLEAR_SIGNED_SELECTORS; } });
const rlp_1 = require("@ethersproject/rlp");
const padHexString = (str) => {
    return str.length % 2 ? "0" + str : str;
};
exports.padHexString = padHexString;
function splitPath(path) {
    const result = [];
    const components = path.split("/");
    components.forEach(element => {
        let number = parseInt(element, 10);
        if (isNaN(number)) {
            return; // FIXME shouldn't it throws instead?
        }
        if (element.length > 1 && element[element.length - 1] === "'") {
            number += 0x80000000;
        }
        result.push(number);
    });
    return result;
}
exports.splitPath = splitPath;
function hexBuffer(str) {
    const strWithoutPrefix = str.startsWith("0x") ? str.slice(2) : str;
    return Buffer.from((0, exports.padHexString)(strWithoutPrefix), "hex");
}
exports.hexBuffer = hexBuffer;
function maybeHexBuffer(str) {
    if (!str)
        return null;
    return hexBuffer(str);
}
exports.maybeHexBuffer = maybeHexBuffer;
const decodeTxInfo = (rawTx) => {
    const VALID_TYPES = [1, 2];
    const txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;
    const rlpData = txType === null ? rawTx : rawTx.slice(1);
    const rlpTx = (0, rlp_1.decode)(rlpData).map(hex => Buffer.from(hex.slice(2), "hex"));
    let chainIdTruncated = 0;
    const rlpDecoded = (0, rlp_1.decode)(rlpData);
    let decodedTx;
    if (txType === 2) {
        // EIP1559
        decodedTx = {
            data: rlpDecoded[7],
            to: rlpDecoded[5],
            chainId: rlpTx[0],
        };
    }
    else if (txType === 1) {
        // EIP2930
        decodedTx = {
            data: rlpDecoded[6],
            to: rlpDecoded[4],
            chainId: rlpTx[0],
        };
    }
    else {
        // Legacy tx
        decodedTx = {
            data: rlpDecoded[5],
            to: rlpDecoded[3],
            // Default to 1 for non EIP 155 txs
            chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from("0x01", "hex"),
        };
    }
    const chainIdSrc = decodedTx.chainId;
    let chainId = new bignumber_js_1.BigNumber(0);
    if (chainIdSrc) {
        // Using BigNumber because chainID could be any uint256.
        chainId = new bignumber_js_1.BigNumber(chainIdSrc.toString("hex"), 16);
        const chainIdTruncatedBuf = Buffer.alloc(4);
        if (chainIdSrc.length > 4) {
            chainIdSrc.copy(chainIdTruncatedBuf);
        }
        else {
            chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);
        }
        chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);
    }
    let vrsOffset = 0;
    if (txType === null && rlpTx.length > 6) {
        const rlpVrs = Buffer.from((0, rlp_1.encode)(rlpTx.slice(-3)).slice(2), "hex");
        vrsOffset = rawTx.length - (rlpVrs.length - 1);
        // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.
        if (rlpVrs[0] > 0xf7) {
            // Increment vrsOffset to account for that extra byte.
            vrsOffset++;
            // Compute size of the list length.
            const sizeOfListLen = rlpVrs[0] - 0xf7;
            // Increase rlpOffset by the size of the list length.
            vrsOffset += sizeOfListLen - 1;
        }
    }
    return {
        decodedTx,
        txType,
        chainId,
        chainIdTruncated,
        vrsOffset,
    };
};
exports.decodeTxInfo = decodeTxInfo;
/**
 * @ignore for the README
 *
 * Helper to convert an integer as a hexadecimal string with the right amount of digits
 * to respect the number of bytes given as parameter
 *
 * @param int Integer
 * @param bytes Number of bytes it should be represented as (1 byte = 2 caraters)
 * @returns The given integer as an hexa string padded with the right number of 0
 */
const intAsHexBytes = (int, bytes) => int.toString(16).padStart(2 * bytes, "0");
exports.intAsHexBytes = intAsHexBytes;
exports.tokenSelectors = Object.values(index_1.ERC20_CLEAR_SIGNED_SELECTORS);
exports.nftSelectors = [
    ...Object.values(index_1.ERC721_CLEAR_SIGNED_SELECTORS),
    ...Object.values(index_1.ERC1155_CLEAR_SIGNED_SELECTORS),
];
const mergeResolutions = (resolutionsArray) => {
    const mergedResolutions = {
        nfts: [],
        erc20Tokens: [],
        externalPlugin: [],
        plugin: [],
        domains: [],
    };
    for (const resolutions of resolutionsArray) {
        for (const key in resolutions) {
            mergedResolutions[key].push(...resolutions[key]);
        }
    }
    return mergedResolutions;
};
exports.mergeResolutions = mergeResolutions;
//# sourceMappingURL=utils.js.map