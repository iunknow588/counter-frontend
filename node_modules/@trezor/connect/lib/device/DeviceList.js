"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceList = exports.assertDeviceListConnected = void 0;
const transport_1 = require("@trezor/transport");
const utils_1 = require("@trezor/utils");
const constants_1 = require("../constants");
const events_1 = require("../events");
const Device_1 = require("./Device");
const transportInfo_1 = require("../data/transportInfo");
const types_1 = require("../types");
const utils_2 = require("../types/utils");
const debug_1 = require("../utils/debug");
const createAuthPenaltyManager = (priority) => {
    const penalizedDevices = {};
    const get = () => 100 * priority +
        Object.keys(penalizedDevices).reduce((penalty, key) => Math.max(penalty, penalizedDevices[key]), 0);
    const add = (device) => {
        if (!device.isInitialized() || device.isBootloader() || !device.features.device_id)
            return;
        const deviceID = device.features.device_id;
        const penalty = penalizedDevices[deviceID] ? penalizedDevices[deviceID] + 500 : 2000;
        penalizedDevices[deviceID] = Math.min(penalty, 5000);
    };
    const remove = (device) => {
        if (!device.isInitialized() || device.isBootloader() || !device.features.device_id)
            return;
        const deviceID = device.features.device_id;
        delete penalizedDevices[deviceID];
    };
    const clear = () => Object.keys(penalizedDevices).forEach(key => delete penalizedDevices[key]);
    return { get, add, remove, clear };
};
const createDeviceCollection = () => {
    let devices = [];
    const isEqual = (a) => (b) => a.transport === b.transport && a.transportPath === b.transportPath;
    const get = (transportPath, transport) => devices.find(isEqual({ transport, transportPath }));
    const all = () => devices;
    const add = (device) => {
        const index = devices.findIndex(isEqual(device));
        if (index >= 0)
            devices[index] = device;
        else
            devices.push(device);
    };
    const remove = (transportPath, transport) => {
        const index = devices.findIndex(isEqual({ transport, transportPath }));
        const [removed] = index >= 0 ? devices.splice(index, 1) : [undefined];
        return removed;
    };
    const clear = (transport) => {
        let removed;
        [removed, devices] = (0, utils_1.arrayPartition)(devices, d => !transport || d.transport === transport);
        return removed;
    };
    return { get, all, add, remove, clear };
};
const getTransportInfo = (transport) => ({
    apiType: transport.apiType,
    type: transport.name,
    version: transport.version,
    outdated: transport.isOutdated,
});
const assertDeviceListConnected = deviceList => {
    if (!deviceList.isConnected()) {
        throw constants_1.ERRORS.TypedError('Transport_Missing');
    }
};
exports.assertDeviceListConnected = assertDeviceListConnected;
class DeviceList extends utils_1.TypedEmitter {
    transport = {};
    transports = [];
    devices = createDeviceCollection();
    deviceCounter = Date.now();
    handshakeLock;
    authPenaltyManager;
    transportCommonArgs;
    isConnected() {
        return !!Object.keys(this.transport).length;
    }
    pendingConnection() {
        const pending = Object.values(this.locks)
            .map(({ promise }) => promise)
            .filter(utils_1.isNotUndefined);
        if (pending.length)
            return Promise.all(pending).then(() => { });
    }
    getActiveTransports() {
        return Object.values(this.transport).map(getTransportInfo);
    }
    locks = {};
    async transportLock(apiType, abortMessage, action) {
        const lock = this.locks[apiType] ?? (this.locks[apiType] = { sequence: 0 });
        lock.abortMessage = abortMessage;
        const sequence = ++lock.sequence;
        while (lock.promise) {
            lock.abort?.abort(new Error(abortMessage));
            await lock.promise.catch(() => { });
        }
        if (sequence !== lock.sequence)
            return Promise.reject(new Error(lock.abortMessage));
        lock.abort = new AbortController();
        lock.promise = action(lock.abort.signal).finally(() => {
            delete lock.abort;
            delete lock.promise;
        });
        return lock.promise;
    }
    scheduledUpgradeChecks = {};
    constructor({ messages, priority, debug, _sessionsBackgroundUrl, manifest, }) {
        super();
        const transportLogger = (0, debug_1.initLog)('@trezor/transport', debug);
        this.handshakeLock = (0, utils_1.getSynchronize)();
        this.authPenaltyManager = createAuthPenaltyManager(priority);
        this.transportCommonArgs = {
            messages,
            logger: transportLogger,
            sessionsBackgroundUrl: _sessionsBackgroundUrl,
            id: manifest?.appUrl || 'unknown app',
        };
    }
    tryGetTransport(name) {
        return this.transports.find(t => t.name === name);
    }
    getOrCreateTransport(transportType) {
        const { transportCommonArgs } = this;
        if (typeof transportType === 'string') {
            const existing = this.tryGetTransport(transportType);
            if (existing)
                return existing;
            switch (transportType) {
                case 'WebUsbTransport':
                    return new transport_1.WebUsbTransport(transportCommonArgs);
                case 'NodeUsbTransport':
                    return new transport_1.NodeUsbTransport(transportCommonArgs);
                case 'BridgeTransport':
                    return new transport_1.BridgeTransport({
                        latestVersion: (0, transportInfo_1.getBridgeInfo)().version.join('.'),
                        ...transportCommonArgs,
                    });
                case 'UdpTransport':
                    return new transport_1.UdpTransport(transportCommonArgs);
            }
        }
        else if (typeof transportType === 'function' && 'prototype' in transportType) {
            const transportInstance = new transportType(transportCommonArgs);
            if ((0, transport_1.isTransportInstance)(transportInstance)) {
                return this.tryGetTransport(transportInstance.name) ?? transportInstance;
            }
        }
        else if ((0, transport_1.isTransportInstance)(transportType)) {
            if (this.tryGetTransport(transportType.name)) {
                return transportType;
            }
            if (!transportType.getMessage()) {
                transportType.updateMessages(transportCommonArgs.messages);
            }
            return transportType;
        }
        throw constants_1.ERRORS.TypedError('Runtime', `DeviceList.init: transports[] of unexpected type: ${transportType}`);
    }
    createTransports(transports) {
        const transportTypes = transports?.length ? transports : ['BridgeTransport'];
        return transportTypes.map(this.getOrCreateTransport.bind(this));
    }
    onDeviceConnected(descriptor, transport) {
        const id = (this.deviceCounter++).toString(16).slice(-8);
        const device = new Device_1.Device({
            id: (0, types_1.DeviceUniquePath)(id),
            transport,
            descriptor,
            listener: lifecycle => this.emit(lifecycle, device),
        });
        this.devices.add(device);
        const penalty = this.authPenaltyManager.get();
        this.handshakeLock(async () => {
            if (this.devices.get(descriptor.path, transport)) {
                await device.handshake(penalty);
            }
        });
    }
    onDeviceDisconnected(descriptor, transport) {
        const device = this.devices.remove(descriptor.path, transport);
        device?.disconnect();
    }
    onDeviceSessionChanged(descriptor, transport) {
        const device = this.devices.get(descriptor.path, transport);
        device?.updateDescriptor(descriptor);
    }
    onDeviceRequestRelease(descriptor, transport) {
        const device = this.devices.get(descriptor.path, transport);
        device?.usedElsewhere();
    }
    async init(initParams = {}) {
        this.transports = this.createTransports(initParams.transports);
        const promises = this.transports
            .map(t => t.apiType)
            .concat((0, utils_2.typedObjectKeys)(this.transport))
            .concat((0, utils_2.typedObjectKeys)(this.locks))
            .filter(utils_1.arrayDistinct)
            .map(apiType => this.transportLock(apiType, 'New init', signal => this.createInitPromise(apiType, initParams, signal)));
        await Promise.all(promises);
    }
    async createInitPromise(apiType, initParams, abortSignal) {
        try {
            const transports = this.transports.filter(t => t.apiType === apiType);
            const transport = transports.length
                ? await this.selectTransport(transports, abortSignal)
                : undefined;
            const oldTransport = this.transport[apiType];
            if (oldTransport !== transport) {
                if (oldTransport) {
                    delete this.transport[apiType];
                    await this.stopTransport(oldTransport);
                    if (!transport) {
                        this.emit(transport_1.TRANSPORT.ERROR, { apiType, error: 'Transport disabled' });
                    }
                }
                if (transport) {
                    try {
                        await this.initializeTransport(transport, initParams, abortSignal);
                    }
                    catch (error) {
                        await this.stopTransport(transport);
                        throw error;
                    }
                    transport.on(transport_1.TRANSPORT.ERROR, error => {
                        this.emit(transport_1.TRANSPORT.ERROR, { apiType, error });
                        this.transportLock(apiType, 'Transport error', async (signal) => {
                            delete this.transport[apiType];
                            await this.stopTransport(transport);
                            if (initParams.transportReconnect) {
                                await this.createReconnectDelay(signal);
                                await this.createInitPromise(apiType, initParams, signal);
                            }
                        }).catch(() => { });
                    });
                    this.transport[apiType] = transport;
                    this.emit(transport_1.TRANSPORT.START, getTransportInfo(transport));
                }
            }
            if (transport && transport !== transports[0]) {
                this.scheduleUpgradeCheck(apiType, initParams);
            }
        }
        catch (error) {
            this.emit(transport_1.TRANSPORT.ERROR, { apiType, error: error?.message });
            if (initParams.transportReconnect && !abortSignal.aborted) {
                this.transportLock(apiType, 'Reconnecting', async (signal) => {
                    await this.createReconnectDelay(signal);
                    await this.createInitPromise(apiType, initParams, signal);
                }).catch(() => { });
            }
        }
    }
    createReconnectDelay(signal) {
        return (0, utils_1.resolveAfter)(1000, signal);
    }
    scheduleUpgradeCheck(apiType, initParams) {
        clearTimeout(this.scheduledUpgradeChecks[apiType]);
        this.scheduledUpgradeChecks[apiType] = setTimeout(async () => {
            const transport = this.transport[apiType];
            const transports = this.transports.filter(t => t.apiType === apiType);
            if (!transport || transport === transports[0])
                return;
            for (const t of transports) {
                if (t === transport)
                    break;
                if (await t.ping()) {
                    this.transportLock(apiType, 'Upgrading', signal => this.createInitPromise(apiType, initParams, signal)).catch(() => { });
                    return;
                }
            }
            this.scheduleUpgradeCheck(apiType, initParams);
        }, 1000);
    }
    async selectTransport([transport, ...rest], signal) {
        if (signal.aborted)
            throw new Error(signal.reason);
        if (transport === this.transport[transport.apiType])
            return transport;
        const result = await transport.init({ signal });
        if (result.success)
            return transport;
        else if (rest.length)
            return this.selectTransport(rest, signal);
        else
            throw new Error(result.error);
    }
    async initializeTransport(transport, initParams, signal) {
        transport.on(transport_1.TRANSPORT.DEVICE_CONNECTED, d => this.onDeviceConnected(d, transport));
        transport.on(transport_1.TRANSPORT.DEVICE_DISCONNECTED, d => this.onDeviceDisconnected(d, transport));
        transport.on(transport_1.TRANSPORT.DEVICE_SESSION_CHANGED, d => this.onDeviceSessionChanged(d, transport));
        transport.on(transport_1.TRANSPORT.DEVICE_REQUEST_RELEASE, d => this.onDeviceRequestRelease(d, transport));
        const enumerateResult = await transport.enumerate({ signal });
        if (!enumerateResult.success) {
            throw new Error(enumerateResult.error);
        }
        const descriptors = enumerateResult.payload;
        const waitForDevicesPromise = initParams.pendingTransportEvent && descriptors.length
            ? this.waitForDevices(transport, descriptors, signal)
            : Promise.resolve();
        transport.handleDescriptorsChange(descriptors);
        transport.listen();
        await waitForDevicesPromise;
    }
    waitForDevices(transport, descriptors, signal) {
        const { promise, reject, resolve } = (0, utils_1.createDeferred)();
        const onAbort = () => reject(signal.reason);
        signal.addEventListener('abort', onAbort);
        const onError = (error) => reject(new Error(error));
        transport.once(transport_1.TRANSPORT.ERROR, onError);
        const autoResolveTransportEventTimeout = setTimeout(resolve, 10000);
        const remaining = descriptors.slice();
        const onDeviceEvent = (device) => {
            const index = remaining.findIndex(d => d.path === device.transportPath && transport === device.transport);
            if (index >= 0)
                remaining.splice(index, 1);
            if (!remaining.length)
                resolve();
        };
        this.on(events_1.DEVICE.CONNECT, onDeviceEvent);
        this.on(events_1.DEVICE.CONNECT_UNACQUIRED, onDeviceEvent);
        this.on(events_1.DEVICE.DISCONNECT, onDeviceEvent);
        return promise.finally(() => {
            transport.off(transport_1.TRANSPORT.ERROR, onError);
            signal.removeEventListener('abort', onAbort);
            clearTimeout(autoResolveTransportEventTimeout);
            this.off(events_1.DEVICE.CONNECT, onDeviceEvent);
            this.off(events_1.DEVICE.CONNECT_UNACQUIRED, onDeviceEvent);
            this.off(events_1.DEVICE.DISCONNECT, onDeviceEvent);
        });
    }
    getDeviceCount() {
        return this.devices.all().length;
    }
    getAllDevices() {
        return this.devices.all();
    }
    getOnlyDevice() {
        return this.getDeviceCount() === 1 ? this.devices.all()[0] : undefined;
    }
    getDeviceByPath(path) {
        return this.devices.all().find(d => d.getUniquePath() === path);
    }
    getDeviceByStaticState(state) {
        const deviceId = state.split('@')[1].split(':')[0];
        return this.devices.all().find(d => d.features?.device_id === deviceId);
    }
    async dispose() {
        this.removeAllListeners();
        const promises = (0, utils_2.typedObjectKeys)(this.transport)
            .concat((0, utils_2.typedObjectKeys)(this.locks))
            .filter(utils_1.arrayDistinct)
            .map(apiType => this.transportLock(apiType, 'Disposing', async () => {
            const transport = this.transport[apiType];
            if (transport) {
                delete this.transport[apiType];
                await this.stopTransport(transport);
            }
        }));
        await Promise.all(promises);
    }
    async stopTransport(transport) {
        clearTimeout(this.scheduledUpgradeChecks[transport.apiType]);
        const devices = this.devices.clear(transport);
        devices.forEach(device => {
            this.emit(events_1.DEVICE.DISCONNECT, device);
        });
        await Promise.all(devices.map(async (device) => {
            this.authPenaltyManager.remove(device);
            await device.dispose();
        }));
        transport?.stop();
    }
    async enumerate() {
        const promises = Object.values(this.transport).map(async (transport) => {
            const res = await transport.enumerate();
            if (!res.success) {
                return;
            }
            res.payload.forEach(d => {
                this.devices.get(d.path, transport)?.updateDescriptor(d);
            });
        });
        await Promise.all(promises);
    }
    addAuthPenalty(device) {
        return this.authPenaltyManager.add(device);
    }
    removeAuthPenalty(device) {
        return this.authPenaltyManager.remove(device);
    }
}
exports.DeviceList = DeviceList;
//# sourceMappingURL=DeviceList.js.map