"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySchnorr = exports.verify = exports.signSchnorr = exports.sign = exports.privateNegate = exports.privateAdd = exports.pointAddScalar = exports.pointCompress = exports.pointFromScalar = exports.xOnlyPointAddTweak = exports.isXOnlyPoint = exports.isPrivate = exports.isPointCompressed = exports.isPoint = void 0;
// https://github.com/bitcoinerlab/secp256k1
const secp256k1_1 = require("@noble/curves/secp256k1");
const mod = __importStar(require("@noble/curves/abstract/modular"));
const utils = __importStar(require("@noble/curves/abstract/utils"));
const Point = secp256k1_1.secp256k1.ProjectivePoint;
const THROW_BAD_PRIVATE = "Expected Private";
const THROW_BAD_POINT = "Expected Point";
const THROW_BAD_TWEAK = "Expected Tweak";
const THROW_BAD_SIGNATURE = "Expected Signature";
const THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
const THROW_BAD_SCALAR = "Expected Scalar";
const HASH_SIZE = 32;
const TWEAK_SIZE = 32;
const BN32_N = new Uint8Array([
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,
]);
const EXTRA_DATA_SIZE = 32;
const _1n = BigInt(1);
function cmpBN32(data1, data2) {
    for (let i = 0; i < 32; ++i) {
        if (data1[i] !== data2[i]) {
            return data1[i] < data2[i] ? -1 : 1;
        }
    }
    return 0;
}
function isTweak(tweak) {
    if (!(tweak instanceof Uint8Array) ||
        tweak.length !== TWEAK_SIZE ||
        cmpBN32(tweak, BN32_N) >= 0) {
        return false;
    }
    return true;
}
function isSignature(signature) {
    return (signature instanceof Uint8Array &&
        signature.length === 64 &&
        cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&
        cmpBN32(signature.subarray(32, 64), BN32_N) < 0);
}
function isHash(h) {
    return h instanceof Uint8Array && h.length === HASH_SIZE;
}
function isExtraData(e) {
    return (e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE));
}
function normalizeScalar(scalar) {
    let num;
    if (typeof scalar === "bigint") {
        num = scalar;
    }
    else if (typeof scalar === "number" &&
        Number.isSafeInteger(scalar) &&
        scalar >= 0) {
        num = BigInt(scalar);
    }
    else if (typeof scalar === "string") {
        if (scalar.length !== 64)
            throw new Error("Expected 32 bytes of private scalar");
        num = utils.hexToNumber(scalar);
    }
    else if (scalar instanceof Uint8Array) {
        if (scalar.length !== 32)
            throw new Error("Expected 32 bytes of private scalar");
        num = utils.bytesToNumberBE(scalar);
    }
    else {
        throw new TypeError("Expected valid private scalar");
    }
    if (num < 0)
        throw new Error("Expected private scalar >= 0");
    return num;
}
function normalizePrivateKey(privateKey) {
    return secp256k1_1.secp256k1.utils.normPrivateKeyToScalar(privateKey);
}
function _privateAdd(privateKey, tweak) {
    const p = normalizePrivateKey(privateKey);
    const t = normalizeScalar(tweak);
    const add = utils.numberToBytesBE(mod.mod(p + t, secp256k1_1.secp256k1.CURVE.n), 32);
    return secp256k1_1.secp256k1.utils.isValidPrivateKey(add) ? add : null;
}
function _privateNegate(privateKey) {
    const p = normalizePrivateKey(privateKey);
    const not = utils.numberToBytesBE(secp256k1_1.secp256k1.CURVE.n - p, 32);
    return secp256k1_1.secp256k1.utils.isValidPrivateKey(not) ? not : null;
}
function _pointAddScalar(p, tweak, isCompressed) {
    const P = fromHex(p);
    const t = normalizeScalar(tweak);
    // multiplyAndAddUnsafe(P, scalar, 1) = P + scalar*G
    const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
    if (!Q)
        throw new Error("Tweaked point at infinity");
    return Q.toRawBytes(isCompressed);
}
function assumeCompression(compressed, p) {
    if (compressed === undefined) {
        return p !== undefined ? isPointCompressed(p) : true;
    }
    return !!compressed;
}
function throwToNull(fn) {
    try {
        return fn();
    }
    catch (e) {
        return null;
    }
}
function fromXOnly(bytes) {
    return secp256k1_1.schnorr.utils.lift_x(utils.bytesToNumberBE(bytes));
}
function fromHex(bytes) {
    return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);
}
function _isPoint(p, xOnly) {
    if ((p.length === 32) !== xOnly)
        return false;
    try {
        if (xOnly)
            return !!fromXOnly(p);
        else
            return !!Point.fromHex(p);
    }
    catch (e) {
        return false;
    }
}
function isPoint(p) {
    return _isPoint(p, false);
}
exports.isPoint = isPoint;
function isPointCompressed(p) {
    const PUBLIC_KEY_COMPRESSED_SIZE = 33;
    return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
}
exports.isPointCompressed = isPointCompressed;
function isPrivate(d) {
    return secp256k1_1.secp256k1.utils.isValidPrivateKey(d);
}
exports.isPrivate = isPrivate;
function isXOnlyPoint(p) {
    return _isPoint(p, true);
}
exports.isXOnlyPoint = isXOnlyPoint;
function xOnlyPointAddTweak(p, tweak) {
    if (!isXOnlyPoint(p)) {
        throw new Error(THROW_BAD_POINT);
    }
    if (!isTweak(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
    }
    return throwToNull(() => {
        const P = _pointAddScalar(p, tweak, true);
        const parity = P[0] % 2 === 1 ? 1 : 0;
        return { parity, xOnlyPubkey: P.slice(1) };
    });
}
exports.xOnlyPointAddTweak = xOnlyPointAddTweak;
function pointFromScalar(sk, compressed) {
    if (!isPrivate(sk)) {
        throw new Error(THROW_BAD_PRIVATE);
    }
    return throwToNull(() => secp256k1_1.secp256k1.getPublicKey(sk, assumeCompression(compressed)));
}
exports.pointFromScalar = pointFromScalar;
function pointCompress(p, compressed) {
    if (!isPoint(p)) {
        throw new Error(THROW_BAD_POINT);
    }
    return fromHex(p).toRawBytes(assumeCompression(compressed, p));
}
exports.pointCompress = pointCompress;
function pointAddScalar(p, tweak, compressed) {
    if (!isPoint(p)) {
        throw new Error(THROW_BAD_POINT);
    }
    if (!isTweak(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
    }
    return throwToNull(() => _pointAddScalar(p, tweak, assumeCompression(compressed, p)));
}
exports.pointAddScalar = pointAddScalar;
function privateAdd(d, tweak) {
    if (!isPrivate(d)) {
        throw new Error(THROW_BAD_PRIVATE);
    }
    if (!isTweak(tweak)) {
        throw new Error(THROW_BAD_TWEAK);
    }
    return throwToNull(() => _privateAdd(d, tweak));
}
exports.privateAdd = privateAdd;
function privateNegate(d) {
    if (!isPrivate(d)) {
        throw new Error(THROW_BAD_PRIVATE);
    }
    const result = _privateNegate(d);
    if (!result) {
        throw new Error(THROW_BAD_PRIVATE);
    }
    return result;
}
exports.privateNegate = privateNegate;
function sign(h, d, e) {
    if (!isPrivate(d)) {
        throw new Error(THROW_BAD_PRIVATE);
    }
    if (!isHash(h)) {
        throw new Error(THROW_BAD_SCALAR);
    }
    if (!isExtraData(e)) {
        throw new Error(THROW_BAD_EXTRA_DATA);
    }
    return secp256k1_1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();
}
exports.sign = sign;
function signSchnorr(h, d, e) {
    if (!isPrivate(d)) {
        throw new Error(THROW_BAD_PRIVATE);
    }
    if (!isHash(h)) {
        throw new Error(THROW_BAD_SCALAR);
    }
    if (!isExtraData(e)) {
        throw new Error(THROW_BAD_EXTRA_DATA);
    }
    return secp256k1_1.schnorr.sign(h, d, e);
}
exports.signSchnorr = signSchnorr;
function verify(h, Q, signature, strict) {
    if (!isPoint(Q)) {
        throw new Error(THROW_BAD_POINT);
    }
    if (!isSignature(signature)) {
        throw new Error(THROW_BAD_SIGNATURE);
    }
    if (!isHash(h)) {
        throw new Error(THROW_BAD_SCALAR);
    }
    return secp256k1_1.secp256k1.verify(signature, h, Q, { lowS: strict });
}
exports.verify = verify;
function verifySchnorr(h, Q, signature) {
    if (!isXOnlyPoint(Q)) {
        throw new Error(THROW_BAD_POINT);
    }
    if (!isSignature(signature)) {
        throw new Error(THROW_BAD_SIGNATURE);
    }
    if (!isHash(h)) {
        throw new Error(THROW_BAD_SCALAR);
    }
    return secp256k1_1.schnorr.verify(signature, h, Q);
}
exports.verifySchnorr = verifySchnorr;
//# sourceMappingURL=ecc-adapter.js.map