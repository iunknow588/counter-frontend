/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "babylon.btccheckpoint.v1";

/** BtcStatus is an enum describing the current btc status of the checkpoint */
export enum BtcStatus {
  /**
   * EPOCH_STATUS_SUBMITTED - SUBMITTED Epoch has Submitted btc status if there ever was at least one
   * known submission on btc main chain
   */
  EPOCH_STATUS_SUBMITTED = 0,
  /**
   * EPOCH_STATUS_CONFIRMED - CONFIRMED Epoch has Confirmed btc status if there ever was at least one
   * known submission on btc main chain which was k-deep
   */
  EPOCH_STATUS_CONFIRMED = 1,
  /**
   * EPOCH_STATUS_FINALIZED - CONFIRMED Epoch has Finalized btc status if there is was at exactly one
   * knon submission on btc main chain which is w-deep
   */
  EPOCH_STATUS_FINALIZED = 2,
  UNRECOGNIZED = -1,
}

export function btcStatusFromJSON(object: any): BtcStatus {
  switch (object) {
    case 0:
    case "EPOCH_STATUS_SUBMITTED":
      return BtcStatus.EPOCH_STATUS_SUBMITTED;
    case 1:
    case "EPOCH_STATUS_CONFIRMED":
      return BtcStatus.EPOCH_STATUS_CONFIRMED;
    case 2:
    case "EPOCH_STATUS_FINALIZED":
      return BtcStatus.EPOCH_STATUS_FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BtcStatus.UNRECOGNIZED;
  }
}

export function btcStatusToJSON(object: BtcStatus): string {
  switch (object) {
    case BtcStatus.EPOCH_STATUS_SUBMITTED:
      return "EPOCH_STATUS_SUBMITTED";
    case BtcStatus.EPOCH_STATUS_CONFIRMED:
      return "EPOCH_STATUS_CONFIRMED";
    case BtcStatus.EPOCH_STATUS_FINALIZED:
      return "EPOCH_STATUS_FINALIZED";
    default:
      return "UNKNOWN";
  }
}

/**
 * Consider we have a Merkle tree with following structure:
 *            ROOT
 *           /    \
 *      H1234      H5555
 *     /     \       \
 *   H12     H34      H55
 *  /  \    /  \     /
 * H1  H2  H3  H4  H5
 * L1  L2  L3  L4  L5
 * To prove L3 was part of ROOT we need:
 * - btc_transaction_index = 2 which in binary is 010
 * (where 0 means going left, 1 means going right in the tree)
 * - merkle_nodes we'd have H4 || H12 || H5555
 * By looking at 010 we would know that H4 is a right sibling,
 * H12 is left, H5555 is right again.
 */
export interface BTCSpvProof {
  /** Valid bitcoin transaction containing OP_RETURN opcode. */
  btcTransaction: Uint8Array;
  /**
   * Index of transaction within the block. Index is needed to determine if
   * currently hashed node is left or right.
   */
  btcTransactionIndex: number;
  /**
   * List of concatenated intermediate merkle tree nodes, without root node and
   * leaf node against which we calculate the proof. Each node has 32 byte
   * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
   * ||  32_bytes_of_node3 so the length of the proof will always be divisible
   * by 32.
   */
  merkleNodes: Uint8Array;
  /**
   * Valid btc header which confirms btc_transaction.
   * Should have exactly 80 bytes
   */
  confirmingBtcHeader: Uint8Array;
}

/**
 * Each provided OP_RETURN transaction can be identified by hash of block in
 * which transaction was included and transaction index in the block
 */
export interface TransactionKey {
  index: number;
  hash: Uint8Array;
}

/**
 * Checkpoint can be composed from multiple transactions, so to identify whole
 * submission we need list of transaction keys.
 * Each submission can generally be identified by this list of (txIdx,
 * blockHash) tuples. Note: this could possibly be optimized as if transactions
 * were in one block they would have the same block hash and different indexes,
 * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
 * so there should be other strong arguments for this optimization
 */
export interface SubmissionKey {
  key: TransactionKey[];
}

/**
 * TransactionInfo is the info of a tx on Bitcoin,
 * including
 * - the position of the tx on BTC blockchain
 * - the full tx content
 * - the Merkle proof that this tx is on the above position
 */
export interface TransactionInfo {
  /**
   * key is the position (txIdx, blockHash) of this tx on BTC blockchain
   * Although it is already a part of SubmissionKey, we store it here again
   * to make TransactionInfo self-contained.
   * For example, storing the key allows TransactionInfo to not relay on
   * the fact that TransactionInfo will be ordered in the same order as
   * TransactionKeys in SubmissionKey.
   */
  key: TransactionKey | undefined;
  /** transaction is the full transaction in bytes */
  transaction: Uint8Array;
  /**
   * proof is the Merkle proof that this tx is included in the position in `key`
   * TODO: maybe it could use here better format as we already processed and
   * validated the proof?
   */
  proof: Uint8Array;
}

/**
 * TODO: Determine if we should keep any block number or depth info.
 * On one hand it may be useful to determine if block is stable or not, on
 * other depth/block number info, without context (i.e info about chain) is
 * pretty useless and blockhash in enough to retrieve is from lightclient
 */
export interface SubmissionData {
  /** address of the submitter and reporter */
  vigilanteAddresses: CheckpointAddresses | undefined;
  /**
   * txs_info is the two `TransactionInfo`s corresponding to the submission
   * It is used for
   * - recovering address of sender of btc transaction to payup the reward.
   * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
   * BTC
   */
  txsInfo: TransactionInfo[];
  epoch: string;
}

/**
 * Data stored in db and indexed by epoch number
 * TODO: Add btc blockheight at epoch end, when adding handling of epoching
 * callbacks
 */
export interface EpochData {
  /**
   * keys is the list of all received checkpoints during this epoch, sorted by
   * order of submission.
   */
  keys: SubmissionKey[];
  /** status is the current btc status of the epoch */
  status: BtcStatus;
}

/**
 * CheckpointAddresses contains the addresses of the submitter and reporter of a
 * given checkpoint
 */
export interface CheckpointAddresses {
  /**
   * TODO: this could probably be better typed
   * submitter is the address of the checkpoint submitter to BTC, extracted from
   * the checkpoint itself.
   */
  submitter: Uint8Array;
  /**
   * reporter is the address of the reporter who reported the submissions,
   * calculated from submission message MsgInsertBTCSpvProof itself
   */
  reporter: Uint8Array;
}

/**
 * BTCCheckpointInfo contains all data about best submission of checkpoint for
 * given epoch. Best submission is the submission which is deeper in btc ledger
 */
export interface BTCCheckpointInfo {
  /** epoch number of this checkpoint */
  epochNumber: string;
  /** btc height of the best submission of the epoch */
  bestSubmissionBtcBlockHeight: number;
  /**
   * hash of the btc block which determines checkpoint btc block height i.e.
   * youngest block of best submission
   */
  bestSubmissionBtcBlockHash: Uint8Array;
  /** the BTC checkpoint transactions of the best submission */
  bestSubmissionTransactions: TransactionInfo[];
  /** list of vigilantes' addresses of the best submission */
  bestSubmissionVigilanteAddressList: CheckpointAddresses[];
}

function createBaseBTCSpvProof(): BTCSpvProof {
  return {
    btcTransaction: new Uint8Array(),
    btcTransactionIndex: 0,
    merkleNodes: new Uint8Array(),
    confirmingBtcHeader: new Uint8Array(),
  };
}

export const BTCSpvProof = {
  encode(
    message: BTCSpvProof,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.btcTransaction.length !== 0) {
      writer.uint32(10).bytes(message.btcTransaction);
    }
    if (message.btcTransactionIndex !== 0) {
      writer.uint32(16).uint32(message.btcTransactionIndex);
    }
    if (message.merkleNodes.length !== 0) {
      writer.uint32(26).bytes(message.merkleNodes);
    }
    if (message.confirmingBtcHeader.length !== 0) {
      writer.uint32(34).bytes(message.confirmingBtcHeader);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCSpvProof {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCSpvProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.btcTransaction = reader.bytes();
          break;
        case 2:
          message.btcTransactionIndex = reader.uint32();
          break;
        case 3:
          message.merkleNodes = reader.bytes();
          break;
        case 4:
          message.confirmingBtcHeader = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BTCSpvProof {
    return {
      btcTransaction: isSet(object.btcTransaction)
        ? bytesFromBase64(object.btcTransaction)
        : new Uint8Array(),
      btcTransactionIndex: isSet(object.btcTransactionIndex)
        ? Number(object.btcTransactionIndex)
        : 0,
      merkleNodes: isSet(object.merkleNodes)
        ? bytesFromBase64(object.merkleNodes)
        : new Uint8Array(),
      confirmingBtcHeader: isSet(object.confirmingBtcHeader)
        ? bytesFromBase64(object.confirmingBtcHeader)
        : new Uint8Array(),
    };
  },

  toJSON(message: BTCSpvProof): unknown {
    const obj: any = {};
    message.btcTransaction !== undefined &&
      (obj.btcTransaction = base64FromBytes(
        message.btcTransaction !== undefined
          ? message.btcTransaction
          : new Uint8Array()
      ));
    message.btcTransactionIndex !== undefined &&
      (obj.btcTransactionIndex = Math.round(message.btcTransactionIndex));
    message.merkleNodes !== undefined &&
      (obj.merkleNodes = base64FromBytes(
        message.merkleNodes !== undefined
          ? message.merkleNodes
          : new Uint8Array()
      ));
    message.confirmingBtcHeader !== undefined &&
      (obj.confirmingBtcHeader = base64FromBytes(
        message.confirmingBtcHeader !== undefined
          ? message.confirmingBtcHeader
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BTCSpvProof>, I>>(
    object: I
  ): BTCSpvProof {
    const message = createBaseBTCSpvProof();
    message.btcTransaction = object.btcTransaction ?? new Uint8Array();
    message.btcTransactionIndex = object.btcTransactionIndex ?? 0;
    message.merkleNodes = object.merkleNodes ?? new Uint8Array();
    message.confirmingBtcHeader =
      object.confirmingBtcHeader ?? new Uint8Array();
    return message;
  },
};

function createBaseTransactionKey(): TransactionKey {
  return { index: 0, hash: new Uint8Array() };
}

export const TransactionKey = {
  encode(
    message: TransactionKey,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionKey {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.uint32();
          break;
        case 2:
          message.hash = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionKey {
    return {
      index: isSet(object.index) ? Number(object.index) : 0,
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(),
    };
  },

  toJSON(message: TransactionKey): unknown {
    const obj: any = {};
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.hash !== undefined &&
      (obj.hash = base64FromBytes(
        message.hash !== undefined ? message.hash : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TransactionKey>, I>>(
    object: I
  ): TransactionKey {
    const message = createBaseTransactionKey();
    message.index = object.index ?? 0;
    message.hash = object.hash ?? new Uint8Array();
    return message;
  },
};

function createBaseSubmissionKey(): SubmissionKey {
  return { key: [] };
}

export const SubmissionKey = {
  encode(
    message: SubmissionKey,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.key) {
      TransactionKey.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmissionKey {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key.push(TransactionKey.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubmissionKey {
    return {
      key: Array.isArray(object?.key)
        ? object.key.map((e: any) => TransactionKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmissionKey): unknown {
    const obj: any = {};
    if (message.key) {
      obj.key = message.key.map((e) =>
        e ? TransactionKey.toJSON(e) : undefined
      );
    } else {
      obj.key = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SubmissionKey>, I>>(
    object: I
  ): SubmissionKey {
    const message = createBaseSubmissionKey();
    message.key = object.key?.map((e) => TransactionKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionInfo(): TransactionInfo {
  return {
    key: undefined,
    transaction: new Uint8Array(),
    proof: new Uint8Array(),
  };
}

export const TransactionInfo = {
  encode(
    message: TransactionInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== undefined) {
      TransactionKey.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.transaction.length !== 0) {
      writer.uint32(18).bytes(message.transaction);
    }
    if (message.proof.length !== 0) {
      writer.uint32(26).bytes(message.proof);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = TransactionKey.decode(reader, reader.uint32());
          break;
        case 2:
          message.transaction = reader.bytes();
          break;
        case 3:
          message.proof = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      key: isSet(object.key) ? TransactionKey.fromJSON(object.key) : undefined,
      transaction: isSet(object.transaction)
        ? bytesFromBase64(object.transaction)
        : new Uint8Array(),
      proof: isSet(object.proof)
        ? bytesFromBase64(object.proof)
        : new Uint8Array(),
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    message.key !== undefined &&
      (obj.key = message.key ? TransactionKey.toJSON(message.key) : undefined);
    message.transaction !== undefined &&
      (obj.transaction = base64FromBytes(
        message.transaction !== undefined
          ? message.transaction
          : new Uint8Array()
      ));
    message.proof !== undefined &&
      (obj.proof = base64FromBytes(
        message.proof !== undefined ? message.proof : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TransactionInfo>, I>>(
    object: I
  ): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.key =
      object.key !== undefined && object.key !== null
        ? TransactionKey.fromPartial(object.key)
        : undefined;
    message.transaction = object.transaction ?? new Uint8Array();
    message.proof = object.proof ?? new Uint8Array();
    return message;
  },
};

function createBaseSubmissionData(): SubmissionData {
  return { vigilanteAddresses: undefined, txsInfo: [], epoch: "0" };
}

export const SubmissionData = {
  encode(
    message: SubmissionData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.vigilanteAddresses !== undefined) {
      CheckpointAddresses.encode(
        message.vigilanteAddresses,
        writer.uint32(10).fork()
      ).ldelim();
    }
    for (const v of message.txsInfo) {
      TransactionInfo.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.epoch !== "0") {
      writer.uint32(24).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmissionData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vigilanteAddresses = CheckpointAddresses.decode(
            reader,
            reader.uint32()
          );
          break;
        case 2:
          message.txsInfo.push(TransactionInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.epoch = longToString(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubmissionData {
    return {
      vigilanteAddresses: isSet(object.vigilanteAddresses)
        ? CheckpointAddresses.fromJSON(object.vigilanteAddresses)
        : undefined,
      txsInfo: Array.isArray(object?.txsInfo)
        ? object.txsInfo.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
      epoch: isSet(object.epoch) ? String(object.epoch) : "0",
    };
  },

  toJSON(message: SubmissionData): unknown {
    const obj: any = {};
    message.vigilanteAddresses !== undefined &&
      (obj.vigilanteAddresses = message.vigilanteAddresses
        ? CheckpointAddresses.toJSON(message.vigilanteAddresses)
        : undefined);
    if (message.txsInfo) {
      obj.txsInfo = message.txsInfo.map((e) =>
        e ? TransactionInfo.toJSON(e) : undefined
      );
    } else {
      obj.txsInfo = [];
    }
    message.epoch !== undefined && (obj.epoch = message.epoch);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SubmissionData>, I>>(
    object: I
  ): SubmissionData {
    const message = createBaseSubmissionData();
    message.vigilanteAddresses =
      object.vigilanteAddresses !== undefined &&
      object.vigilanteAddresses !== null
        ? CheckpointAddresses.fromPartial(object.vigilanteAddresses)
        : undefined;
    message.txsInfo =
      object.txsInfo?.map((e) => TransactionInfo.fromPartial(e)) || [];
    message.epoch = object.epoch ?? "0";
    return message;
  },
};

function createBaseEpochData(): EpochData {
  return { keys: [], status: 0 };
}

export const EpochData = {
  encode(
    message: EpochData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.keys) {
      SubmissionKey.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EpochData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEpochData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keys.push(SubmissionKey.decode(reader, reader.uint32()));
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EpochData {
    return {
      keys: Array.isArray(object?.keys)
        ? object.keys.map((e: any) => SubmissionKey.fromJSON(e))
        : [],
      status: isSet(object.status) ? btcStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EpochData): unknown {
    const obj: any = {};
    if (message.keys) {
      obj.keys = message.keys.map((e) =>
        e ? SubmissionKey.toJSON(e) : undefined
      );
    } else {
      obj.keys = [];
    }
    message.status !== undefined &&
      (obj.status = btcStatusToJSON(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EpochData>, I>>(
    object: I
  ): EpochData {
    const message = createBaseEpochData();
    message.keys = object.keys?.map((e) => SubmissionKey.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCheckpointAddresses(): CheckpointAddresses {
  return { submitter: new Uint8Array(), reporter: new Uint8Array() };
}

export const CheckpointAddresses = {
  encode(
    message: CheckpointAddresses,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.submitter.length !== 0) {
      writer.uint32(10).bytes(message.submitter);
    }
    if (message.reporter.length !== 0) {
      writer.uint32(18).bytes(message.reporter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckpointAddresses {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckpointAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.submitter = reader.bytes();
          break;
        case 2:
          message.reporter = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CheckpointAddresses {
    return {
      submitter: isSet(object.submitter)
        ? bytesFromBase64(object.submitter)
        : new Uint8Array(),
      reporter: isSet(object.reporter)
        ? bytesFromBase64(object.reporter)
        : new Uint8Array(),
    };
  },

  toJSON(message: CheckpointAddresses): unknown {
    const obj: any = {};
    message.submitter !== undefined &&
      (obj.submitter = base64FromBytes(
        message.submitter !== undefined ? message.submitter : new Uint8Array()
      ));
    message.reporter !== undefined &&
      (obj.reporter = base64FromBytes(
        message.reporter !== undefined ? message.reporter : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CheckpointAddresses>, I>>(
    object: I
  ): CheckpointAddresses {
    const message = createBaseCheckpointAddresses();
    message.submitter = object.submitter ?? new Uint8Array();
    message.reporter = object.reporter ?? new Uint8Array();
    return message;
  },
};

function createBaseBTCCheckpointInfo(): BTCCheckpointInfo {
  return {
    epochNumber: "0",
    bestSubmissionBtcBlockHeight: 0,
    bestSubmissionBtcBlockHash: new Uint8Array(),
    bestSubmissionTransactions: [],
    bestSubmissionVigilanteAddressList: [],
  };
}

export const BTCCheckpointInfo = {
  encode(
    message: BTCCheckpointInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.epochNumber !== "0") {
      writer.uint32(8).uint64(message.epochNumber);
    }
    if (message.bestSubmissionBtcBlockHeight !== 0) {
      writer.uint32(16).uint32(message.bestSubmissionBtcBlockHeight);
    }
    if (message.bestSubmissionBtcBlockHash.length !== 0) {
      writer.uint32(26).bytes(message.bestSubmissionBtcBlockHash);
    }
    for (const v of message.bestSubmissionTransactions) {
      TransactionInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.bestSubmissionVigilanteAddressList) {
      CheckpointAddresses.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCCheckpointInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCCheckpointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.epochNumber = longToString(reader.uint64() as Long);
          break;
        case 2:
          message.bestSubmissionBtcBlockHeight = reader.uint32();
          break;
        case 3:
          message.bestSubmissionBtcBlockHash = reader.bytes();
          break;
        case 4:
          message.bestSubmissionTransactions.push(
            TransactionInfo.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.bestSubmissionVigilanteAddressList.push(
            CheckpointAddresses.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BTCCheckpointInfo {
    return {
      epochNumber: isSet(object.epochNumber) ? String(object.epochNumber) : "0",
      bestSubmissionBtcBlockHeight: isSet(object.bestSubmissionBtcBlockHeight)
        ? Number(object.bestSubmissionBtcBlockHeight)
        : 0,
      bestSubmissionBtcBlockHash: isSet(object.bestSubmissionBtcBlockHash)
        ? bytesFromBase64(object.bestSubmissionBtcBlockHash)
        : new Uint8Array(),
      bestSubmissionTransactions: Array.isArray(
        object?.bestSubmissionTransactions
      )
        ? object.bestSubmissionTransactions.map((e: any) =>
            TransactionInfo.fromJSON(e)
          )
        : [],
      bestSubmissionVigilanteAddressList: Array.isArray(
        object?.bestSubmissionVigilanteAddressList
      )
        ? object.bestSubmissionVigilanteAddressList.map((e: any) =>
            CheckpointAddresses.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: BTCCheckpointInfo): unknown {
    const obj: any = {};
    message.epochNumber !== undefined &&
      (obj.epochNumber = message.epochNumber);
    message.bestSubmissionBtcBlockHeight !== undefined &&
      (obj.bestSubmissionBtcBlockHeight = Math.round(
        message.bestSubmissionBtcBlockHeight
      ));
    message.bestSubmissionBtcBlockHash !== undefined &&
      (obj.bestSubmissionBtcBlockHash = base64FromBytes(
        message.bestSubmissionBtcBlockHash !== undefined
          ? message.bestSubmissionBtcBlockHash
          : new Uint8Array()
      ));
    if (message.bestSubmissionTransactions) {
      obj.bestSubmissionTransactions = message.bestSubmissionTransactions.map(
        (e) => (e ? TransactionInfo.toJSON(e) : undefined)
      );
    } else {
      obj.bestSubmissionTransactions = [];
    }
    if (message.bestSubmissionVigilanteAddressList) {
      obj.bestSubmissionVigilanteAddressList =
        message.bestSubmissionVigilanteAddressList.map((e) =>
          e ? CheckpointAddresses.toJSON(e) : undefined
        );
    } else {
      obj.bestSubmissionVigilanteAddressList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BTCCheckpointInfo>, I>>(
    object: I
  ): BTCCheckpointInfo {
    const message = createBaseBTCCheckpointInfo();
    message.epochNumber = object.epochNumber ?? "0";
    message.bestSubmissionBtcBlockHeight =
      object.bestSubmissionBtcBlockHeight ?? 0;
    message.bestSubmissionBtcBlockHash =
      object.bestSubmissionBtcBlockHash ?? new Uint8Array();
    message.bestSubmissionTransactions =
      object.bestSubmissionTransactions?.map((e) =>
        TransactionInfo.fromPartial(e)
      ) || [];
    message.bestSubmissionVigilanteAddressList =
      object.bestSubmissionVigilanteAddressList?.map((e) =>
        CheckpointAddresses.fromPartial(e)
      ) || [];
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

const atob: (b64: string) => string =
  globalThis.atob ||
  ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

const btoa: (bin: string) => string =
  globalThis.btoa ||
  ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  for (const byte of arr) {
    bin.push(String.fromCharCode(byte));
  }
  return btoa(bin.join(""));
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
