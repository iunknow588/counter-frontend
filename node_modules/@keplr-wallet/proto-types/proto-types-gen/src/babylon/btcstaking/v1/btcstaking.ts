/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { ProofOfPossessionBTC } from "../../../babylon/btcstaking/v1/pop";
import { TransactionKey } from "../../../babylon/btccheckpoint/v1/btccheckpoint";
import { BTCHeaderInfo } from "../../../babylon/btclightclient/v1/btclightclient";

export const protobufPackage = "babylon.btcstaking.v1";

/**
 * BTCDelegationStatus is the status of a delegation.
 * There are two possible valid state transition paths for a BTC delegation:
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED -> EXPIRED
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED/EXPIRED
 * and one invalid state transition path:
 * - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
 * activating delegation on Babylon chain.
 * In valid transition paths, the delegation becomes UNBONDED when:
 * - either the staking transaction timelock expires
 * - or the staker requests early undelegation through MsgBTCUndelegate message.
 */
export enum BTCDelegationStatus {
  /** PENDING - PENDING defines a delegation that is waiting for covenant signatures. */
  PENDING = 0,
  /**
   * VERIFIED - VERIFIED defines a delegation that has covenant signatures but is not yet
   * included in the BTC chain.
   */
  VERIFIED = 1,
  /** ACTIVE - ACTIVE defines a delegation that has voting power */
  ACTIVE = 2,
  /**
   * UNBONDED - UNBONDED defines a delegation no longer has voting power
   * by receiving unbonding tx with signatures from staker and covenant
   * committee
   */
  UNBONDED = 3,
  /**
   * EXPIRED - EXPIRED defines a delegation no longer has voting power
   * for reaching the end of staking transaction timelock
   */
  EXPIRED = 4,
  /** ANY - ANY is any of the above status */
  ANY = 5,
  UNRECOGNIZED = -1,
}

export function bTCDelegationStatusFromJSON(object: any): BTCDelegationStatus {
  switch (object) {
    case 0:
    case "PENDING":
      return BTCDelegationStatus.PENDING;
    case 1:
    case "VERIFIED":
      return BTCDelegationStatus.VERIFIED;
    case 2:
    case "ACTIVE":
      return BTCDelegationStatus.ACTIVE;
    case 3:
    case "UNBONDED":
      return BTCDelegationStatus.UNBONDED;
    case 4:
    case "EXPIRED":
      return BTCDelegationStatus.EXPIRED;
    case 5:
    case "ANY":
      return BTCDelegationStatus.ANY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BTCDelegationStatus.UNRECOGNIZED;
  }
}

export function bTCDelegationStatusToJSON(object: BTCDelegationStatus): string {
  switch (object) {
    case BTCDelegationStatus.PENDING:
      return "PENDING";
    case BTCDelegationStatus.VERIFIED:
      return "VERIFIED";
    case BTCDelegationStatus.ACTIVE:
      return "ACTIVE";
    case BTCDelegationStatus.UNBONDED:
      return "UNBONDED";
    case BTCDelegationStatus.EXPIRED:
      return "EXPIRED";
    case BTCDelegationStatus.ANY:
      return "ANY";
    default:
      return "UNKNOWN";
  }
}

/** FinalityProvider defines a finality provider */
export interface FinalityProvider {
  /** addr is the bech32 address identifier of the finality provider. */
  addr: string;
  /** description defines the description terms for the finality provider. */
  description: Description | undefined;
  /** commission defines the commission rate of the finality provider. */
  commission: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /**
   * pop is the proof of possession of the btc_pk, where the BTC
   * private key signs the bech32 bbn addr of the finality provider.
   */
  pop: ProofOfPossessionBTC | undefined;
  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBabylonHeight: string;
  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBtcHeight: number;
  /** jailed defines whether the finality provider is jailed */
  jailed: boolean;
  /**
   * highest_voted_height is the highest height for which the
   * finality provider has voted
   */
  highestVotedHeight: number;
  /** commission_info contains information details of the finality provider commission. */
  commissionInfo: CommissionInfo | undefined;
}

/**
 * CommissionInfo defines the information related to the commission of
 * a finality provider.
 */
export interface CommissionInfo {
  /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
  maxRate: string;
  /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
  maxChangeRate: string;
  /** update_time is the last time the commission rate was changed. */
  updateTime: Date | undefined;
}

/** FinalityProviderWithMeta wraps the FinalityProvider with metadata. */
export interface FinalityProviderWithMeta {
  /**
   * btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /** height is the queried Babylon height */
  height: string;
  /**
   * voting_power is the voting power of this finality provider at the given
   * height
   */
  votingPower: string;
  /**
   * slashed_babylon_height indicates the Babylon height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBabylonHeight: string;
  /**
   * slashed_btc_height indicates the BTC height when
   * the finality provider is slashed.
   * if it's 0 then the finality provider is not slashed
   */
  slashedBtcHeight: number;
  /** jailed defines whether the finality provider is detected jailed */
  jailed: boolean;
  /**
   * highest_voted_height is the highest height for which the
   * finality provider has voted
   */
  highestVotedHeight: number;
}

/** BTCDelegation defines a BTC delegation */
export interface BTCDelegation {
  /** staker_addr is the address to receive rewards from BTC delegation. */
  stakerAddr: string;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /** pop is the proof of possession of babylon_pk and btc_pk */
  pop: ProofOfPossessionBTC | undefined;
  /**
   * fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
   * this BTC delegation delegates to
   * If there is more than 1 PKs, then this means the delegation is restaked
   * to multiple finality providers
   */
  fpBtcPkList: Uint8Array[];
  /**
   * staking_time is the number of blocks for which the delegation is locked on
   * BTC chain
   */
  stakingTime: number;
  /**
   * start_height is the start BTC height of the BTC delegation
   * it is the start BTC height of the timelock
   */
  startHeight: number;
  /**
   * end_height is the end height of the BTC delegation
   * it is calculated by end_height = start_height + staking_time
   */
  endHeight: number;
  /**
   * total_sat is the total amount of BTC stakes in this delegation
   * quantified in satoshi
   */
  totalSat: string;
  /** staking_tx is the staking tx */
  stakingTx: Uint8Array;
  /** staking_output_idx is the index of the staking output in the staking tx */
  stakingOutputIdx: number;
  /**
   * slashing_tx is the slashing tx
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the staking tx output.
   */
  delegatorSig: Uint8Array;
  /**
   * covenant_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSigs: CovenantAdaptorSignatures[];
  /**
   * unbonding_time describes how long the funds will be locked either in
   * unbonding output or slashing change output
   */
  unbondingTime: number;
  /**
   * btc_undelegation is the information about the early unbonding path of the
   * BTC delegation
   */
  btcUndelegation: BTCUndelegation | undefined;
  /** version of the params used to validate the delegation */
  paramsVersion: number;
  /**
   * btc_tip_height is the height of the BTC light client tip at the time of
   * the delegation creation
   */
  btcTipHeight: number;
}

/**
 * DelegatorUnbondingInfo contains the information about transaction which spent
 * the staking output. It contains:
 * - spend_stake_tx: the transaction which spent the staking output
 */
export interface DelegatorUnbondingInfo {
  /**
   * spend_stake_tx is the transaction which spent the staking output. It is
   * filled only if spend_stake_tx is different than unbonding_tx registered
   * on the Babylon chain.
   */
  spendStakeTx: Uint8Array;
}

/**
 * BTCUndelegation contains the information about the early unbonding path of
 * the BTC delegation
 */
export interface BTCUndelegation {
  /**
   * unbonding_tx is the transaction which will transfer the funds from staking
   * output to unbonding output. Unbonding output will usually have lower
   * timelock than staking output.
   */
  unbondingTx: Uint8Array;
  /**
   * slashing_tx is the slashing tx for unbonding transactions
   * It is partially signed by SK corresponding to btc_pk, but not signed by
   * finality provider or covenant yet.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_slashing_sig is the signature on the slashing tx
   * by the delegator (i.e., SK corresponding to btc_pk).
   * It will be a part of the witness for the unbonding tx output.
   */
  delegatorSlashingSig: Uint8Array;
  /**
   * covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
   * by each covenant member
   * It will be a part of the witness for the staking tx output.
   */
  covenantSlashingSigs: CovenantAdaptorSignatures[];
  /**
   * covenant_unbonding_sig_list is the list of signatures on the unbonding tx
   * by covenant members
   * It must be provided after processing undelegate message by Babylon
   */
  covenantUnbondingSigList: SignatureInfo[];
  /**
   * delegator_unbonding_info is the information about transaction which spent
   * the staking output
   */
  delegatorUnbondingInfo: DelegatorUnbondingInfo | undefined;
}

/**
 * BTCDelegatorDelegations is a collection of BTC delegations from the same
 * delegator.
 */
export interface BTCDelegatorDelegations {
  dels: BTCDelegation[];
}

/**
 * BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations
 * from the same delegator.
 */
export interface BTCDelegatorDelegationIndex {
  stakingTxHashList: Uint8Array[];
}

/** SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK */
export interface SignatureInfo {
  pk: Uint8Array;
  sig: Uint8Array;
}

/**
 * CovenantAdaptorSignatures is a list adaptor signatures signed by the
 * covenant with different finality provider's public keys as encryption keys
 */
export interface CovenantAdaptorSignatures {
  /**
   * cov_pk is the public key of the covenant emulator, used as the public key
   * of the adaptor signature
   */
  covPk: Uint8Array;
  /**
   * adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked
   * BTC finality provider's public key
   */
  adaptorSigs: Uint8Array[];
}

/**
 * SelectiveSlashingEvidence is the evidence that the finality provider
 * selectively slashed a BTC delegation
 * NOTE: it's possible that a slashed finality provider exploits the
 * SelectiveSlashingEvidence endpoint while it is actually slashed due to
 * equivocation. But such behaviour does not affect the system's security
 * or gives any benefit for the adversary
 */
export interface SelectiveSlashingEvidence {
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * fp_btc_pk is the BTC PK of the finality provider who
   * launches the selective slashing offence
   */
  fpBtcPk: Uint8Array;
  /**
   * recovered_fp_btc_sk is the finality provider's BTC SK recovered from
   * the covenant adaptor/Schnorr signature pair. It is the consequence
   * of selective slashing.
   */
  recoveredFpBtcSk: Uint8Array;
}

/**
 * InclusionProof proves the existence of tx on BTC blockchain
 * including
 * - the position of the tx on BTC blockchain
 * - the Merkle proof that this tx is on the above position
 */
export interface InclusionProof {
  /** key is the position (txIdx, blockHash) of this tx on BTC blockchain */
  key: TransactionKey | undefined;
  /** proof is the Merkle proof that this tx is included in the position in `key` */
  proof: Uint8Array;
}

/** LargestBtcReOrg stores the largest BTC reorg recorded */
export interface LargestBtcReOrg {
  /**
   * BlockDiff is the difference of the block height of the BTC header Tip - the btc height
   * which it was rolled back
   */
  blockDiff: number;
  /** RollbackFrom is the latest BTC block header prior to rollback */
  rollbackFrom: BTCHeaderInfo | undefined;
  /** RollbackTo is the BTC block header which we rollback to */
  rollbackTo: BTCHeaderInfo | undefined;
}

function createBaseFinalityProvider(): FinalityProvider {
  return {
    addr: "",
    description: undefined,
    commission: "",
    btcPk: new Uint8Array(),
    pop: undefined,
    slashedBabylonHeight: "0",
    slashedBtcHeight: 0,
    jailed: false,
    highestVotedHeight: 0,
    commissionInfo: undefined,
  };
}

export const FinalityProvider = {
  encode(
    message: FinalityProvider,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.description !== undefined) {
      Description.encode(
        message.description,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.commission !== "") {
      writer.uint32(26).string(message.commission);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(34).bytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(
        message.pop,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.slashedBabylonHeight !== "0") {
      writer.uint32(48).uint64(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      writer.uint32(56).uint32(message.slashedBtcHeight);
    }
    if (message.jailed === true) {
      writer.uint32(64).bool(message.jailed);
    }
    if (message.highestVotedHeight !== 0) {
      writer.uint32(72).uint32(message.highestVotedHeight);
    }
    if (message.commissionInfo !== undefined) {
      CommissionInfo.encode(
        message.commissionInfo,
        writer.uint32(90).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinalityProvider {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.addr = reader.string();
          break;
        case 2:
          message.description = Description.decode(reader, reader.uint32());
          break;
        case 3:
          message.commission = reader.string();
          break;
        case 4:
          message.btcPk = reader.bytes();
          break;
        case 5:
          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          break;
        case 6:
          message.slashedBabylonHeight = longToString(reader.uint64() as Long);
          break;
        case 7:
          message.slashedBtcHeight = reader.uint32();
          break;
        case 8:
          message.jailed = reader.bool();
          break;
        case 9:
          message.highestVotedHeight = reader.uint32();
          break;
        case 11:
          message.commissionInfo = CommissionInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinalityProvider {
    return {
      addr: isSet(object.addr) ? String(object.addr) : "",
      description: isSet(object.description)
        ? Description.fromJSON(object.description)
        : undefined,
      commission: isSet(object.commission) ? String(object.commission) : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(),
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      slashedBabylonHeight: isSet(object.slashedBabylonHeight)
        ? String(object.slashedBabylonHeight)
        : "0",
      slashedBtcHeight: isSet(object.slashedBtcHeight)
        ? Number(object.slashedBtcHeight)
        : 0,
      jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,
      highestVotedHeight: isSet(object.highestVotedHeight)
        ? Number(object.highestVotedHeight)
        : 0,
      commissionInfo: isSet(object.commissionInfo)
        ? CommissionInfo.fromJSON(object.commissionInfo)
        : undefined,
    };
  },

  toJSON(message: FinalityProvider): unknown {
    const obj: any = {};
    message.addr !== undefined && (obj.addr = message.addr);
    message.description !== undefined &&
      (obj.description = message.description
        ? Description.toJSON(message.description)
        : undefined);
    message.commission !== undefined && (obj.commission = message.commission);
    message.btcPk !== undefined &&
      (obj.btcPk = base64FromBytes(
        message.btcPk !== undefined ? message.btcPk : new Uint8Array()
      ));
    message.pop !== undefined &&
      (obj.pop = message.pop
        ? ProofOfPossessionBTC.toJSON(message.pop)
        : undefined);
    message.slashedBabylonHeight !== undefined &&
      (obj.slashedBabylonHeight = message.slashedBabylonHeight);
    message.slashedBtcHeight !== undefined &&
      (obj.slashedBtcHeight = Math.round(message.slashedBtcHeight));
    message.jailed !== undefined && (obj.jailed = message.jailed);
    message.highestVotedHeight !== undefined &&
      (obj.highestVotedHeight = Math.round(message.highestVotedHeight));
    message.commissionInfo !== undefined &&
      (obj.commissionInfo = message.commissionInfo
        ? CommissionInfo.toJSON(message.commissionInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinalityProvider>, I>>(
    object: I
  ): FinalityProvider {
    const message = createBaseFinalityProvider();
    message.addr = object.addr ?? "";
    message.description =
      object.description !== undefined && object.description !== null
        ? Description.fromPartial(object.description)
        : undefined;
    message.commission = object.commission ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array();
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.slashedBabylonHeight = object.slashedBabylonHeight ?? "0";
    message.slashedBtcHeight = object.slashedBtcHeight ?? 0;
    message.jailed = object.jailed ?? false;
    message.highestVotedHeight = object.highestVotedHeight ?? 0;
    message.commissionInfo =
      object.commissionInfo !== undefined && object.commissionInfo !== null
        ? CommissionInfo.fromPartial(object.commissionInfo)
        : undefined;
    return message;
  },
};

function createBaseCommissionInfo(): CommissionInfo {
  return { maxRate: "", maxChangeRate: "", updateTime: undefined };
}

export const CommissionInfo = {
  encode(
    message: CommissionInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.maxRate !== "") {
      writer.uint32(10).string(message.maxRate);
    }
    if (message.maxChangeRate !== "") {
      writer.uint32(18).string(message.maxChangeRate);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(
        toTimestamp(message.updateTime),
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommissionInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommissionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxRate = reader.string();
          break;
        case 2:
          message.maxChangeRate = reader.string();
          break;
        case 3:
          message.updateTime = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CommissionInfo {
    return {
      maxRate: isSet(object.maxRate) ? String(object.maxRate) : "",
      maxChangeRate: isSet(object.maxChangeRate)
        ? String(object.maxChangeRate)
        : "",
      updateTime: isSet(object.updateTime)
        ? fromJsonTimestamp(object.updateTime)
        : undefined,
    };
  },

  toJSON(message: CommissionInfo): unknown {
    const obj: any = {};
    message.maxRate !== undefined && (obj.maxRate = message.maxRate);
    message.maxChangeRate !== undefined &&
      (obj.maxChangeRate = message.maxChangeRate);
    message.updateTime !== undefined &&
      (obj.updateTime = message.updateTime.toISOString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CommissionInfo>, I>>(
    object: I
  ): CommissionInfo {
    const message = createBaseCommissionInfo();
    message.maxRate = object.maxRate ?? "";
    message.maxChangeRate = object.maxChangeRate ?? "";
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseFinalityProviderWithMeta(): FinalityProviderWithMeta {
  return {
    btcPk: new Uint8Array(),
    height: "0",
    votingPower: "0",
    slashedBabylonHeight: "0",
    slashedBtcHeight: 0,
    jailed: false,
    highestVotedHeight: 0,
  };
}

export const FinalityProviderWithMeta = {
  encode(
    message: FinalityProviderWithMeta,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.btcPk.length !== 0) {
      writer.uint32(10).bytes(message.btcPk);
    }
    if (message.height !== "0") {
      writer.uint32(16).uint64(message.height);
    }
    if (message.votingPower !== "0") {
      writer.uint32(24).uint64(message.votingPower);
    }
    if (message.slashedBabylonHeight !== "0") {
      writer.uint32(32).uint64(message.slashedBabylonHeight);
    }
    if (message.slashedBtcHeight !== 0) {
      writer.uint32(40).uint32(message.slashedBtcHeight);
    }
    if (message.jailed === true) {
      writer.uint32(48).bool(message.jailed);
    }
    if (message.highestVotedHeight !== 0) {
      writer.uint32(56).uint32(message.highestVotedHeight);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinalityProviderWithMeta {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalityProviderWithMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.btcPk = reader.bytes();
          break;
        case 2:
          message.height = longToString(reader.uint64() as Long);
          break;
        case 3:
          message.votingPower = longToString(reader.uint64() as Long);
          break;
        case 4:
          message.slashedBabylonHeight = longToString(reader.uint64() as Long);
          break;
        case 5:
          message.slashedBtcHeight = reader.uint32();
          break;
        case 6:
          message.jailed = reader.bool();
          break;
        case 7:
          message.highestVotedHeight = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinalityProviderWithMeta {
    return {
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(),
      height: isSet(object.height) ? String(object.height) : "0",
      votingPower: isSet(object.votingPower) ? String(object.votingPower) : "0",
      slashedBabylonHeight: isSet(object.slashedBabylonHeight)
        ? String(object.slashedBabylonHeight)
        : "0",
      slashedBtcHeight: isSet(object.slashedBtcHeight)
        ? Number(object.slashedBtcHeight)
        : 0,
      jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,
      highestVotedHeight: isSet(object.highestVotedHeight)
        ? Number(object.highestVotedHeight)
        : 0,
    };
  },

  toJSON(message: FinalityProviderWithMeta): unknown {
    const obj: any = {};
    message.btcPk !== undefined &&
      (obj.btcPk = base64FromBytes(
        message.btcPk !== undefined ? message.btcPk : new Uint8Array()
      ));
    message.height !== undefined && (obj.height = message.height);
    message.votingPower !== undefined &&
      (obj.votingPower = message.votingPower);
    message.slashedBabylonHeight !== undefined &&
      (obj.slashedBabylonHeight = message.slashedBabylonHeight);
    message.slashedBtcHeight !== undefined &&
      (obj.slashedBtcHeight = Math.round(message.slashedBtcHeight));
    message.jailed !== undefined && (obj.jailed = message.jailed);
    message.highestVotedHeight !== undefined &&
      (obj.highestVotedHeight = Math.round(message.highestVotedHeight));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinalityProviderWithMeta>, I>>(
    object: I
  ): FinalityProviderWithMeta {
    const message = createBaseFinalityProviderWithMeta();
    message.btcPk = object.btcPk ?? new Uint8Array();
    message.height = object.height ?? "0";
    message.votingPower = object.votingPower ?? "0";
    message.slashedBabylonHeight = object.slashedBabylonHeight ?? "0";
    message.slashedBtcHeight = object.slashedBtcHeight ?? 0;
    message.jailed = object.jailed ?? false;
    message.highestVotedHeight = object.highestVotedHeight ?? 0;
    return message;
  },
};

function createBaseBTCDelegation(): BTCDelegation {
  return {
    stakerAddr: "",
    btcPk: new Uint8Array(),
    pop: undefined,
    fpBtcPkList: [],
    stakingTime: 0,
    startHeight: 0,
    endHeight: 0,
    totalSat: "0",
    stakingTx: new Uint8Array(),
    stakingOutputIdx: 0,
    slashingTx: new Uint8Array(),
    delegatorSig: new Uint8Array(),
    covenantSigs: [],
    unbondingTime: 0,
    btcUndelegation: undefined,
    paramsVersion: 0,
    btcTipHeight: 0,
  };
}

export const BTCDelegation = {
  encode(
    message: BTCDelegation,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stakerAddr !== "") {
      writer.uint32(10).string(message.stakerAddr);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(18).bytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(
        message.pop,
        writer.uint32(26).fork()
      ).ldelim();
    }
    for (const v of message.fpBtcPkList) {
      writer.uint32(34).bytes(v!);
    }
    if (message.stakingTime !== 0) {
      writer.uint32(40).uint32(message.stakingTime);
    }
    if (message.startHeight !== 0) {
      writer.uint32(48).uint32(message.startHeight);
    }
    if (message.endHeight !== 0) {
      writer.uint32(56).uint32(message.endHeight);
    }
    if (message.totalSat !== "0") {
      writer.uint32(64).uint64(message.totalSat);
    }
    if (message.stakingTx.length !== 0) {
      writer.uint32(74).bytes(message.stakingTx);
    }
    if (message.stakingOutputIdx !== 0) {
      writer.uint32(80).uint32(message.stakingOutputIdx);
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(90).bytes(message.slashingTx);
    }
    if (message.delegatorSig.length !== 0) {
      writer.uint32(98).bytes(message.delegatorSig);
    }
    for (const v of message.covenantSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.unbondingTime !== 0) {
      writer.uint32(112).uint32(message.unbondingTime);
    }
    if (message.btcUndelegation !== undefined) {
      BTCUndelegation.encode(
        message.btcUndelegation,
        writer.uint32(122).fork()
      ).ldelim();
    }
    if (message.paramsVersion !== 0) {
      writer.uint32(128).uint32(message.paramsVersion);
    }
    if (message.btcTipHeight !== 0) {
      writer.uint32(136).uint32(message.btcTipHeight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCDelegation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stakerAddr = reader.string();
          break;
        case 2:
          message.btcPk = reader.bytes();
          break;
        case 3:
          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          break;
        case 4:
          message.fpBtcPkList.push(reader.bytes());
          break;
        case 5:
          message.stakingTime = reader.uint32();
          break;
        case 6:
          message.startHeight = reader.uint32();
          break;
        case 7:
          message.endHeight = reader.uint32();
          break;
        case 8:
          message.totalSat = longToString(reader.uint64() as Long);
          break;
        case 9:
          message.stakingTx = reader.bytes();
          break;
        case 10:
          message.stakingOutputIdx = reader.uint32();
          break;
        case 11:
          message.slashingTx = reader.bytes();
          break;
        case 12:
          message.delegatorSig = reader.bytes();
          break;
        case 13:
          message.covenantSigs.push(
            CovenantAdaptorSignatures.decode(reader, reader.uint32())
          );
          break;
        case 14:
          message.unbondingTime = reader.uint32();
          break;
        case 15:
          message.btcUndelegation = BTCUndelegation.decode(
            reader,
            reader.uint32()
          );
          break;
        case 16:
          message.paramsVersion = reader.uint32();
          break;
        case 17:
          message.btcTipHeight = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BTCDelegation {
    return {
      stakerAddr: isSet(object.stakerAddr) ? String(object.stakerAddr) : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(),
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      fpBtcPkList: Array.isArray(object?.fpBtcPkList)
        ? object.fpBtcPkList.map((e: any) => bytesFromBase64(e))
        : [],
      stakingTime: isSet(object.stakingTime) ? Number(object.stakingTime) : 0,
      startHeight: isSet(object.startHeight) ? Number(object.startHeight) : 0,
      endHeight: isSet(object.endHeight) ? Number(object.endHeight) : 0,
      totalSat: isSet(object.totalSat) ? String(object.totalSat) : "0",
      stakingTx: isSet(object.stakingTx)
        ? bytesFromBase64(object.stakingTx)
        : new Uint8Array(),
      stakingOutputIdx: isSet(object.stakingOutputIdx)
        ? Number(object.stakingOutputIdx)
        : 0,
      slashingTx: isSet(object.slashingTx)
        ? bytesFromBase64(object.slashingTx)
        : new Uint8Array(),
      delegatorSig: isSet(object.delegatorSig)
        ? bytesFromBase64(object.delegatorSig)
        : new Uint8Array(),
      covenantSigs: Array.isArray(object?.covenantSigs)
        ? object.covenantSigs.map((e: any) =>
            CovenantAdaptorSignatures.fromJSON(e)
          )
        : [],
      unbondingTime: isSet(object.unbondingTime)
        ? Number(object.unbondingTime)
        : 0,
      btcUndelegation: isSet(object.btcUndelegation)
        ? BTCUndelegation.fromJSON(object.btcUndelegation)
        : undefined,
      paramsVersion: isSet(object.paramsVersion)
        ? Number(object.paramsVersion)
        : 0,
      btcTipHeight: isSet(object.btcTipHeight)
        ? Number(object.btcTipHeight)
        : 0,
    };
  },

  toJSON(message: BTCDelegation): unknown {
    const obj: any = {};
    message.stakerAddr !== undefined && (obj.stakerAddr = message.stakerAddr);
    message.btcPk !== undefined &&
      (obj.btcPk = base64FromBytes(
        message.btcPk !== undefined ? message.btcPk : new Uint8Array()
      ));
    message.pop !== undefined &&
      (obj.pop = message.pop
        ? ProofOfPossessionBTC.toJSON(message.pop)
        : undefined);
    if (message.fpBtcPkList) {
      obj.fpBtcPkList = message.fpBtcPkList.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.fpBtcPkList = [];
    }
    message.stakingTime !== undefined &&
      (obj.stakingTime = Math.round(message.stakingTime));
    message.startHeight !== undefined &&
      (obj.startHeight = Math.round(message.startHeight));
    message.endHeight !== undefined &&
      (obj.endHeight = Math.round(message.endHeight));
    message.totalSat !== undefined && (obj.totalSat = message.totalSat);
    message.stakingTx !== undefined &&
      (obj.stakingTx = base64FromBytes(
        message.stakingTx !== undefined ? message.stakingTx : new Uint8Array()
      ));
    message.stakingOutputIdx !== undefined &&
      (obj.stakingOutputIdx = Math.round(message.stakingOutputIdx));
    message.slashingTx !== undefined &&
      (obj.slashingTx = base64FromBytes(
        message.slashingTx !== undefined ? message.slashingTx : new Uint8Array()
      ));
    message.delegatorSig !== undefined &&
      (obj.delegatorSig = base64FromBytes(
        message.delegatorSig !== undefined
          ? message.delegatorSig
          : new Uint8Array()
      ));
    if (message.covenantSigs) {
      obj.covenantSigs = message.covenantSigs.map((e) =>
        e ? CovenantAdaptorSignatures.toJSON(e) : undefined
      );
    } else {
      obj.covenantSigs = [];
    }
    message.unbondingTime !== undefined &&
      (obj.unbondingTime = Math.round(message.unbondingTime));
    message.btcUndelegation !== undefined &&
      (obj.btcUndelegation = message.btcUndelegation
        ? BTCUndelegation.toJSON(message.btcUndelegation)
        : undefined);
    message.paramsVersion !== undefined &&
      (obj.paramsVersion = Math.round(message.paramsVersion));
    message.btcTipHeight !== undefined &&
      (obj.btcTipHeight = Math.round(message.btcTipHeight));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BTCDelegation>, I>>(
    object: I
  ): BTCDelegation {
    const message = createBaseBTCDelegation();
    message.stakerAddr = object.stakerAddr ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array();
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.fpBtcPkList = object.fpBtcPkList?.map((e) => e) || [];
    message.stakingTime = object.stakingTime ?? 0;
    message.startHeight = object.startHeight ?? 0;
    message.endHeight = object.endHeight ?? 0;
    message.totalSat = object.totalSat ?? "0";
    message.stakingTx = object.stakingTx ?? new Uint8Array();
    message.stakingOutputIdx = object.stakingOutputIdx ?? 0;
    message.slashingTx = object.slashingTx ?? new Uint8Array();
    message.delegatorSig = object.delegatorSig ?? new Uint8Array();
    message.covenantSigs =
      object.covenantSigs?.map((e) =>
        CovenantAdaptorSignatures.fromPartial(e)
      ) || [];
    message.unbondingTime = object.unbondingTime ?? 0;
    message.btcUndelegation =
      object.btcUndelegation !== undefined && object.btcUndelegation !== null
        ? BTCUndelegation.fromPartial(object.btcUndelegation)
        : undefined;
    message.paramsVersion = object.paramsVersion ?? 0;
    message.btcTipHeight = object.btcTipHeight ?? 0;
    return message;
  },
};

function createBaseDelegatorUnbondingInfo(): DelegatorUnbondingInfo {
  return { spendStakeTx: new Uint8Array() };
}

export const DelegatorUnbondingInfo = {
  encode(
    message: DelegatorUnbondingInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.spendStakeTx.length !== 0) {
      writer.uint32(10).bytes(message.spendStakeTx);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DelegatorUnbondingInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatorUnbondingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.spendStakeTx = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelegatorUnbondingInfo {
    return {
      spendStakeTx: isSet(object.spendStakeTx)
        ? bytesFromBase64(object.spendStakeTx)
        : new Uint8Array(),
    };
  },

  toJSON(message: DelegatorUnbondingInfo): unknown {
    const obj: any = {};
    message.spendStakeTx !== undefined &&
      (obj.spendStakeTx = base64FromBytes(
        message.spendStakeTx !== undefined
          ? message.spendStakeTx
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DelegatorUnbondingInfo>, I>>(
    object: I
  ): DelegatorUnbondingInfo {
    const message = createBaseDelegatorUnbondingInfo();
    message.spendStakeTx = object.spendStakeTx ?? new Uint8Array();
    return message;
  },
};

function createBaseBTCUndelegation(): BTCUndelegation {
  return {
    unbondingTx: new Uint8Array(),
    slashingTx: new Uint8Array(),
    delegatorSlashingSig: new Uint8Array(),
    covenantSlashingSigs: [],
    covenantUnbondingSigList: [],
    delegatorUnbondingInfo: undefined,
  };
}

export const BTCUndelegation = {
  encode(
    message: BTCUndelegation,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.unbondingTx.length !== 0) {
      writer.uint32(10).bytes(message.unbondingTx);
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(18).bytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      writer.uint32(26).bytes(message.delegatorSlashingSig);
    }
    for (const v of message.covenantSlashingSigs) {
      CovenantAdaptorSignatures.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.covenantUnbondingSigList) {
      SignatureInfo.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.delegatorUnbondingInfo !== undefined) {
      DelegatorUnbondingInfo.encode(
        message.delegatorUnbondingInfo,
        writer.uint32(50).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCUndelegation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCUndelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.unbondingTx = reader.bytes();
          break;
        case 2:
          message.slashingTx = reader.bytes();
          break;
        case 3:
          message.delegatorSlashingSig = reader.bytes();
          break;
        case 4:
          message.covenantSlashingSigs.push(
            CovenantAdaptorSignatures.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.covenantUnbondingSigList.push(
            SignatureInfo.decode(reader, reader.uint32())
          );
          break;
        case 6:
          message.delegatorUnbondingInfo = DelegatorUnbondingInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BTCUndelegation {
    return {
      unbondingTx: isSet(object.unbondingTx)
        ? bytesFromBase64(object.unbondingTx)
        : new Uint8Array(),
      slashingTx: isSet(object.slashingTx)
        ? bytesFromBase64(object.slashingTx)
        : new Uint8Array(),
      delegatorSlashingSig: isSet(object.delegatorSlashingSig)
        ? bytesFromBase64(object.delegatorSlashingSig)
        : new Uint8Array(),
      covenantSlashingSigs: Array.isArray(object?.covenantSlashingSigs)
        ? object.covenantSlashingSigs.map((e: any) =>
            CovenantAdaptorSignatures.fromJSON(e)
          )
        : [],
      covenantUnbondingSigList: Array.isArray(object?.covenantUnbondingSigList)
        ? object.covenantUnbondingSigList.map((e: any) =>
            SignatureInfo.fromJSON(e)
          )
        : [],
      delegatorUnbondingInfo: isSet(object.delegatorUnbondingInfo)
        ? DelegatorUnbondingInfo.fromJSON(object.delegatorUnbondingInfo)
        : undefined,
    };
  },

  toJSON(message: BTCUndelegation): unknown {
    const obj: any = {};
    message.unbondingTx !== undefined &&
      (obj.unbondingTx = base64FromBytes(
        message.unbondingTx !== undefined
          ? message.unbondingTx
          : new Uint8Array()
      ));
    message.slashingTx !== undefined &&
      (obj.slashingTx = base64FromBytes(
        message.slashingTx !== undefined ? message.slashingTx : new Uint8Array()
      ));
    message.delegatorSlashingSig !== undefined &&
      (obj.delegatorSlashingSig = base64FromBytes(
        message.delegatorSlashingSig !== undefined
          ? message.delegatorSlashingSig
          : new Uint8Array()
      ));
    if (message.covenantSlashingSigs) {
      obj.covenantSlashingSigs = message.covenantSlashingSigs.map((e) =>
        e ? CovenantAdaptorSignatures.toJSON(e) : undefined
      );
    } else {
      obj.covenantSlashingSigs = [];
    }
    if (message.covenantUnbondingSigList) {
      obj.covenantUnbondingSigList = message.covenantUnbondingSigList.map((e) =>
        e ? SignatureInfo.toJSON(e) : undefined
      );
    } else {
      obj.covenantUnbondingSigList = [];
    }
    message.delegatorUnbondingInfo !== undefined &&
      (obj.delegatorUnbondingInfo = message.delegatorUnbondingInfo
        ? DelegatorUnbondingInfo.toJSON(message.delegatorUnbondingInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BTCUndelegation>, I>>(
    object: I
  ): BTCUndelegation {
    const message = createBaseBTCUndelegation();
    message.unbondingTx = object.unbondingTx ?? new Uint8Array();
    message.slashingTx = object.slashingTx ?? new Uint8Array();
    message.delegatorSlashingSig =
      object.delegatorSlashingSig ?? new Uint8Array();
    message.covenantSlashingSigs =
      object.covenantSlashingSigs?.map((e) =>
        CovenantAdaptorSignatures.fromPartial(e)
      ) || [];
    message.covenantUnbondingSigList =
      object.covenantUnbondingSigList?.map((e) =>
        SignatureInfo.fromPartial(e)
      ) || [];
    message.delegatorUnbondingInfo =
      object.delegatorUnbondingInfo !== undefined &&
      object.delegatorUnbondingInfo !== null
        ? DelegatorUnbondingInfo.fromPartial(object.delegatorUnbondingInfo)
        : undefined;
    return message;
  },
};

function createBaseBTCDelegatorDelegations(): BTCDelegatorDelegations {
  return { dels: [] };
}

export const BTCDelegatorDelegations = {
  encode(
    message: BTCDelegatorDelegations,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.dels) {
      BTCDelegation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BTCDelegatorDelegations {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCDelegatorDelegations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dels.push(BTCDelegation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BTCDelegatorDelegations {
    return {
      dels: Array.isArray(object?.dels)
        ? object.dels.map((e: any) => BTCDelegation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BTCDelegatorDelegations): unknown {
    const obj: any = {};
    if (message.dels) {
      obj.dels = message.dels.map((e) =>
        e ? BTCDelegation.toJSON(e) : undefined
      );
    } else {
      obj.dels = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BTCDelegatorDelegations>, I>>(
    object: I
  ): BTCDelegatorDelegations {
    const message = createBaseBTCDelegatorDelegations();
    message.dels = object.dels?.map((e) => BTCDelegation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBTCDelegatorDelegationIndex(): BTCDelegatorDelegationIndex {
  return { stakingTxHashList: [] };
}

export const BTCDelegatorDelegationIndex = {
  encode(
    message: BTCDelegatorDelegationIndex,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.stakingTxHashList) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BTCDelegatorDelegationIndex {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCDelegatorDelegationIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stakingTxHashList.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BTCDelegatorDelegationIndex {
    return {
      stakingTxHashList: Array.isArray(object?.stakingTxHashList)
        ? object.stakingTxHashList.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: BTCDelegatorDelegationIndex): unknown {
    const obj: any = {};
    if (message.stakingTxHashList) {
      obj.stakingTxHashList = message.stakingTxHashList.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.stakingTxHashList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BTCDelegatorDelegationIndex>, I>>(
    object: I
  ): BTCDelegatorDelegationIndex {
    const message = createBaseBTCDelegatorDelegationIndex();
    message.stakingTxHashList = object.stakingTxHashList?.map((e) => e) || [];
    return message;
  },
};

function createBaseSignatureInfo(): SignatureInfo {
  return { pk: new Uint8Array(), sig: new Uint8Array() };
}

export const SignatureInfo = {
  encode(
    message: SignatureInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pk.length !== 0) {
      writer.uint32(10).bytes(message.pk);
    }
    if (message.sig.length !== 0) {
      writer.uint32(18).bytes(message.sig);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pk = reader.bytes();
          break;
        case 2:
          message.sig = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SignatureInfo {
    return {
      pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : new Uint8Array(),
    };
  },

  toJSON(message: SignatureInfo): unknown {
    const obj: any = {};
    message.pk !== undefined &&
      (obj.pk = base64FromBytes(
        message.pk !== undefined ? message.pk : new Uint8Array()
      ));
    message.sig !== undefined &&
      (obj.sig = base64FromBytes(
        message.sig !== undefined ? message.sig : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SignatureInfo>, I>>(
    object: I
  ): SignatureInfo {
    const message = createBaseSignatureInfo();
    message.pk = object.pk ?? new Uint8Array();
    message.sig = object.sig ?? new Uint8Array();
    return message;
  },
};

function createBaseCovenantAdaptorSignatures(): CovenantAdaptorSignatures {
  return { covPk: new Uint8Array(), adaptorSigs: [] };
}

export const CovenantAdaptorSignatures = {
  encode(
    message: CovenantAdaptorSignatures,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.covPk.length !== 0) {
      writer.uint32(10).bytes(message.covPk);
    }
    for (const v of message.adaptorSigs) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CovenantAdaptorSignatures {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCovenantAdaptorSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.covPk = reader.bytes();
          break;
        case 2:
          message.adaptorSigs.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CovenantAdaptorSignatures {
    return {
      covPk: isSet(object.covPk)
        ? bytesFromBase64(object.covPk)
        : new Uint8Array(),
      adaptorSigs: Array.isArray(object?.adaptorSigs)
        ? object.adaptorSigs.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: CovenantAdaptorSignatures): unknown {
    const obj: any = {};
    message.covPk !== undefined &&
      (obj.covPk = base64FromBytes(
        message.covPk !== undefined ? message.covPk : new Uint8Array()
      ));
    if (message.adaptorSigs) {
      obj.adaptorSigs = message.adaptorSigs.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.adaptorSigs = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CovenantAdaptorSignatures>, I>>(
    object: I
  ): CovenantAdaptorSignatures {
    const message = createBaseCovenantAdaptorSignatures();
    message.covPk = object.covPk ?? new Uint8Array();
    message.adaptorSigs = object.adaptorSigs?.map((e) => e) || [];
    return message;
  },
};

function createBaseSelectiveSlashingEvidence(): SelectiveSlashingEvidence {
  return {
    stakingTxHash: "",
    fpBtcPk: new Uint8Array(),
    recoveredFpBtcSk: new Uint8Array(),
  };
}

export const SelectiveSlashingEvidence = {
  encode(
    message: SelectiveSlashingEvidence,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stakingTxHash !== "") {
      writer.uint32(10).string(message.stakingTxHash);
    }
    if (message.fpBtcPk.length !== 0) {
      writer.uint32(18).bytes(message.fpBtcPk);
    }
    if (message.recoveredFpBtcSk.length !== 0) {
      writer.uint32(26).bytes(message.recoveredFpBtcSk);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SelectiveSlashingEvidence {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectiveSlashingEvidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stakingTxHash = reader.string();
          break;
        case 2:
          message.fpBtcPk = reader.bytes();
          break;
        case 3:
          message.recoveredFpBtcSk = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SelectiveSlashingEvidence {
    return {
      stakingTxHash: isSet(object.stakingTxHash)
        ? String(object.stakingTxHash)
        : "",
      fpBtcPk: isSet(object.fpBtcPk)
        ? bytesFromBase64(object.fpBtcPk)
        : new Uint8Array(),
      recoveredFpBtcSk: isSet(object.recoveredFpBtcSk)
        ? bytesFromBase64(object.recoveredFpBtcSk)
        : new Uint8Array(),
    };
  },

  toJSON(message: SelectiveSlashingEvidence): unknown {
    const obj: any = {};
    message.stakingTxHash !== undefined &&
      (obj.stakingTxHash = message.stakingTxHash);
    message.fpBtcPk !== undefined &&
      (obj.fpBtcPk = base64FromBytes(
        message.fpBtcPk !== undefined ? message.fpBtcPk : new Uint8Array()
      ));
    message.recoveredFpBtcSk !== undefined &&
      (obj.recoveredFpBtcSk = base64FromBytes(
        message.recoveredFpBtcSk !== undefined
          ? message.recoveredFpBtcSk
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SelectiveSlashingEvidence>, I>>(
    object: I
  ): SelectiveSlashingEvidence {
    const message = createBaseSelectiveSlashingEvidence();
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.fpBtcPk = object.fpBtcPk ?? new Uint8Array();
    message.recoveredFpBtcSk = object.recoveredFpBtcSk ?? new Uint8Array();
    return message;
  },
};

function createBaseInclusionProof(): InclusionProof {
  return { key: undefined, proof: new Uint8Array() };
}

export const InclusionProof = {
  encode(
    message: InclusionProof,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== undefined) {
      TransactionKey.encode(message.key, writer.uint32(10).fork()).ldelim();
    }
    if (message.proof.length !== 0) {
      writer.uint32(18).bytes(message.proof);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InclusionProof {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = TransactionKey.decode(reader, reader.uint32());
          break;
        case 2:
          message.proof = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InclusionProof {
    return {
      key: isSet(object.key) ? TransactionKey.fromJSON(object.key) : undefined,
      proof: isSet(object.proof)
        ? bytesFromBase64(object.proof)
        : new Uint8Array(),
    };
  },

  toJSON(message: InclusionProof): unknown {
    const obj: any = {};
    message.key !== undefined &&
      (obj.key = message.key ? TransactionKey.toJSON(message.key) : undefined);
    message.proof !== undefined &&
      (obj.proof = base64FromBytes(
        message.proof !== undefined ? message.proof : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<InclusionProof>, I>>(
    object: I
  ): InclusionProof {
    const message = createBaseInclusionProof();
    message.key =
      object.key !== undefined && object.key !== null
        ? TransactionKey.fromPartial(object.key)
        : undefined;
    message.proof = object.proof ?? new Uint8Array();
    return message;
  },
};

function createBaseLargestBtcReOrg(): LargestBtcReOrg {
  return { blockDiff: 0, rollbackFrom: undefined, rollbackTo: undefined };
}

export const LargestBtcReOrg = {
  encode(
    message: LargestBtcReOrg,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.blockDiff !== 0) {
      writer.uint32(8).uint32(message.blockDiff);
    }
    if (message.rollbackFrom !== undefined) {
      BTCHeaderInfo.encode(
        message.rollbackFrom,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.rollbackTo !== undefined) {
      BTCHeaderInfo.encode(
        message.rollbackTo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LargestBtcReOrg {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLargestBtcReOrg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockDiff = reader.uint32();
          break;
        case 2:
          message.rollbackFrom = BTCHeaderInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.rollbackTo = BTCHeaderInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LargestBtcReOrg {
    return {
      blockDiff: isSet(object.blockDiff) ? Number(object.blockDiff) : 0,
      rollbackFrom: isSet(object.rollbackFrom)
        ? BTCHeaderInfo.fromJSON(object.rollbackFrom)
        : undefined,
      rollbackTo: isSet(object.rollbackTo)
        ? BTCHeaderInfo.fromJSON(object.rollbackTo)
        : undefined,
    };
  },

  toJSON(message: LargestBtcReOrg): unknown {
    const obj: any = {};
    message.blockDiff !== undefined &&
      (obj.blockDiff = Math.round(message.blockDiff));
    message.rollbackFrom !== undefined &&
      (obj.rollbackFrom = message.rollbackFrom
        ? BTCHeaderInfo.toJSON(message.rollbackFrom)
        : undefined);
    message.rollbackTo !== undefined &&
      (obj.rollbackTo = message.rollbackTo
        ? BTCHeaderInfo.toJSON(message.rollbackTo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LargestBtcReOrg>, I>>(
    object: I
  ): LargestBtcReOrg {
    const message = createBaseLargestBtcReOrg();
    message.blockDiff = object.blockDiff ?? 0;
    message.rollbackFrom =
      object.rollbackFrom !== undefined && object.rollbackFrom !== null
        ? BTCHeaderInfo.fromPartial(object.rollbackFrom)
        : undefined;
    message.rollbackTo =
      object.rollbackTo !== undefined && object.rollbackTo !== null
        ? BTCHeaderInfo.fromPartial(object.rollbackTo)
        : undefined;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

const atob: (b64: string) => string =
  globalThis.atob ||
  ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

const btoa: (bin: string) => string =
  globalThis.btoa ||
  ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  for (const byte of arr) {
    bin.push(String.fromCharCode(byte));
  }
  return btoa(bin.join(""));
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = Number(t.seconds) * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
