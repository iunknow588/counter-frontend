/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { ProofOfPossessionBTC } from "../../../babylon/btcstaking/v1/pop";
import { InclusionProof } from "../../../babylon/btcstaking/v1/btcstaking";
import { Params } from "../../../babylon/btcstaking/v1/params";

export const protobufPackage = "babylon.btcstaking.v1";

/** MsgCreateFinalityProvider is the message for creating a finality provider */
export interface MsgCreateFinalityProvider {
  /**
   * addr defines the address of the finality provider that will receive
   * the commissions to all the delegations.
   */
  addr: string;
  /** description defines the description terms for the finality provider */
  description: Description | undefined;
  /**
   * btc_pk is the Bitcoin secp256k1 PK of this finality provider
   * the PK follows encoding in BIP-340 spec
   */
  btcPk: Uint8Array;
  /** pop is the proof of possession of btc_pk over the FP signer address. */
  pop: ProofOfPossessionBTC | undefined;
  /** commission is the finality provider commission information */
  commission: CommissionRates | undefined;
}

/**
 * MsgCreateFinalityProviderResponse is the response for
 * MsgCreateFinalityProvider
 */
export interface MsgCreateFinalityProviderResponse {}

/**
 * CommissionRates defines the initial commission rates to be used for creating
 * a finality provider.
 */
export interface CommissionRates {
  /** rate is the commission rate charged to delegators, as a fraction. */
  rate: string;
  /**
   * max_rate defines the maximum commission rate which finality provider can
   * ever charge, as a fraction.
   */
  maxRate: string;
  /**
   * max_change_rate defines the maximum daily increase of the finality provider
   * commission, as a fraction.
   */
  maxChangeRate: string;
}

/**
 * MsgEditFinalityProvider is the message for editing an existing finality
 * provider
 */
export interface MsgEditFinalityProvider {
  /**
   * addr the address of the finality provider that whishes to edit his
   * information.
   */
  addr: string;
  /** btc_pk is the Bitcoin secp256k1 PK of the finality provider to be edited */
  btcPk: Uint8Array;
  /** description defines the updated description terms for the finality provider */
  description: Description | undefined;
  /** commission defines the updated commission rate of the finality provider */
  commission: string;
}

/** MsgEditFinalityProviderResponse is the response for MsgEditFinalityProvider */
export interface MsgEditFinalityProviderResponse {}

/** MsgCreateBTCDelegation is the message for creating a BTC delegation */
export interface MsgCreateBTCDelegation {
  /** staker_addr is the address to receive rewards from BTC delegation. */
  stakerAddr: string;
  /** pop is the proof of possession of btc_pk by the staker_addr. */
  pop: ProofOfPossessionBTC | undefined;
  /** btc_pk is the Bitcoin secp256k1 PK of the BTC delegator */
  btcPk: Uint8Array;
  /**
   * fp_btc_pk_list is the list of Bitcoin secp256k1 PKs of the finality
   * providers, if there is more than one finality provider pk it means that
   * delegation is re-staked
   */
  fpBtcPkList: Uint8Array[];
  /** staking_time is the time lock used in staking transaction */
  stakingTime: number;
  /** staking_value  is the amount of satoshis locked in staking output */
  stakingValue: string;
  /**
   * staking_tx is a bitcoin staking transaction i.e transaction that locks
   * funds
   */
  stakingTx: Uint8Array;
  /**
   * staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC
   * chain
   */
  stakingTxInclusionProof: InclusionProof | undefined;
  /**
   * slashing_tx is the slashing tx
   * Note that the tx itself does not contain signatures, which are off-chain.
   */
  slashingTx: Uint8Array;
  /**
   * delegator_slashing_sig is the signature on the slashing tx by the delegator
   * (i.e., SK corresponding to btc_pk). It will be a part of the witness for
   * the staking tx output. The staking tx output further needs signatures from
   * covenant and finality provider in order to be spendable.
   */
  delegatorSlashingSig: Uint8Array;
  /**
   * unbonding_time is the time lock used when funds are being unbonded. It is
   * be used in:
   * - unbonding transaction, time lock spending path
   * - staking slashing transaction, change output
   * - unbonding slashing transaction, change output
   * It must be smaller than math.MaxUInt16 and larger that
   * max(MinUnbondingTime, CheckpointFinalizationTimeout)
   */
  unbondingTime: number;
  /**
   * fields related to unbonding transaction
   * unbonding_tx is a bitcoin unbonding transaction i.e transaction that spends
   * staking output and sends it to the unbonding output
   */
  unbondingTx: Uint8Array;
  /**
   * unbonding_value is amount of satoshis locked in unbonding output.
   * NOTE: staking_value and unbonding_value could be different because of the
   * difference between the fee for staking tx and that for unbonding
   */
  unbondingValue: string;
  /**
   * unbonding_slashing_tx is the slashing tx which slash unbonding contract
   * Note that the tx itself does not contain signatures, which are off-chain.
   */
  unbondingSlashingTx: Uint8Array;
  /**
   * delegator_unbonding_slashing_sig is the signature on the slashing tx by the
   * delegator (i.e., SK corresponding to btc_pk).
   */
  delegatorUnbondingSlashingSig: Uint8Array;
}

/** MsgCreateBTCDelegationResponse is the response for MsgCreateBTCDelegation */
export interface MsgCreateBTCDelegationResponse {}

/**
 * MsgAddBTCDelegationInclusionProof is the message for adding proof of
 * inclusion of BTC delegation on BTC chain
 */
export interface MsgAddBTCDelegationInclusionProof {
  signer: string;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC
   * chain
   */
  stakingTxInclusionProof: InclusionProof | undefined;
}

/**
 * MsgAddBTCDelegationInclusionProofResponse is the response for
 * MsgAddBTCDelegationInclusionProof
 */
export interface MsgAddBTCDelegationInclusionProofResponse {}

/**
 * MsgAddCovenantSigs is the message for handling signatures from a covenant
 * member
 */
export interface MsgAddCovenantSigs {
  signer: string;
  /** pk is the BTC public key of the covenant member */
  pk: Uint8Array;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * sigs is a list of adaptor signatures of the covenant
   * the order of sigs should respect the order of finality providers
   * of the corresponding delegation
   */
  slashingTxSigs: Uint8Array[];
  /**
   * unbonding_tx_sig is the signature of the covenant on the unbonding tx
   * submitted to babylon the signature follows encoding in BIP-340 spec
   */
  unbondingTxSig: Uint8Array;
  /**
   * slashing_unbonding_tx_sigs is a list of adaptor signatures of the covenant
   * on slashing tx corresponding to unbonding tx submitted to babylon
   * the order of sigs should respect the order of finality providers
   * of the corresponding delegation
   */
  slashingUnbondingTxSigs: Uint8Array[];
}

/** MsgAddCovenantSigsResponse is the response for MsgAddCovenantSigs */
export interface MsgAddCovenantSigsResponse {}

/**
 * MsgBTCUndelegate is the message for handling signature on unbonding tx
 * from its delegator. This signature effectively proves that the delegator
 * wants to unbond this BTC delegation
 */
export interface MsgBTCUndelegate {
  signer: string;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * stake_spending_tx is a bitcoin transaction that spends the staking
   * transaction i.e it has staking output as an input
   */
  stakeSpendingTx: Uint8Array;
  /**
   * spend_spending_tx_inclusion_proof is the proof of inclusion of the
   * stake_spending_tx in the BTC chain
   */
  stakeSpendingTxInclusionProof: InclusionProof | undefined;
  /**
   * funding_transactions is a list of bitcoin transactions that funds the stake_spending_tx
   * i.e. they are inputs of the stake_spending_tx
   */
  fundingTransactions: Uint8Array[];
}

/** MsgBTCUndelegateResponse is the response for MsgBTCUndelegate */
export interface MsgBTCUndelegateResponse {}

/**
 * MsgSelectiveSlashingEvidence is the message for handling evidence of
 * selective slashing launched by a finality provider
 */
export interface MsgSelectiveSlashingEvidence {
  signer: string;
  /**
   * staking_tx_hash is the hash of the staking tx.
   * It uniquely identifies a BTC delegation
   */
  stakingTxHash: string;
  /**
   * recovered_fp_btc_sk is the BTC SK of the finality provider who
   * launches the selective slashing offence. The SK is recovered by
   * using a covenant adaptor signature and the corresponding Schnorr
   * signature
   */
  recoveredFpBtcSk: Uint8Array;
}

/**
 * MsgSelectiveSlashingEvidenceResponse is the response for
 * MsgSelectiveSlashingEvidence
 */
export interface MsgSelectiveSlashingEvidenceResponse {}

/** MsgUpdateParams defines a message for updating btcstaking module parameters. */
export interface MsgUpdateParams {
  /**
   * authority is the address of the governance account.
   * just FYI: cosmos.AddressString marks that this field should use type alias
   * for AddressString instead of string, but the functionality is not yet
   * implemented in cosmos-proto
   */
  authority: string;
  /**
   * params defines the finality parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response to the MsgUpdateParams message. */
export interface MsgUpdateParamsResponse {}

function createBaseMsgCreateFinalityProvider(): MsgCreateFinalityProvider {
  return {
    addr: "",
    description: undefined,
    btcPk: new Uint8Array(),
    pop: undefined,
    commission: undefined,
  };
}

export const MsgCreateFinalityProvider = {
  encode(
    message: MsgCreateFinalityProvider,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.description !== undefined) {
      Description.encode(
        message.description,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(34).bytes(message.btcPk);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(
        message.pop,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.commission !== undefined) {
      CommissionRates.encode(
        message.commission,
        writer.uint32(58).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgCreateFinalityProvider {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.addr = reader.string();
          break;
        case 2:
          message.description = Description.decode(reader, reader.uint32());
          break;
        case 4:
          message.btcPk = reader.bytes();
          break;
        case 5:
          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          break;
        case 7:
          message.commission = CommissionRates.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateFinalityProvider {
    return {
      addr: isSet(object.addr) ? String(object.addr) : "",
      description: isSet(object.description)
        ? Description.fromJSON(object.description)
        : undefined,
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(),
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      commission: isSet(object.commission)
        ? CommissionRates.fromJSON(object.commission)
        : undefined,
    };
  },

  toJSON(message: MsgCreateFinalityProvider): unknown {
    const obj: any = {};
    message.addr !== undefined && (obj.addr = message.addr);
    message.description !== undefined &&
      (obj.description = message.description
        ? Description.toJSON(message.description)
        : undefined);
    message.btcPk !== undefined &&
      (obj.btcPk = base64FromBytes(
        message.btcPk !== undefined ? message.btcPk : new Uint8Array()
      ));
    message.pop !== undefined &&
      (obj.pop = message.pop
        ? ProofOfPossessionBTC.toJSON(message.pop)
        : undefined);
    message.commission !== undefined &&
      (obj.commission = message.commission
        ? CommissionRates.toJSON(message.commission)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgCreateFinalityProvider>, I>>(
    object: I
  ): MsgCreateFinalityProvider {
    const message = createBaseMsgCreateFinalityProvider();
    message.addr = object.addr ?? "";
    message.description =
      object.description !== undefined && object.description !== null
        ? Description.fromPartial(object.description)
        : undefined;
    message.btcPk = object.btcPk ?? new Uint8Array();
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.commission =
      object.commission !== undefined && object.commission !== null
        ? CommissionRates.fromPartial(object.commission)
        : undefined;
    return message;
  },
};

function createBaseMsgCreateFinalityProviderResponse(): MsgCreateFinalityProviderResponse {
  return {};
}

export const MsgCreateFinalityProviderResponse = {
  encode(
    _: MsgCreateFinalityProviderResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgCreateFinalityProviderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFinalityProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCreateFinalityProviderResponse {
    return {};
  },

  toJSON(_: MsgCreateFinalityProviderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgCreateFinalityProviderResponse>, I>
  >(_: I): MsgCreateFinalityProviderResponse {
    const message = createBaseMsgCreateFinalityProviderResponse();
    return message;
  },
};

function createBaseCommissionRates(): CommissionRates {
  return { rate: "", maxRate: "", maxChangeRate: "" };
}

export const CommissionRates = {
  encode(
    message: CommissionRates,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rate !== "") {
      writer.uint32(10).string(message.rate);
    }
    if (message.maxRate !== "") {
      writer.uint32(18).string(message.maxRate);
    }
    if (message.maxChangeRate !== "") {
      writer.uint32(26).string(message.maxChangeRate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommissionRates {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommissionRates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rate = reader.string();
          break;
        case 2:
          message.maxRate = reader.string();
          break;
        case 3:
          message.maxChangeRate = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CommissionRates {
    return {
      rate: isSet(object.rate) ? String(object.rate) : "",
      maxRate: isSet(object.maxRate) ? String(object.maxRate) : "",
      maxChangeRate: isSet(object.maxChangeRate)
        ? String(object.maxChangeRate)
        : "",
    };
  },

  toJSON(message: CommissionRates): unknown {
    const obj: any = {};
    message.rate !== undefined && (obj.rate = message.rate);
    message.maxRate !== undefined && (obj.maxRate = message.maxRate);
    message.maxChangeRate !== undefined &&
      (obj.maxChangeRate = message.maxChangeRate);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CommissionRates>, I>>(
    object: I
  ): CommissionRates {
    const message = createBaseCommissionRates();
    message.rate = object.rate ?? "";
    message.maxRate = object.maxRate ?? "";
    message.maxChangeRate = object.maxChangeRate ?? "";
    return message;
  },
};

function createBaseMsgEditFinalityProvider(): MsgEditFinalityProvider {
  return {
    addr: "",
    btcPk: new Uint8Array(),
    description: undefined,
    commission: "",
  };
}

export const MsgEditFinalityProvider = {
  encode(
    message: MsgEditFinalityProvider,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(18).bytes(message.btcPk);
    }
    if (message.description !== undefined) {
      Description.encode(
        message.description,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.commission !== "") {
      writer.uint32(34).string(message.commission);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgEditFinalityProvider {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEditFinalityProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.addr = reader.string();
          break;
        case 2:
          message.btcPk = reader.bytes();
          break;
        case 3:
          message.description = Description.decode(reader, reader.uint32());
          break;
        case 4:
          message.commission = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgEditFinalityProvider {
    return {
      addr: isSet(object.addr) ? String(object.addr) : "",
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(),
      description: isSet(object.description)
        ? Description.fromJSON(object.description)
        : undefined,
      commission: isSet(object.commission) ? String(object.commission) : "",
    };
  },

  toJSON(message: MsgEditFinalityProvider): unknown {
    const obj: any = {};
    message.addr !== undefined && (obj.addr = message.addr);
    message.btcPk !== undefined &&
      (obj.btcPk = base64FromBytes(
        message.btcPk !== undefined ? message.btcPk : new Uint8Array()
      ));
    message.description !== undefined &&
      (obj.description = message.description
        ? Description.toJSON(message.description)
        : undefined);
    message.commission !== undefined && (obj.commission = message.commission);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgEditFinalityProvider>, I>>(
    object: I
  ): MsgEditFinalityProvider {
    const message = createBaseMsgEditFinalityProvider();
    message.addr = object.addr ?? "";
    message.btcPk = object.btcPk ?? new Uint8Array();
    message.description =
      object.description !== undefined && object.description !== null
        ? Description.fromPartial(object.description)
        : undefined;
    message.commission = object.commission ?? "";
    return message;
  },
};

function createBaseMsgEditFinalityProviderResponse(): MsgEditFinalityProviderResponse {
  return {};
}

export const MsgEditFinalityProviderResponse = {
  encode(
    _: MsgEditFinalityProviderResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgEditFinalityProviderResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgEditFinalityProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgEditFinalityProviderResponse {
    return {};
  },

  toJSON(_: MsgEditFinalityProviderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgEditFinalityProviderResponse>, I>>(
    _: I
  ): MsgEditFinalityProviderResponse {
    const message = createBaseMsgEditFinalityProviderResponse();
    return message;
  },
};

function createBaseMsgCreateBTCDelegation(): MsgCreateBTCDelegation {
  return {
    stakerAddr: "",
    pop: undefined,
    btcPk: new Uint8Array(),
    fpBtcPkList: [],
    stakingTime: 0,
    stakingValue: "0",
    stakingTx: new Uint8Array(),
    stakingTxInclusionProof: undefined,
    slashingTx: new Uint8Array(),
    delegatorSlashingSig: new Uint8Array(),
    unbondingTime: 0,
    unbondingTx: new Uint8Array(),
    unbondingValue: "0",
    unbondingSlashingTx: new Uint8Array(),
    delegatorUnbondingSlashingSig: new Uint8Array(),
  };
}

export const MsgCreateBTCDelegation = {
  encode(
    message: MsgCreateBTCDelegation,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stakerAddr !== "") {
      writer.uint32(10).string(message.stakerAddr);
    }
    if (message.pop !== undefined) {
      ProofOfPossessionBTC.encode(
        message.pop,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.btcPk.length !== 0) {
      writer.uint32(26).bytes(message.btcPk);
    }
    for (const v of message.fpBtcPkList) {
      writer.uint32(34).bytes(v!);
    }
    if (message.stakingTime !== 0) {
      writer.uint32(40).uint32(message.stakingTime);
    }
    if (message.stakingValue !== "0") {
      writer.uint32(48).int64(message.stakingValue);
    }
    if (message.stakingTx.length !== 0) {
      writer.uint32(58).bytes(message.stakingTx);
    }
    if (message.stakingTxInclusionProof !== undefined) {
      InclusionProof.encode(
        message.stakingTxInclusionProof,
        writer.uint32(66).fork()
      ).ldelim();
    }
    if (message.slashingTx.length !== 0) {
      writer.uint32(74).bytes(message.slashingTx);
    }
    if (message.delegatorSlashingSig.length !== 0) {
      writer.uint32(82).bytes(message.delegatorSlashingSig);
    }
    if (message.unbondingTime !== 0) {
      writer.uint32(88).uint32(message.unbondingTime);
    }
    if (message.unbondingTx.length !== 0) {
      writer.uint32(98).bytes(message.unbondingTx);
    }
    if (message.unbondingValue !== "0") {
      writer.uint32(104).int64(message.unbondingValue);
    }
    if (message.unbondingSlashingTx.length !== 0) {
      writer.uint32(114).bytes(message.unbondingSlashingTx);
    }
    if (message.delegatorUnbondingSlashingSig.length !== 0) {
      writer.uint32(122).bytes(message.delegatorUnbondingSlashingSig);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgCreateBTCDelegation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBTCDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stakerAddr = reader.string();
          break;
        case 2:
          message.pop = ProofOfPossessionBTC.decode(reader, reader.uint32());
          break;
        case 3:
          message.btcPk = reader.bytes();
          break;
        case 4:
          message.fpBtcPkList.push(reader.bytes());
          break;
        case 5:
          message.stakingTime = reader.uint32();
          break;
        case 6:
          message.stakingValue = longToString(reader.int64() as Long);
          break;
        case 7:
          message.stakingTx = reader.bytes();
          break;
        case 8:
          message.stakingTxInclusionProof = InclusionProof.decode(
            reader,
            reader.uint32()
          );
          break;
        case 9:
          message.slashingTx = reader.bytes();
          break;
        case 10:
          message.delegatorSlashingSig = reader.bytes();
          break;
        case 11:
          message.unbondingTime = reader.uint32();
          break;
        case 12:
          message.unbondingTx = reader.bytes();
          break;
        case 13:
          message.unbondingValue = longToString(reader.int64() as Long);
          break;
        case 14:
          message.unbondingSlashingTx = reader.bytes();
          break;
        case 15:
          message.delegatorUnbondingSlashingSig = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBTCDelegation {
    return {
      stakerAddr: isSet(object.stakerAddr) ? String(object.stakerAddr) : "",
      pop: isSet(object.pop)
        ? ProofOfPossessionBTC.fromJSON(object.pop)
        : undefined,
      btcPk: isSet(object.btcPk)
        ? bytesFromBase64(object.btcPk)
        : new Uint8Array(),
      fpBtcPkList: Array.isArray(object?.fpBtcPkList)
        ? object.fpBtcPkList.map((e: any) => bytesFromBase64(e))
        : [],
      stakingTime: isSet(object.stakingTime) ? Number(object.stakingTime) : 0,
      stakingValue: isSet(object.stakingValue)
        ? String(object.stakingValue)
        : "0",
      stakingTx: isSet(object.stakingTx)
        ? bytesFromBase64(object.stakingTx)
        : new Uint8Array(),
      stakingTxInclusionProof: isSet(object.stakingTxInclusionProof)
        ? InclusionProof.fromJSON(object.stakingTxInclusionProof)
        : undefined,
      slashingTx: isSet(object.slashingTx)
        ? bytesFromBase64(object.slashingTx)
        : new Uint8Array(),
      delegatorSlashingSig: isSet(object.delegatorSlashingSig)
        ? bytesFromBase64(object.delegatorSlashingSig)
        : new Uint8Array(),
      unbondingTime: isSet(object.unbondingTime)
        ? Number(object.unbondingTime)
        : 0,
      unbondingTx: isSet(object.unbondingTx)
        ? bytesFromBase64(object.unbondingTx)
        : new Uint8Array(),
      unbondingValue: isSet(object.unbondingValue)
        ? String(object.unbondingValue)
        : "0",
      unbondingSlashingTx: isSet(object.unbondingSlashingTx)
        ? bytesFromBase64(object.unbondingSlashingTx)
        : new Uint8Array(),
      delegatorUnbondingSlashingSig: isSet(object.delegatorUnbondingSlashingSig)
        ? bytesFromBase64(object.delegatorUnbondingSlashingSig)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgCreateBTCDelegation): unknown {
    const obj: any = {};
    message.stakerAddr !== undefined && (obj.stakerAddr = message.stakerAddr);
    message.pop !== undefined &&
      (obj.pop = message.pop
        ? ProofOfPossessionBTC.toJSON(message.pop)
        : undefined);
    message.btcPk !== undefined &&
      (obj.btcPk = base64FromBytes(
        message.btcPk !== undefined ? message.btcPk : new Uint8Array()
      ));
    if (message.fpBtcPkList) {
      obj.fpBtcPkList = message.fpBtcPkList.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.fpBtcPkList = [];
    }
    message.stakingTime !== undefined &&
      (obj.stakingTime = Math.round(message.stakingTime));
    message.stakingValue !== undefined &&
      (obj.stakingValue = message.stakingValue);
    message.stakingTx !== undefined &&
      (obj.stakingTx = base64FromBytes(
        message.stakingTx !== undefined ? message.stakingTx : new Uint8Array()
      ));
    message.stakingTxInclusionProof !== undefined &&
      (obj.stakingTxInclusionProof = message.stakingTxInclusionProof
        ? InclusionProof.toJSON(message.stakingTxInclusionProof)
        : undefined);
    message.slashingTx !== undefined &&
      (obj.slashingTx = base64FromBytes(
        message.slashingTx !== undefined ? message.slashingTx : new Uint8Array()
      ));
    message.delegatorSlashingSig !== undefined &&
      (obj.delegatorSlashingSig = base64FromBytes(
        message.delegatorSlashingSig !== undefined
          ? message.delegatorSlashingSig
          : new Uint8Array()
      ));
    message.unbondingTime !== undefined &&
      (obj.unbondingTime = Math.round(message.unbondingTime));
    message.unbondingTx !== undefined &&
      (obj.unbondingTx = base64FromBytes(
        message.unbondingTx !== undefined
          ? message.unbondingTx
          : new Uint8Array()
      ));
    message.unbondingValue !== undefined &&
      (obj.unbondingValue = message.unbondingValue);
    message.unbondingSlashingTx !== undefined &&
      (obj.unbondingSlashingTx = base64FromBytes(
        message.unbondingSlashingTx !== undefined
          ? message.unbondingSlashingTx
          : new Uint8Array()
      ));
    message.delegatorUnbondingSlashingSig !== undefined &&
      (obj.delegatorUnbondingSlashingSig = base64FromBytes(
        message.delegatorUnbondingSlashingSig !== undefined
          ? message.delegatorUnbondingSlashingSig
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgCreateBTCDelegation>, I>>(
    object: I
  ): MsgCreateBTCDelegation {
    const message = createBaseMsgCreateBTCDelegation();
    message.stakerAddr = object.stakerAddr ?? "";
    message.pop =
      object.pop !== undefined && object.pop !== null
        ? ProofOfPossessionBTC.fromPartial(object.pop)
        : undefined;
    message.btcPk = object.btcPk ?? new Uint8Array();
    message.fpBtcPkList = object.fpBtcPkList?.map((e) => e) || [];
    message.stakingTime = object.stakingTime ?? 0;
    message.stakingValue = object.stakingValue ?? "0";
    message.stakingTx = object.stakingTx ?? new Uint8Array();
    message.stakingTxInclusionProof =
      object.stakingTxInclusionProof !== undefined &&
      object.stakingTxInclusionProof !== null
        ? InclusionProof.fromPartial(object.stakingTxInclusionProof)
        : undefined;
    message.slashingTx = object.slashingTx ?? new Uint8Array();
    message.delegatorSlashingSig =
      object.delegatorSlashingSig ?? new Uint8Array();
    message.unbondingTime = object.unbondingTime ?? 0;
    message.unbondingTx = object.unbondingTx ?? new Uint8Array();
    message.unbondingValue = object.unbondingValue ?? "0";
    message.unbondingSlashingTx =
      object.unbondingSlashingTx ?? new Uint8Array();
    message.delegatorUnbondingSlashingSig =
      object.delegatorUnbondingSlashingSig ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgCreateBTCDelegationResponse(): MsgCreateBTCDelegationResponse {
  return {};
}

export const MsgCreateBTCDelegationResponse = {
  encode(
    _: MsgCreateBTCDelegationResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgCreateBTCDelegationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBTCDelegationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgCreateBTCDelegationResponse {
    return {};
  },

  toJSON(_: MsgCreateBTCDelegationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgCreateBTCDelegationResponse>, I>>(
    _: I
  ): MsgCreateBTCDelegationResponse {
    const message = createBaseMsgCreateBTCDelegationResponse();
    return message;
  },
};

function createBaseMsgAddBTCDelegationInclusionProof(): MsgAddBTCDelegationInclusionProof {
  return { signer: "", stakingTxHash: "", stakingTxInclusionProof: undefined };
}

export const MsgAddBTCDelegationInclusionProof = {
  encode(
    message: MsgAddBTCDelegationInclusionProof,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.stakingTxHash !== "") {
      writer.uint32(18).string(message.stakingTxHash);
    }
    if (message.stakingTxInclusionProof !== undefined) {
      InclusionProof.encode(
        message.stakingTxInclusionProof,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgAddBTCDelegationInclusionProof {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddBTCDelegationInclusionProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.stakingTxHash = reader.string();
          break;
        case 3:
          message.stakingTxInclusionProof = InclusionProof.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgAddBTCDelegationInclusionProof {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      stakingTxHash: isSet(object.stakingTxHash)
        ? String(object.stakingTxHash)
        : "",
      stakingTxInclusionProof: isSet(object.stakingTxInclusionProof)
        ? InclusionProof.fromJSON(object.stakingTxInclusionProof)
        : undefined,
    };
  },

  toJSON(message: MsgAddBTCDelegationInclusionProof): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.stakingTxHash !== undefined &&
      (obj.stakingTxHash = message.stakingTxHash);
    message.stakingTxInclusionProof !== undefined &&
      (obj.stakingTxInclusionProof = message.stakingTxInclusionProof
        ? InclusionProof.toJSON(message.stakingTxInclusionProof)
        : undefined);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgAddBTCDelegationInclusionProof>, I>
  >(object: I): MsgAddBTCDelegationInclusionProof {
    const message = createBaseMsgAddBTCDelegationInclusionProof();
    message.signer = object.signer ?? "";
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.stakingTxInclusionProof =
      object.stakingTxInclusionProof !== undefined &&
      object.stakingTxInclusionProof !== null
        ? InclusionProof.fromPartial(object.stakingTxInclusionProof)
        : undefined;
    return message;
  },
};

function createBaseMsgAddBTCDelegationInclusionProofResponse(): MsgAddBTCDelegationInclusionProofResponse {
  return {};
}

export const MsgAddBTCDelegationInclusionProofResponse = {
  encode(
    _: MsgAddBTCDelegationInclusionProofResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgAddBTCDelegationInclusionProofResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddBTCDelegationInclusionProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgAddBTCDelegationInclusionProofResponse {
    return {};
  },

  toJSON(_: MsgAddBTCDelegationInclusionProofResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgAddBTCDelegationInclusionProofResponse>, I>
  >(_: I): MsgAddBTCDelegationInclusionProofResponse {
    const message = createBaseMsgAddBTCDelegationInclusionProofResponse();
    return message;
  },
};

function createBaseMsgAddCovenantSigs(): MsgAddCovenantSigs {
  return {
    signer: "",
    pk: new Uint8Array(),
    stakingTxHash: "",
    slashingTxSigs: [],
    unbondingTxSig: new Uint8Array(),
    slashingUnbondingTxSigs: [],
  };
}

export const MsgAddCovenantSigs = {
  encode(
    message: MsgAddCovenantSigs,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.pk.length !== 0) {
      writer.uint32(18).bytes(message.pk);
    }
    if (message.stakingTxHash !== "") {
      writer.uint32(26).string(message.stakingTxHash);
    }
    for (const v of message.slashingTxSigs) {
      writer.uint32(34).bytes(v!);
    }
    if (message.unbondingTxSig.length !== 0) {
      writer.uint32(42).bytes(message.unbondingTxSig);
    }
    for (const v of message.slashingUnbondingTxSigs) {
      writer.uint32(50).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddCovenantSigs {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddCovenantSigs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.pk = reader.bytes();
          break;
        case 3:
          message.stakingTxHash = reader.string();
          break;
        case 4:
          message.slashingTxSigs.push(reader.bytes());
          break;
        case 5:
          message.unbondingTxSig = reader.bytes();
          break;
        case 6:
          message.slashingUnbondingTxSigs.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgAddCovenantSigs {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
      stakingTxHash: isSet(object.stakingTxHash)
        ? String(object.stakingTxHash)
        : "",
      slashingTxSigs: Array.isArray(object?.slashingTxSigs)
        ? object.slashingTxSigs.map((e: any) => bytesFromBase64(e))
        : [],
      unbondingTxSig: isSet(object.unbondingTxSig)
        ? bytesFromBase64(object.unbondingTxSig)
        : new Uint8Array(),
      slashingUnbondingTxSigs: Array.isArray(object?.slashingUnbondingTxSigs)
        ? object.slashingUnbondingTxSigs.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: MsgAddCovenantSigs): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.pk !== undefined &&
      (obj.pk = base64FromBytes(
        message.pk !== undefined ? message.pk : new Uint8Array()
      ));
    message.stakingTxHash !== undefined &&
      (obj.stakingTxHash = message.stakingTxHash);
    if (message.slashingTxSigs) {
      obj.slashingTxSigs = message.slashingTxSigs.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.slashingTxSigs = [];
    }
    message.unbondingTxSig !== undefined &&
      (obj.unbondingTxSig = base64FromBytes(
        message.unbondingTxSig !== undefined
          ? message.unbondingTxSig
          : new Uint8Array()
      ));
    if (message.slashingUnbondingTxSigs) {
      obj.slashingUnbondingTxSigs = message.slashingUnbondingTxSigs.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.slashingUnbondingTxSigs = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgAddCovenantSigs>, I>>(
    object: I
  ): MsgAddCovenantSigs {
    const message = createBaseMsgAddCovenantSigs();
    message.signer = object.signer ?? "";
    message.pk = object.pk ?? new Uint8Array();
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.slashingTxSigs = object.slashingTxSigs?.map((e) => e) || [];
    message.unbondingTxSig = object.unbondingTxSig ?? new Uint8Array();
    message.slashingUnbondingTxSigs =
      object.slashingUnbondingTxSigs?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgAddCovenantSigsResponse(): MsgAddCovenantSigsResponse {
  return {};
}

export const MsgAddCovenantSigsResponse = {
  encode(
    _: MsgAddCovenantSigsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgAddCovenantSigsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddCovenantSigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgAddCovenantSigsResponse {
    return {};
  },

  toJSON(_: MsgAddCovenantSigsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgAddCovenantSigsResponse>, I>>(
    _: I
  ): MsgAddCovenantSigsResponse {
    const message = createBaseMsgAddCovenantSigsResponse();
    return message;
  },
};

function createBaseMsgBTCUndelegate(): MsgBTCUndelegate {
  return {
    signer: "",
    stakingTxHash: "",
    stakeSpendingTx: new Uint8Array(),
    stakeSpendingTxInclusionProof: undefined,
    fundingTransactions: [],
  };
}

export const MsgBTCUndelegate = {
  encode(
    message: MsgBTCUndelegate,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.stakingTxHash !== "") {
      writer.uint32(18).string(message.stakingTxHash);
    }
    if (message.stakeSpendingTx.length !== 0) {
      writer.uint32(26).bytes(message.stakeSpendingTx);
    }
    if (message.stakeSpendingTxInclusionProof !== undefined) {
      InclusionProof.encode(
        message.stakeSpendingTxInclusionProof,
        writer.uint32(34).fork()
      ).ldelim();
    }
    for (const v of message.fundingTransactions) {
      writer.uint32(42).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBTCUndelegate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBTCUndelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.stakingTxHash = reader.string();
          break;
        case 3:
          message.stakeSpendingTx = reader.bytes();
          break;
        case 4:
          message.stakeSpendingTxInclusionProof = InclusionProof.decode(
            reader,
            reader.uint32()
          );
          break;
        case 5:
          message.fundingTransactions.push(reader.bytes());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgBTCUndelegate {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      stakingTxHash: isSet(object.stakingTxHash)
        ? String(object.stakingTxHash)
        : "",
      stakeSpendingTx: isSet(object.stakeSpendingTx)
        ? bytesFromBase64(object.stakeSpendingTx)
        : new Uint8Array(),
      stakeSpendingTxInclusionProof: isSet(object.stakeSpendingTxInclusionProof)
        ? InclusionProof.fromJSON(object.stakeSpendingTxInclusionProof)
        : undefined,
      fundingTransactions: Array.isArray(object?.fundingTransactions)
        ? object.fundingTransactions.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: MsgBTCUndelegate): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.stakingTxHash !== undefined &&
      (obj.stakingTxHash = message.stakingTxHash);
    message.stakeSpendingTx !== undefined &&
      (obj.stakeSpendingTx = base64FromBytes(
        message.stakeSpendingTx !== undefined
          ? message.stakeSpendingTx
          : new Uint8Array()
      ));
    message.stakeSpendingTxInclusionProof !== undefined &&
      (obj.stakeSpendingTxInclusionProof = message.stakeSpendingTxInclusionProof
        ? InclusionProof.toJSON(message.stakeSpendingTxInclusionProof)
        : undefined);
    if (message.fundingTransactions) {
      obj.fundingTransactions = message.fundingTransactions.map((e) =>
        base64FromBytes(e !== undefined ? e : new Uint8Array())
      );
    } else {
      obj.fundingTransactions = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgBTCUndelegate>, I>>(
    object: I
  ): MsgBTCUndelegate {
    const message = createBaseMsgBTCUndelegate();
    message.signer = object.signer ?? "";
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.stakeSpendingTx = object.stakeSpendingTx ?? new Uint8Array();
    message.stakeSpendingTxInclusionProof =
      object.stakeSpendingTxInclusionProof !== undefined &&
      object.stakeSpendingTxInclusionProof !== null
        ? InclusionProof.fromPartial(object.stakeSpendingTxInclusionProof)
        : undefined;
    message.fundingTransactions =
      object.fundingTransactions?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgBTCUndelegateResponse(): MsgBTCUndelegateResponse {
  return {};
}

export const MsgBTCUndelegateResponse = {
  encode(
    _: MsgBTCUndelegateResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgBTCUndelegateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBTCUndelegateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgBTCUndelegateResponse {
    return {};
  },

  toJSON(_: MsgBTCUndelegateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgBTCUndelegateResponse>, I>>(
    _: I
  ): MsgBTCUndelegateResponse {
    const message = createBaseMsgBTCUndelegateResponse();
    return message;
  },
};

function createBaseMsgSelectiveSlashingEvidence(): MsgSelectiveSlashingEvidence {
  return { signer: "", stakingTxHash: "", recoveredFpBtcSk: new Uint8Array() };
}

export const MsgSelectiveSlashingEvidence = {
  encode(
    message: MsgSelectiveSlashingEvidence,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.stakingTxHash !== "") {
      writer.uint32(18).string(message.stakingTxHash);
    }
    if (message.recoveredFpBtcSk.length !== 0) {
      writer.uint32(26).bytes(message.recoveredFpBtcSk);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSelectiveSlashingEvidence {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSelectiveSlashingEvidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.stakingTxHash = reader.string();
          break;
        case 3:
          message.recoveredFpBtcSk = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSelectiveSlashingEvidence {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      stakingTxHash: isSet(object.stakingTxHash)
        ? String(object.stakingTxHash)
        : "",
      recoveredFpBtcSk: isSet(object.recoveredFpBtcSk)
        ? bytesFromBase64(object.recoveredFpBtcSk)
        : new Uint8Array(),
    };
  },

  toJSON(message: MsgSelectiveSlashingEvidence): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.stakingTxHash !== undefined &&
      (obj.stakingTxHash = message.stakingTxHash);
    message.recoveredFpBtcSk !== undefined &&
      (obj.recoveredFpBtcSk = base64FromBytes(
        message.recoveredFpBtcSk !== undefined
          ? message.recoveredFpBtcSk
          : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSelectiveSlashingEvidence>, I>>(
    object: I
  ): MsgSelectiveSlashingEvidence {
    const message = createBaseMsgSelectiveSlashingEvidence();
    message.signer = object.signer ?? "";
    message.stakingTxHash = object.stakingTxHash ?? "";
    message.recoveredFpBtcSk = object.recoveredFpBtcSk ?? new Uint8Array();
    return message;
  },
};

function createBaseMsgSelectiveSlashingEvidenceResponse(): MsgSelectiveSlashingEvidenceResponse {
  return {};
}

export const MsgSelectiveSlashingEvidenceResponse = {
  encode(
    _: MsgSelectiveSlashingEvidenceResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgSelectiveSlashingEvidenceResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSelectiveSlashingEvidenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgSelectiveSlashingEvidenceResponse {
    return {};
  },

  toJSON(_: MsgSelectiveSlashingEvidenceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgSelectiveSlashingEvidenceResponse>, I>
  >(_: I): MsgSelectiveSlashingEvidenceResponse {
    const message = createBaseMsgSelectiveSlashingEvidenceResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams = {
  encode(
    message: MsgUpdateParams,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        case 2:
          message.params = Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    message.authority !== undefined && (obj.authority = message.authority);
    message.params !== undefined &&
      (obj.params = message.params ? Params.toJSON(message.params) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(
    object: I
  ): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse = {
  encode(
    _: MsgUpdateParamsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateParamsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(
    _: I
  ): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/**
 * Msg defines the Msg service.
 * TODO: handle unbonding tx with full witness
 */
export interface Msg {
  /** CreateFinalityProvider creates a new finality provider */
  CreateFinalityProvider(
    request: MsgCreateFinalityProvider
  ): Promise<MsgCreateFinalityProviderResponse>;
  /** EditFinalityProvider edits an existing finality provider */
  EditFinalityProvider(
    request: MsgEditFinalityProvider
  ): Promise<MsgEditFinalityProviderResponse>;
  /** CreateBTCDelegation creates a new BTC delegation */
  CreateBTCDelegation(
    request: MsgCreateBTCDelegation
  ): Promise<MsgCreateBTCDelegationResponse>;
  /**
   * AddBTCDelegationInclusionProof adds inclusion proof of a given delegation
   * on BTC chain
   */
  AddBTCDelegationInclusionProof(
    request: MsgAddBTCDelegationInclusionProof
  ): Promise<MsgAddBTCDelegationInclusionProofResponse>;
  /** AddCovenantSigs handles signatures from a covenant member */
  AddCovenantSigs(
    request: MsgAddCovenantSigs
  ): Promise<MsgAddCovenantSigsResponse>;
  /** BTCUndelegate handles a signature on unbonding tx from its delegator */
  BTCUndelegate(request: MsgBTCUndelegate): Promise<MsgBTCUndelegateResponse>;
  /**
   * SelectiveSlashingEvidence handles the evidence of selective slashing
   * launched by a finality provider
   */
  SelectiveSlashingEvidence(
    request: MsgSelectiveSlashingEvidence
  ): Promise<MsgSelectiveSlashingEvidenceResponse>;
  /** UpdateParams updates the btcstaking module parameters. */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

const atob: (b64: string) => string =
  globalThis.atob ||
  ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

const btoa: (bin: string) => string =
  globalThis.btoa ||
  ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  for (const byte of arr) {
    bin.push(String.fromCharCode(byte));
  }
  return btoa(bin.join(""));
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
