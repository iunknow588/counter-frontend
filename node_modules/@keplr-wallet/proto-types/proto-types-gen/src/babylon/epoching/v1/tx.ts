/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  MsgDelegate,
  MsgUndelegate,
  MsgBeginRedelegate,
  MsgCancelUnbondingDelegation,
  MsgEditValidator,
} from "../../../cosmos/staking/v1beta1/tx";
import { Params } from "../../../babylon/epoching/v1/params";

export const protobufPackage = "babylon.epoching.v1";

/** MsgWrappedDelegate is the message for delegating stakes */
export interface MsgWrappedDelegate {
  msg: MsgDelegate | undefined;
}

/** MsgWrappedDelegate is the response to the MsgWrappedDelegate message */
export interface MsgWrappedDelegateResponse {}

/** MsgWrappedUndelegate is the message for undelegating stakes */
export interface MsgWrappedUndelegate {
  msg: MsgUndelegate | undefined;
}

/**
 * MsgWrappedUndelegateResponse is the response to the MsgWrappedUndelegate
 * message
 */
export interface MsgWrappedUndelegateResponse {}

/**
 * MsgWrappedDelegate is the message for moving bonded stakes from a
 * validator to another validator
 */
export interface MsgWrappedBeginRedelegate {
  msg: MsgBeginRedelegate | undefined;
}

/**
 * MsgWrappedBeginRedelegateResponse is the response to the
 * MsgWrappedBeginRedelegate message
 */
export interface MsgWrappedBeginRedelegateResponse {}

/**
 * MsgWrappedCancelUnbondingDelegation is the message for cancelling
 * an unbonding delegation
 */
export interface MsgWrappedCancelUnbondingDelegation {
  msg: MsgCancelUnbondingDelegation | undefined;
}

/**
 * MsgWrappedCancelUnbondingDelegationResponse is the response to the
 * MsgWrappedCancelUnbondingDelegation message
 */
export interface MsgWrappedCancelUnbondingDelegationResponse {}

/**
 * MsgWrappedEditValidator defines a message for updating validator description
 * and commission rate.
 */
export interface MsgWrappedEditValidator {
  msg: MsgEditValidator | undefined;
}

/** MsgWrappedEditValidatorResponse is the response to the MsgWrappedEditValidator message. */
export interface MsgWrappedEditValidatorResponse {}

/** MsgUpdateParams defines a message for updating epoching module parameters. */
export interface MsgUpdateParams {
  /**
   * authority is the address of the governance account.
   * just FYI: cosmos.AddressString marks that this field should use type alias
   * for AddressString instead of string, but the functionality is not yet implemented
   * in cosmos-proto
   */
  authority: string;
  /**
   * params defines the epoching parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response to the MsgUpdateParams message. */
export interface MsgUpdateParamsResponse {}

function createBaseMsgWrappedDelegate(): MsgWrappedDelegate {
  return { msg: undefined };
}

export const MsgWrappedDelegate = {
  encode(
    message: MsgWrappedDelegate,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== undefined) {
      MsgDelegate.encode(message.msg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWrappedDelegate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedDelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = MsgDelegate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWrappedDelegate {
    return {
      msg: isSet(object.msg) ? MsgDelegate.fromJSON(object.msg) : undefined,
    };
  },

  toJSON(message: MsgWrappedDelegate): unknown {
    const obj: any = {};
    message.msg !== undefined &&
      (obj.msg = message.msg ? MsgDelegate.toJSON(message.msg) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedDelegate>, I>>(
    object: I
  ): MsgWrappedDelegate {
    const message = createBaseMsgWrappedDelegate();
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? MsgDelegate.fromPartial(object.msg)
        : undefined;
    return message;
  },
};

function createBaseMsgWrappedDelegateResponse(): MsgWrappedDelegateResponse {
  return {};
}

export const MsgWrappedDelegateResponse = {
  encode(
    _: MsgWrappedDelegateResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedDelegateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedDelegateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWrappedDelegateResponse {
    return {};
  },

  toJSON(_: MsgWrappedDelegateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedDelegateResponse>, I>>(
    _: I
  ): MsgWrappedDelegateResponse {
    const message = createBaseMsgWrappedDelegateResponse();
    return message;
  },
};

function createBaseMsgWrappedUndelegate(): MsgWrappedUndelegate {
  return { msg: undefined };
}

export const MsgWrappedUndelegate = {
  encode(
    message: MsgWrappedUndelegate,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== undefined) {
      MsgUndelegate.encode(message.msg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedUndelegate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedUndelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = MsgUndelegate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWrappedUndelegate {
    return {
      msg: isSet(object.msg) ? MsgUndelegate.fromJSON(object.msg) : undefined,
    };
  },

  toJSON(message: MsgWrappedUndelegate): unknown {
    const obj: any = {};
    message.msg !== undefined &&
      (obj.msg = message.msg ? MsgUndelegate.toJSON(message.msg) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedUndelegate>, I>>(
    object: I
  ): MsgWrappedUndelegate {
    const message = createBaseMsgWrappedUndelegate();
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? MsgUndelegate.fromPartial(object.msg)
        : undefined;
    return message;
  },
};

function createBaseMsgWrappedUndelegateResponse(): MsgWrappedUndelegateResponse {
  return {};
}

export const MsgWrappedUndelegateResponse = {
  encode(
    _: MsgWrappedUndelegateResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedUndelegateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedUndelegateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWrappedUndelegateResponse {
    return {};
  },

  toJSON(_: MsgWrappedUndelegateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedUndelegateResponse>, I>>(
    _: I
  ): MsgWrappedUndelegateResponse {
    const message = createBaseMsgWrappedUndelegateResponse();
    return message;
  },
};

function createBaseMsgWrappedBeginRedelegate(): MsgWrappedBeginRedelegate {
  return { msg: undefined };
}

export const MsgWrappedBeginRedelegate = {
  encode(
    message: MsgWrappedBeginRedelegate,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== undefined) {
      MsgBeginRedelegate.encode(message.msg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedBeginRedelegate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedBeginRedelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = MsgBeginRedelegate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWrappedBeginRedelegate {
    return {
      msg: isSet(object.msg)
        ? MsgBeginRedelegate.fromJSON(object.msg)
        : undefined,
    };
  },

  toJSON(message: MsgWrappedBeginRedelegate): unknown {
    const obj: any = {};
    message.msg !== undefined &&
      (obj.msg = message.msg
        ? MsgBeginRedelegate.toJSON(message.msg)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedBeginRedelegate>, I>>(
    object: I
  ): MsgWrappedBeginRedelegate {
    const message = createBaseMsgWrappedBeginRedelegate();
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? MsgBeginRedelegate.fromPartial(object.msg)
        : undefined;
    return message;
  },
};

function createBaseMsgWrappedBeginRedelegateResponse(): MsgWrappedBeginRedelegateResponse {
  return {};
}

export const MsgWrappedBeginRedelegateResponse = {
  encode(
    _: MsgWrappedBeginRedelegateResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedBeginRedelegateResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedBeginRedelegateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWrappedBeginRedelegateResponse {
    return {};
  },

  toJSON(_: MsgWrappedBeginRedelegateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgWrappedBeginRedelegateResponse>, I>
  >(_: I): MsgWrappedBeginRedelegateResponse {
    const message = createBaseMsgWrappedBeginRedelegateResponse();
    return message;
  },
};

function createBaseMsgWrappedCancelUnbondingDelegation(): MsgWrappedCancelUnbondingDelegation {
  return { msg: undefined };
}

export const MsgWrappedCancelUnbondingDelegation = {
  encode(
    message: MsgWrappedCancelUnbondingDelegation,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== undefined) {
      MsgCancelUnbondingDelegation.encode(
        message.msg,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedCancelUnbondingDelegation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedCancelUnbondingDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = MsgCancelUnbondingDelegation.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWrappedCancelUnbondingDelegation {
    return {
      msg: isSet(object.msg)
        ? MsgCancelUnbondingDelegation.fromJSON(object.msg)
        : undefined,
    };
  },

  toJSON(message: MsgWrappedCancelUnbondingDelegation): unknown {
    const obj: any = {};
    message.msg !== undefined &&
      (obj.msg = message.msg
        ? MsgCancelUnbondingDelegation.toJSON(message.msg)
        : undefined);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgWrappedCancelUnbondingDelegation>, I>
  >(object: I): MsgWrappedCancelUnbondingDelegation {
    const message = createBaseMsgWrappedCancelUnbondingDelegation();
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? MsgCancelUnbondingDelegation.fromPartial(object.msg)
        : undefined;
    return message;
  },
};

function createBaseMsgWrappedCancelUnbondingDelegationResponse(): MsgWrappedCancelUnbondingDelegationResponse {
  return {};
}

export const MsgWrappedCancelUnbondingDelegationResponse = {
  encode(
    _: MsgWrappedCancelUnbondingDelegationResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedCancelUnbondingDelegationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedCancelUnbondingDelegationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWrappedCancelUnbondingDelegationResponse {
    return {};
  },

  toJSON(_: MsgWrappedCancelUnbondingDelegationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<MsgWrappedCancelUnbondingDelegationResponse>, I>
  >(_: I): MsgWrappedCancelUnbondingDelegationResponse {
    const message = createBaseMsgWrappedCancelUnbondingDelegationResponse();
    return message;
  },
};

function createBaseMsgWrappedEditValidator(): MsgWrappedEditValidator {
  return { msg: undefined };
}

export const MsgWrappedEditValidator = {
  encode(
    message: MsgWrappedEditValidator,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== undefined) {
      MsgEditValidator.encode(message.msg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedEditValidator {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedEditValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = MsgEditValidator.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWrappedEditValidator {
    return {
      msg: isSet(object.msg)
        ? MsgEditValidator.fromJSON(object.msg)
        : undefined,
    };
  },

  toJSON(message: MsgWrappedEditValidator): unknown {
    const obj: any = {};
    message.msg !== undefined &&
      (obj.msg = message.msg
        ? MsgEditValidator.toJSON(message.msg)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedEditValidator>, I>>(
    object: I
  ): MsgWrappedEditValidator {
    const message = createBaseMsgWrappedEditValidator();
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? MsgEditValidator.fromPartial(object.msg)
        : undefined;
    return message;
  },
};

function createBaseMsgWrappedEditValidatorResponse(): MsgWrappedEditValidatorResponse {
  return {};
}

export const MsgWrappedEditValidatorResponse = {
  encode(
    _: MsgWrappedEditValidatorResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWrappedEditValidatorResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWrappedEditValidatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWrappedEditValidatorResponse {
    return {};
  },

  toJSON(_: MsgWrappedEditValidatorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWrappedEditValidatorResponse>, I>>(
    _: I
  ): MsgWrappedEditValidatorResponse {
    const message = createBaseMsgWrappedEditValidatorResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams = {
  encode(
    message: MsgUpdateParams,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authority = reader.string();
          break;
        case 2:
          message.params = Params.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    message.authority !== undefined && (obj.authority = message.authority);
    message.params !== undefined &&
      (obj.params = message.params ? Params.toJSON(message.params) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(
    object: I
  ): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params =
      object.params !== undefined && object.params !== null
        ? Params.fromPartial(object.params)
        : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse = {
  encode(
    _: MsgUpdateParamsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUpdateParamsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(
    _: I
  ): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * WrappedDelegate defines a method for performing a delegation of coins from
   * a delegator to a validator.
   */
  WrappedDelegate(
    request: MsgWrappedDelegate
  ): Promise<MsgWrappedDelegateResponse>;
  /**
   * WrappedUndelegate defines a method for performing an undelegation from a
   * delegate and a validator.
   */
  WrappedUndelegate(
    request: MsgWrappedUndelegate
  ): Promise<MsgWrappedUndelegateResponse>;
  /**
   * WrappedBeginRedelegate defines a method for performing a redelegation of
   * coins from a delegator and source validator to a destination validator.
   */
  WrappedBeginRedelegate(
    request: MsgWrappedBeginRedelegate
  ): Promise<MsgWrappedBeginRedelegateResponse>;
  /**
   * WrappedCancelUnbondingDelegation defines a method for cancelling unbonding of
   * coins from a delegator and source validator to a destination validator.
   */
  WrappedCancelUnbondingDelegation(
    request: MsgWrappedCancelUnbondingDelegation
  ): Promise<MsgWrappedCancelUnbondingDelegationResponse>;
  /**
   * WrappedEditValidator defines a method for editing the validator
   * information.
   */
  WrappedEditValidator(
    request: MsgWrappedEditValidator
  ): Promise<MsgWrappedEditValidatorResponse>;
  /** UpdateParams defines a method for updating epoching module parameters. */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
