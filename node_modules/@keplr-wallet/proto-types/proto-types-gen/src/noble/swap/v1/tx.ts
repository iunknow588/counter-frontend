/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  Algorithm,
  algorithmFromJSON,
  algorithmToJSON,
} from "../../../noble/swap/v1/algorithm";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Route, Swap } from "../../../noble/swap/v1/swap";

export const protobufPackage = "noble.swap.v1";

export interface MsgWithdrawProtocolFees {
  /** Address of the signer who is requesting the fee withdrawal. */
  signer: string;
  /** Address to which the withdrawn fees will be sent. */
  to: string;
}

export interface MsgWithdrawProtocolFeesResponse {}

export interface MsgWithdrawRewards {
  /** Address of the signer who is requesting the reward withdrawal. */
  signer: string;
}

export interface MsgWithdrawRewardsResponse {
  /** List of rewards withdrawn by the user. */
  rewards: Coin[];
}

export interface MsgSwap {
  /** Address of the signer who is initiating the swap. */
  signer: string;
  /** The coin to be swapped. */
  amount: Coin | undefined;
  /** The routes through which the swap will occur. */
  routes: Route[];
  /** The minimum amount of tokens expected after the swap. */
  min: Coin | undefined;
}

export interface MsgSwapResponse {
  /** The resulting amount of tokens after the swap. */
  result: Coin | undefined;
  /** Details of each individual swap involved in the process. */
  swaps: Swap[];
}

export interface MsgPauseByAlgorithm {
  /** Address of the signer who is requesting to pause the pools. */
  signer: string;
  /** The algorithm used by the pools to be paused. */
  algorithm: Algorithm;
}

export interface MsgPauseByAlgorithmResponse {
  /** List of IDs of the paused pools. */
  pausedPools: string[];
}

export interface MsgPauseByPoolIds {
  /** Address of the signer who is requesting to pause the pools. */
  signer: string;
  /** List of IDs of the pools to be paused. */
  poolIds: string[];
}

export interface MsgPauseByPoolIdsResponse {
  /** List of IDs of the paused pools. */
  pausedPools: string[];
}

export interface MsgUnpauseByAlgorithm {
  /** Address of the signer who is requesting to unpause the pools. */
  signer: string;
  /** The algorithm used by the pools to be unpaused. */
  algorithm: Algorithm;
}

export interface MsgUnpauseByAlgorithmResponse {
  /** List of IDs of the unpaused pools. */
  unpausedPools: string[];
}

export interface MsgUnpauseByPoolIds {
  /** Address of the signer who is requesting to unpause the pools. */
  signer: string;
  /** List of IDs of the pools to be unpaused. */
  poolIds: string[];
}

export interface MsgUnpauseByPoolIdsResponse {
  /** List of IDs of the unpaused pools. */
  unpausedPools: string[];
}

function createBaseMsgWithdrawProtocolFees(): MsgWithdrawProtocolFees {
  return { signer: "", to: "" };
}

export const MsgWithdrawProtocolFees = {
  encode(
    message: MsgWithdrawProtocolFees,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWithdrawProtocolFees {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawProtocolFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.to = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawProtocolFees {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      to: isSet(object.to) ? String(object.to) : "",
    };
  },

  toJSON(message: MsgWithdrawProtocolFees): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.to !== undefined && (obj.to = message.to);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWithdrawProtocolFees>, I>>(
    object: I
  ): MsgWithdrawProtocolFees {
    const message = createBaseMsgWithdrawProtocolFees();
    message.signer = object.signer ?? "";
    message.to = object.to ?? "";
    return message;
  },
};

function createBaseMsgWithdrawProtocolFeesResponse(): MsgWithdrawProtocolFeesResponse {
  return {};
}

export const MsgWithdrawProtocolFeesResponse = {
  encode(
    _: MsgWithdrawProtocolFeesResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWithdrawProtocolFeesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawProtocolFeesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawProtocolFeesResponse {
    return {};
  },

  toJSON(_: MsgWithdrawProtocolFeesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWithdrawProtocolFeesResponse>, I>>(
    _: I
  ): MsgWithdrawProtocolFeesResponse {
    const message = createBaseMsgWithdrawProtocolFeesResponse();
    return message;
  },
};

function createBaseMsgWithdrawRewards(): MsgWithdrawRewards {
  return { signer: "" };
}

export const MsgWithdrawRewards = {
  encode(
    message: MsgWithdrawRewards,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawRewards {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawRewards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawRewards {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
    };
  },

  toJSON(message: MsgWithdrawRewards): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWithdrawRewards>, I>>(
    object: I
  ): MsgWithdrawRewards {
    const message = createBaseMsgWithdrawRewards();
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseMsgWithdrawRewardsResponse(): MsgWithdrawRewardsResponse {
  return { rewards: [] };
}

export const MsgWithdrawRewardsResponse = {
  encode(
    message: MsgWithdrawRewardsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.rewards) {
      Coin.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgWithdrawRewardsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawRewardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rewards.push(Coin.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawRewardsResponse {
    return {
      rewards: Array.isArray(object?.rewards)
        ? object.rewards.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgWithdrawRewardsResponse): unknown {
    const obj: any = {};
    if (message.rewards) {
      obj.rewards = message.rewards.map((e) =>
        e ? Coin.toJSON(e) : undefined
      );
    } else {
      obj.rewards = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgWithdrawRewardsResponse>, I>>(
    object: I
  ): MsgWithdrawRewardsResponse {
    const message = createBaseMsgWithdrawRewardsResponse();
    message.rewards = object.rewards?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgSwap(): MsgSwap {
  return { signer: "", amount: undefined, routes: [], min: undefined };
}

export const MsgSwap = {
  encode(
    message: MsgSwap,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.routes) {
      Route.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.min !== undefined) {
      Coin.encode(message.min, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwap {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.amount = Coin.decode(reader, reader.uint32());
          break;
        case 3:
          message.routes.push(Route.decode(reader, reader.uint32()));
          break;
        case 4:
          message.min = Coin.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSwap {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      routes: Array.isArray(object?.routes)
        ? object.routes.map((e: any) => Route.fromJSON(e))
        : [],
      min: isSet(object.min) ? Coin.fromJSON(object.min) : undefined,
    };
  },

  toJSON(message: MsgSwap): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.amount !== undefined &&
      (obj.amount = message.amount ? Coin.toJSON(message.amount) : undefined);
    if (message.routes) {
      obj.routes = message.routes.map((e) => (e ? Route.toJSON(e) : undefined));
    } else {
      obj.routes = [];
    }
    message.min !== undefined &&
      (obj.min = message.min ? Coin.toJSON(message.min) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSwap>, I>>(object: I): MsgSwap {
    const message = createBaseMsgSwap();
    message.signer = object.signer ?? "";
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? Coin.fromPartial(object.amount)
        : undefined;
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || [];
    message.min =
      object.min !== undefined && object.min !== null
        ? Coin.fromPartial(object.min)
        : undefined;
    return message;
  },
};

function createBaseMsgSwapResponse(): MsgSwapResponse {
  return { result: undefined, swaps: [] };
}

export const MsgSwapResponse = {
  encode(
    message: MsgSwapResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.result !== undefined) {
      Coin.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.swaps) {
      Swap.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = Coin.decode(reader, reader.uint32());
          break;
        case 2:
          message.swaps.push(Swap.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgSwapResponse {
    return {
      result: isSet(object.result) ? Coin.fromJSON(object.result) : undefined,
      swaps: Array.isArray(object?.swaps)
        ? object.swaps.map((e: any) => Swap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgSwapResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = message.result ? Coin.toJSON(message.result) : undefined);
    if (message.swaps) {
      obj.swaps = message.swaps.map((e) => (e ? Swap.toJSON(e) : undefined));
    } else {
      obj.swaps = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSwapResponse>, I>>(
    object: I
  ): MsgSwapResponse {
    const message = createBaseMsgSwapResponse();
    message.result =
      object.result !== undefined && object.result !== null
        ? Coin.fromPartial(object.result)
        : undefined;
    message.swaps = object.swaps?.map((e) => Swap.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgPauseByAlgorithm(): MsgPauseByAlgorithm {
  return { signer: "", algorithm: 0 };
}

export const MsgPauseByAlgorithm = {
  encode(
    message: MsgPauseByAlgorithm,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgPauseByAlgorithm {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseByAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.algorithm = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPauseByAlgorithm {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      algorithm: isSet(object.algorithm)
        ? algorithmFromJSON(object.algorithm)
        : 0,
    };
  },

  toJSON(message: MsgPauseByAlgorithm): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.algorithm !== undefined &&
      (obj.algorithm = algorithmToJSON(message.algorithm));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgPauseByAlgorithm>, I>>(
    object: I
  ): MsgPauseByAlgorithm {
    const message = createBaseMsgPauseByAlgorithm();
    message.signer = object.signer ?? "";
    message.algorithm = object.algorithm ?? 0;
    return message;
  },
};

function createBaseMsgPauseByAlgorithmResponse(): MsgPauseByAlgorithmResponse {
  return { pausedPools: [] };
}

export const MsgPauseByAlgorithmResponse = {
  encode(
    message: MsgPauseByAlgorithmResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.pausedPools) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgPauseByAlgorithmResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseByAlgorithmResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pausedPools.push(longToString(reader.uint64() as Long));
            }
          } else {
            message.pausedPools.push(longToString(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPauseByAlgorithmResponse {
    return {
      pausedPools: Array.isArray(object?.pausedPools)
        ? object.pausedPools.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgPauseByAlgorithmResponse): unknown {
    const obj: any = {};
    if (message.pausedPools) {
      obj.pausedPools = message.pausedPools.map((e) => e);
    } else {
      obj.pausedPools = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgPauseByAlgorithmResponse>, I>>(
    object: I
  ): MsgPauseByAlgorithmResponse {
    const message = createBaseMsgPauseByAlgorithmResponse();
    message.pausedPools = object.pausedPools?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgPauseByPoolIds(): MsgPauseByPoolIds {
  return { signer: "", poolIds: [] };
}

export const MsgPauseByPoolIds = {
  encode(
    message: MsgPauseByPoolIds,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    writer.uint32(18).fork();
    for (const v of message.poolIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgPauseByPoolIds {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseByPoolIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.poolIds.push(longToString(reader.uint64() as Long));
            }
          } else {
            message.poolIds.push(longToString(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPauseByPoolIds {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      poolIds: Array.isArray(object?.poolIds)
        ? object.poolIds.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgPauseByPoolIds): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    if (message.poolIds) {
      obj.poolIds = message.poolIds.map((e) => e);
    } else {
      obj.poolIds = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgPauseByPoolIds>, I>>(
    object: I
  ): MsgPauseByPoolIds {
    const message = createBaseMsgPauseByPoolIds();
    message.signer = object.signer ?? "";
    message.poolIds = object.poolIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgPauseByPoolIdsResponse(): MsgPauseByPoolIdsResponse {
  return { pausedPools: [] };
}

export const MsgPauseByPoolIdsResponse = {
  encode(
    message: MsgPauseByPoolIdsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.pausedPools) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgPauseByPoolIdsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPauseByPoolIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pausedPools.push(longToString(reader.uint64() as Long));
            }
          } else {
            message.pausedPools.push(longToString(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgPauseByPoolIdsResponse {
    return {
      pausedPools: Array.isArray(object?.pausedPools)
        ? object.pausedPools.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgPauseByPoolIdsResponse): unknown {
    const obj: any = {};
    if (message.pausedPools) {
      obj.pausedPools = message.pausedPools.map((e) => e);
    } else {
      obj.pausedPools = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgPauseByPoolIdsResponse>, I>>(
    object: I
  ): MsgPauseByPoolIdsResponse {
    const message = createBaseMsgPauseByPoolIdsResponse();
    message.pausedPools = object.pausedPools?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUnpauseByAlgorithm(): MsgUnpauseByAlgorithm {
  return { signer: "", algorithm: 0 };
}

export const MsgUnpauseByAlgorithm = {
  encode(
    message: MsgUnpauseByAlgorithm,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseByAlgorithm {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseByAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          message.algorithm = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnpauseByAlgorithm {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      algorithm: isSet(object.algorithm)
        ? algorithmFromJSON(object.algorithm)
        : 0,
    };
  },

  toJSON(message: MsgUnpauseByAlgorithm): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    message.algorithm !== undefined &&
      (obj.algorithm = algorithmToJSON(message.algorithm));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnpauseByAlgorithm>, I>>(
    object: I
  ): MsgUnpauseByAlgorithm {
    const message = createBaseMsgUnpauseByAlgorithm();
    message.signer = object.signer ?? "";
    message.algorithm = object.algorithm ?? 0;
    return message;
  },
};

function createBaseMsgUnpauseByAlgorithmResponse(): MsgUnpauseByAlgorithmResponse {
  return { unpausedPools: [] };
}

export const MsgUnpauseByAlgorithmResponse = {
  encode(
    message: MsgUnpauseByAlgorithmResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.unpausedPools) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseByAlgorithmResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseByAlgorithmResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unpausedPools.push(longToString(reader.uint64() as Long));
            }
          } else {
            message.unpausedPools.push(longToString(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnpauseByAlgorithmResponse {
    return {
      unpausedPools: Array.isArray(object?.unpausedPools)
        ? object.unpausedPools.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgUnpauseByAlgorithmResponse): unknown {
    const obj: any = {};
    if (message.unpausedPools) {
      obj.unpausedPools = message.unpausedPools.map((e) => e);
    } else {
      obj.unpausedPools = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnpauseByAlgorithmResponse>, I>>(
    object: I
  ): MsgUnpauseByAlgorithmResponse {
    const message = createBaseMsgUnpauseByAlgorithmResponse();
    message.unpausedPools = object.unpausedPools?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUnpauseByPoolIds(): MsgUnpauseByPoolIds {
  return { signer: "", poolIds: [] };
}

export const MsgUnpauseByPoolIds = {
  encode(
    message: MsgUnpauseByPoolIds,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    writer.uint32(18).fork();
    for (const v of message.poolIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnpauseByPoolIds {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseByPoolIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signer = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.poolIds.push(longToString(reader.uint64() as Long));
            }
          } else {
            message.poolIds.push(longToString(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnpauseByPoolIds {
    return {
      signer: isSet(object.signer) ? String(object.signer) : "",
      poolIds: Array.isArray(object?.poolIds)
        ? object.poolIds.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgUnpauseByPoolIds): unknown {
    const obj: any = {};
    message.signer !== undefined && (obj.signer = message.signer);
    if (message.poolIds) {
      obj.poolIds = message.poolIds.map((e) => e);
    } else {
      obj.poolIds = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnpauseByPoolIds>, I>>(
    object: I
  ): MsgUnpauseByPoolIds {
    const message = createBaseMsgUnpauseByPoolIds();
    message.signer = object.signer ?? "";
    message.poolIds = object.poolIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUnpauseByPoolIdsResponse(): MsgUnpauseByPoolIdsResponse {
  return { unpausedPools: [] };
}

export const MsgUnpauseByPoolIdsResponse = {
  encode(
    message: MsgUnpauseByPoolIdsResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.unpausedPools) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MsgUnpauseByPoolIdsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnpauseByPoolIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unpausedPools.push(longToString(reader.uint64() as Long));
            }
          } else {
            message.unpausedPools.push(longToString(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MsgUnpauseByPoolIdsResponse {
    return {
      unpausedPools: Array.isArray(object?.unpausedPools)
        ? object.unpausedPools.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: MsgUnpauseByPoolIdsResponse): unknown {
    const obj: any = {};
    if (message.unpausedPools) {
      obj.unpausedPools = message.unpausedPools.map((e) => e);
    } else {
      obj.unpausedPools = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgUnpauseByPoolIdsResponse>, I>>(
    object: I
  ): MsgUnpauseByPoolIdsResponse {
    const message = createBaseMsgUnpauseByPoolIdsResponse();
    message.unpausedPools = object.unpausedPools?.map((e) => e) || [];
    return message;
  },
};

export interface Msg {
  /** Swap allows a user to swap one type of token for another, using multiple routes. */
  Swap(request: MsgSwap): Promise<MsgSwapResponse>;
  /** WithdrawProtocolFees allows the protocol to withdraw accumulated fees and move them to another account. */
  WithdrawProtocolFees(
    request: MsgWithdrawProtocolFees
  ): Promise<MsgWithdrawProtocolFeesResponse>;
  /** WithdrawRewards allows a user to claim their accumulated rewards. */
  WithdrawRewards(
    request: MsgWithdrawRewards
  ): Promise<MsgWithdrawRewardsResponse>;
  /** PauseByAlgorithm pauses all pools using a specific algorithm. */
  PauseByAlgorithm(
    request: MsgPauseByAlgorithm
  ): Promise<MsgPauseByAlgorithmResponse>;
  /** PauseByPoolIds pauses specific pools identified by their pool IDs. */
  PauseByPoolIds(
    request: MsgPauseByPoolIds
  ): Promise<MsgPauseByPoolIdsResponse>;
  /** UnpauseByAlgorithm unpauses all pools using a specific algorithm. */
  UnpauseByAlgorithm(
    request: MsgUnpauseByAlgorithm
  ): Promise<MsgUnpauseByAlgorithmResponse>;
  /** UnpauseByPoolIds unpauses specific pools identified by their pool IDs. */
  UnpauseByPoolIds(
    request: MsgUnpauseByPoolIds
  ): Promise<MsgUnpauseByPoolIdsResponse>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
