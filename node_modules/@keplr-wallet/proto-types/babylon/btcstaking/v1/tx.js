"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgSelectiveSlashingEvidenceResponse = exports.MsgSelectiveSlashingEvidence = exports.MsgBTCUndelegateResponse = exports.MsgBTCUndelegate = exports.MsgAddCovenantSigsResponse = exports.MsgAddCovenantSigs = exports.MsgAddBTCDelegationInclusionProofResponse = exports.MsgAddBTCDelegationInclusionProof = exports.MsgCreateBTCDelegationResponse = exports.MsgCreateBTCDelegation = exports.MsgEditFinalityProviderResponse = exports.MsgEditFinalityProvider = exports.CommissionRates = exports.MsgCreateFinalityProviderResponse = exports.MsgCreateFinalityProvider = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const staking_1 = require("../../../cosmos/staking/v1beta1/staking");
const pop_1 = require("../../../babylon/btcstaking/v1/pop");
const btcstaking_1 = require("../../../babylon/btcstaking/v1/btcstaking");
const params_1 = require("../../../babylon/btcstaking/v1/params");
exports.protobufPackage = "babylon.btcstaking.v1";
function createBaseMsgCreateFinalityProvider() {
    return {
        addr: "",
        description: undefined,
        btcPk: new Uint8Array(),
        pop: undefined,
        commission: undefined,
    };
}
exports.MsgCreateFinalityProvider = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.addr !== "") {
            writer.uint32(10).string(message.addr);
        }
        if (message.description !== undefined) {
            staking_1.Description.encode(message.description, writer.uint32(18).fork()).ldelim();
        }
        if (message.btcPk.length !== 0) {
            writer.uint32(34).bytes(message.btcPk);
        }
        if (message.pop !== undefined) {
            pop_1.ProofOfPossessionBTC.encode(message.pop, writer.uint32(42).fork()).ldelim();
        }
        if (message.commission !== undefined) {
            exports.CommissionRates.encode(message.commission, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateFinalityProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.description = staking_1.Description.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.btcPk = reader.bytes();
                    break;
                case 5:
                    message.pop = pop_1.ProofOfPossessionBTC.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.commission = exports.CommissionRates.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            addr: isSet(object.addr) ? String(object.addr) : "",
            description: isSet(object.description)
                ? staking_1.Description.fromJSON(object.description)
                : undefined,
            btcPk: isSet(object.btcPk)
                ? bytesFromBase64(object.btcPk)
                : new Uint8Array(),
            pop: isSet(object.pop)
                ? pop_1.ProofOfPossessionBTC.fromJSON(object.pop)
                : undefined,
            commission: isSet(object.commission)
                ? exports.CommissionRates.fromJSON(object.commission)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.addr !== undefined && (obj.addr = message.addr);
        message.description !== undefined &&
            (obj.description = message.description
                ? staking_1.Description.toJSON(message.description)
                : undefined);
        message.btcPk !== undefined &&
            (obj.btcPk = base64FromBytes(message.btcPk !== undefined ? message.btcPk : new Uint8Array()));
        message.pop !== undefined &&
            (obj.pop = message.pop
                ? pop_1.ProofOfPossessionBTC.toJSON(message.pop)
                : undefined);
        message.commission !== undefined &&
            (obj.commission = message.commission
                ? exports.CommissionRates.toJSON(message.commission)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgCreateFinalityProvider();
        message.addr = (_a = object.addr) !== null && _a !== void 0 ? _a : "";
        message.description =
            object.description !== undefined && object.description !== null
                ? staking_1.Description.fromPartial(object.description)
                : undefined;
        message.btcPk = (_b = object.btcPk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.pop =
            object.pop !== undefined && object.pop !== null
                ? pop_1.ProofOfPossessionBTC.fromPartial(object.pop)
                : undefined;
        message.commission =
            object.commission !== undefined && object.commission !== null
                ? exports.CommissionRates.fromPartial(object.commission)
                : undefined;
        return message;
    },
};
function createBaseMsgCreateFinalityProviderResponse() {
    return {};
}
exports.MsgCreateFinalityProviderResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateFinalityProviderResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgCreateFinalityProviderResponse();
        return message;
    },
};
function createBaseCommissionRates() {
    return { rate: "", maxRate: "", maxChangeRate: "" };
}
exports.CommissionRates = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rate !== "") {
            writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
            writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
            writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rate = reader.string();
                    break;
                case 2:
                    message.maxRate = reader.string();
                    break;
                case 3:
                    message.maxChangeRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            rate: isSet(object.rate) ? String(object.rate) : "",
            maxRate: isSet(object.maxRate) ? String(object.maxRate) : "",
            maxChangeRate: isSet(object.maxChangeRate)
                ? String(object.maxChangeRate)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.rate !== undefined && (obj.rate = message.rate);
        message.maxRate !== undefined && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== undefined &&
            (obj.maxChangeRate = message.maxChangeRate);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCommissionRates();
        message.rate = (_a = object.rate) !== null && _a !== void 0 ? _a : "";
        message.maxRate = (_b = object.maxRate) !== null && _b !== void 0 ? _b : "";
        message.maxChangeRate = (_c = object.maxChangeRate) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgEditFinalityProvider() {
    return {
        addr: "",
        btcPk: new Uint8Array(),
        description: undefined,
        commission: "",
    };
}
exports.MsgEditFinalityProvider = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.addr !== "") {
            writer.uint32(10).string(message.addr);
        }
        if (message.btcPk.length !== 0) {
            writer.uint32(18).bytes(message.btcPk);
        }
        if (message.description !== undefined) {
            staking_1.Description.encode(message.description, writer.uint32(26).fork()).ldelim();
        }
        if (message.commission !== "") {
            writer.uint32(34).string(message.commission);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgEditFinalityProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.btcPk = reader.bytes();
                    break;
                case 3:
                    message.description = staking_1.Description.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.commission = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            addr: isSet(object.addr) ? String(object.addr) : "",
            btcPk: isSet(object.btcPk)
                ? bytesFromBase64(object.btcPk)
                : new Uint8Array(),
            description: isSet(object.description)
                ? staking_1.Description.fromJSON(object.description)
                : undefined,
            commission: isSet(object.commission) ? String(object.commission) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.addr !== undefined && (obj.addr = message.addr);
        message.btcPk !== undefined &&
            (obj.btcPk = base64FromBytes(message.btcPk !== undefined ? message.btcPk : new Uint8Array()));
        message.description !== undefined &&
            (obj.description = message.description
                ? staking_1.Description.toJSON(message.description)
                : undefined);
        message.commission !== undefined && (obj.commission = message.commission);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgEditFinalityProvider();
        message.addr = (_a = object.addr) !== null && _a !== void 0 ? _a : "";
        message.btcPk = (_b = object.btcPk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.description =
            object.description !== undefined && object.description !== null
                ? staking_1.Description.fromPartial(object.description)
                : undefined;
        message.commission = (_c = object.commission) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgEditFinalityProviderResponse() {
    return {};
}
exports.MsgEditFinalityProviderResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgEditFinalityProviderResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgEditFinalityProviderResponse();
        return message;
    },
};
function createBaseMsgCreateBTCDelegation() {
    return {
        stakerAddr: "",
        pop: undefined,
        btcPk: new Uint8Array(),
        fpBtcPkList: [],
        stakingTime: 0,
        stakingValue: "0",
        stakingTx: new Uint8Array(),
        stakingTxInclusionProof: undefined,
        slashingTx: new Uint8Array(),
        delegatorSlashingSig: new Uint8Array(),
        unbondingTime: 0,
        unbondingTx: new Uint8Array(),
        unbondingValue: "0",
        unbondingSlashingTx: new Uint8Array(),
        delegatorUnbondingSlashingSig: new Uint8Array(),
    };
}
exports.MsgCreateBTCDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stakerAddr !== "") {
            writer.uint32(10).string(message.stakerAddr);
        }
        if (message.pop !== undefined) {
            pop_1.ProofOfPossessionBTC.encode(message.pop, writer.uint32(18).fork()).ldelim();
        }
        if (message.btcPk.length !== 0) {
            writer.uint32(26).bytes(message.btcPk);
        }
        for (const v of message.fpBtcPkList) {
            writer.uint32(34).bytes(v);
        }
        if (message.stakingTime !== 0) {
            writer.uint32(40).uint32(message.stakingTime);
        }
        if (message.stakingValue !== "0") {
            writer.uint32(48).int64(message.stakingValue);
        }
        if (message.stakingTx.length !== 0) {
            writer.uint32(58).bytes(message.stakingTx);
        }
        if (message.stakingTxInclusionProof !== undefined) {
            btcstaking_1.InclusionProof.encode(message.stakingTxInclusionProof, writer.uint32(66).fork()).ldelim();
        }
        if (message.slashingTx.length !== 0) {
            writer.uint32(74).bytes(message.slashingTx);
        }
        if (message.delegatorSlashingSig.length !== 0) {
            writer.uint32(82).bytes(message.delegatorSlashingSig);
        }
        if (message.unbondingTime !== 0) {
            writer.uint32(88).uint32(message.unbondingTime);
        }
        if (message.unbondingTx.length !== 0) {
            writer.uint32(98).bytes(message.unbondingTx);
        }
        if (message.unbondingValue !== "0") {
            writer.uint32(104).int64(message.unbondingValue);
        }
        if (message.unbondingSlashingTx.length !== 0) {
            writer.uint32(114).bytes(message.unbondingSlashingTx);
        }
        if (message.delegatorUnbondingSlashingSig.length !== 0) {
            writer.uint32(122).bytes(message.delegatorUnbondingSlashingSig);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateBTCDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stakerAddr = reader.string();
                    break;
                case 2:
                    message.pop = pop_1.ProofOfPossessionBTC.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.btcPk = reader.bytes();
                    break;
                case 4:
                    message.fpBtcPkList.push(reader.bytes());
                    break;
                case 5:
                    message.stakingTime = reader.uint32();
                    break;
                case 6:
                    message.stakingValue = longToString(reader.int64());
                    break;
                case 7:
                    message.stakingTx = reader.bytes();
                    break;
                case 8:
                    message.stakingTxInclusionProof = btcstaking_1.InclusionProof.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.slashingTx = reader.bytes();
                    break;
                case 10:
                    message.delegatorSlashingSig = reader.bytes();
                    break;
                case 11:
                    message.unbondingTime = reader.uint32();
                    break;
                case 12:
                    message.unbondingTx = reader.bytes();
                    break;
                case 13:
                    message.unbondingValue = longToString(reader.int64());
                    break;
                case 14:
                    message.unbondingSlashingTx = reader.bytes();
                    break;
                case 15:
                    message.delegatorUnbondingSlashingSig = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            stakerAddr: isSet(object.stakerAddr) ? String(object.stakerAddr) : "",
            pop: isSet(object.pop)
                ? pop_1.ProofOfPossessionBTC.fromJSON(object.pop)
                : undefined,
            btcPk: isSet(object.btcPk)
                ? bytesFromBase64(object.btcPk)
                : new Uint8Array(),
            fpBtcPkList: Array.isArray(object === null || object === void 0 ? void 0 : object.fpBtcPkList)
                ? object.fpBtcPkList.map((e) => bytesFromBase64(e))
                : [],
            stakingTime: isSet(object.stakingTime) ? Number(object.stakingTime) : 0,
            stakingValue: isSet(object.stakingValue)
                ? String(object.stakingValue)
                : "0",
            stakingTx: isSet(object.stakingTx)
                ? bytesFromBase64(object.stakingTx)
                : new Uint8Array(),
            stakingTxInclusionProof: isSet(object.stakingTxInclusionProof)
                ? btcstaking_1.InclusionProof.fromJSON(object.stakingTxInclusionProof)
                : undefined,
            slashingTx: isSet(object.slashingTx)
                ? bytesFromBase64(object.slashingTx)
                : new Uint8Array(),
            delegatorSlashingSig: isSet(object.delegatorSlashingSig)
                ? bytesFromBase64(object.delegatorSlashingSig)
                : new Uint8Array(),
            unbondingTime: isSet(object.unbondingTime)
                ? Number(object.unbondingTime)
                : 0,
            unbondingTx: isSet(object.unbondingTx)
                ? bytesFromBase64(object.unbondingTx)
                : new Uint8Array(),
            unbondingValue: isSet(object.unbondingValue)
                ? String(object.unbondingValue)
                : "0",
            unbondingSlashingTx: isSet(object.unbondingSlashingTx)
                ? bytesFromBase64(object.unbondingSlashingTx)
                : new Uint8Array(),
            delegatorUnbondingSlashingSig: isSet(object.delegatorUnbondingSlashingSig)
                ? bytesFromBase64(object.delegatorUnbondingSlashingSig)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.stakerAddr !== undefined && (obj.stakerAddr = message.stakerAddr);
        message.pop !== undefined &&
            (obj.pop = message.pop
                ? pop_1.ProofOfPossessionBTC.toJSON(message.pop)
                : undefined);
        message.btcPk !== undefined &&
            (obj.btcPk = base64FromBytes(message.btcPk !== undefined ? message.btcPk : new Uint8Array()));
        if (message.fpBtcPkList) {
            obj.fpBtcPkList = message.fpBtcPkList.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.fpBtcPkList = [];
        }
        message.stakingTime !== undefined &&
            (obj.stakingTime = Math.round(message.stakingTime));
        message.stakingValue !== undefined &&
            (obj.stakingValue = message.stakingValue);
        message.stakingTx !== undefined &&
            (obj.stakingTx = base64FromBytes(message.stakingTx !== undefined ? message.stakingTx : new Uint8Array()));
        message.stakingTxInclusionProof !== undefined &&
            (obj.stakingTxInclusionProof = message.stakingTxInclusionProof
                ? btcstaking_1.InclusionProof.toJSON(message.stakingTxInclusionProof)
                : undefined);
        message.slashingTx !== undefined &&
            (obj.slashingTx = base64FromBytes(message.slashingTx !== undefined ? message.slashingTx : new Uint8Array()));
        message.delegatorSlashingSig !== undefined &&
            (obj.delegatorSlashingSig = base64FromBytes(message.delegatorSlashingSig !== undefined
                ? message.delegatorSlashingSig
                : new Uint8Array()));
        message.unbondingTime !== undefined &&
            (obj.unbondingTime = Math.round(message.unbondingTime));
        message.unbondingTx !== undefined &&
            (obj.unbondingTx = base64FromBytes(message.unbondingTx !== undefined
                ? message.unbondingTx
                : new Uint8Array()));
        message.unbondingValue !== undefined &&
            (obj.unbondingValue = message.unbondingValue);
        message.unbondingSlashingTx !== undefined &&
            (obj.unbondingSlashingTx = base64FromBytes(message.unbondingSlashingTx !== undefined
                ? message.unbondingSlashingTx
                : new Uint8Array()));
        message.delegatorUnbondingSlashingSig !== undefined &&
            (obj.delegatorUnbondingSlashingSig = base64FromBytes(message.delegatorUnbondingSlashingSig !== undefined
                ? message.delegatorUnbondingSlashingSig
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const message = createBaseMsgCreateBTCDelegation();
        message.stakerAddr = (_a = object.stakerAddr) !== null && _a !== void 0 ? _a : "";
        message.pop =
            object.pop !== undefined && object.pop !== null
                ? pop_1.ProofOfPossessionBTC.fromPartial(object.pop)
                : undefined;
        message.btcPk = (_b = object.btcPk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.fpBtcPkList = ((_c = object.fpBtcPkList) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.stakingTime = (_d = object.stakingTime) !== null && _d !== void 0 ? _d : 0;
        message.stakingValue = (_e = object.stakingValue) !== null && _e !== void 0 ? _e : "0";
        message.stakingTx = (_f = object.stakingTx) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.stakingTxInclusionProof =
            object.stakingTxInclusionProof !== undefined &&
                object.stakingTxInclusionProof !== null
                ? btcstaking_1.InclusionProof.fromPartial(object.stakingTxInclusionProof)
                : undefined;
        message.slashingTx = (_g = object.slashingTx) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.delegatorSlashingSig =
            (_h = object.delegatorSlashingSig) !== null && _h !== void 0 ? _h : new Uint8Array();
        message.unbondingTime = (_j = object.unbondingTime) !== null && _j !== void 0 ? _j : 0;
        message.unbondingTx = (_k = object.unbondingTx) !== null && _k !== void 0 ? _k : new Uint8Array();
        message.unbondingValue = (_l = object.unbondingValue) !== null && _l !== void 0 ? _l : "0";
        message.unbondingSlashingTx =
            (_m = object.unbondingSlashingTx) !== null && _m !== void 0 ? _m : new Uint8Array();
        message.delegatorUnbondingSlashingSig =
            (_o = object.delegatorUnbondingSlashingSig) !== null && _o !== void 0 ? _o : new Uint8Array();
        return message;
    },
};
function createBaseMsgCreateBTCDelegationResponse() {
    return {};
}
exports.MsgCreateBTCDelegationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateBTCDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgCreateBTCDelegationResponse();
        return message;
    },
};
function createBaseMsgAddBTCDelegationInclusionProof() {
    return { signer: "", stakingTxHash: "", stakingTxInclusionProof: undefined };
}
exports.MsgAddBTCDelegationInclusionProof = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.stakingTxHash !== "") {
            writer.uint32(18).string(message.stakingTxHash);
        }
        if (message.stakingTxInclusionProof !== undefined) {
            btcstaking_1.InclusionProof.encode(message.stakingTxInclusionProof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddBTCDelegationInclusionProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.stakingTxHash = reader.string();
                    break;
                case 3:
                    message.stakingTxInclusionProof = btcstaking_1.InclusionProof.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signer: isSet(object.signer) ? String(object.signer) : "",
            stakingTxHash: isSet(object.stakingTxHash)
                ? String(object.stakingTxHash)
                : "",
            stakingTxInclusionProof: isSet(object.stakingTxInclusionProof)
                ? btcstaking_1.InclusionProof.fromJSON(object.stakingTxInclusionProof)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.stakingTxHash !== undefined &&
            (obj.stakingTxHash = message.stakingTxHash);
        message.stakingTxInclusionProof !== undefined &&
            (obj.stakingTxInclusionProof = message.stakingTxInclusionProof
                ? btcstaking_1.InclusionProof.toJSON(message.stakingTxInclusionProof)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgAddBTCDelegationInclusionProof();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.stakingTxHash = (_b = object.stakingTxHash) !== null && _b !== void 0 ? _b : "";
        message.stakingTxInclusionProof =
            object.stakingTxInclusionProof !== undefined &&
                object.stakingTxInclusionProof !== null
                ? btcstaking_1.InclusionProof.fromPartial(object.stakingTxInclusionProof)
                : undefined;
        return message;
    },
};
function createBaseMsgAddBTCDelegationInclusionProofResponse() {
    return {};
}
exports.MsgAddBTCDelegationInclusionProofResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddBTCDelegationInclusionProofResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgAddBTCDelegationInclusionProofResponse();
        return message;
    },
};
function createBaseMsgAddCovenantSigs() {
    return {
        signer: "",
        pk: new Uint8Array(),
        stakingTxHash: "",
        slashingTxSigs: [],
        unbondingTxSig: new Uint8Array(),
        slashingUnbondingTxSigs: [],
    };
}
exports.MsgAddCovenantSigs = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.pk.length !== 0) {
            writer.uint32(18).bytes(message.pk);
        }
        if (message.stakingTxHash !== "") {
            writer.uint32(26).string(message.stakingTxHash);
        }
        for (const v of message.slashingTxSigs) {
            writer.uint32(34).bytes(v);
        }
        if (message.unbondingTxSig.length !== 0) {
            writer.uint32(42).bytes(message.unbondingTxSig);
        }
        for (const v of message.slashingUnbondingTxSigs) {
            writer.uint32(50).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddCovenantSigs();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.pk = reader.bytes();
                    break;
                case 3:
                    message.stakingTxHash = reader.string();
                    break;
                case 4:
                    message.slashingTxSigs.push(reader.bytes());
                    break;
                case 5:
                    message.unbondingTxSig = reader.bytes();
                    break;
                case 6:
                    message.slashingUnbondingTxSigs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signer: isSet(object.signer) ? String(object.signer) : "",
            pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
            stakingTxHash: isSet(object.stakingTxHash)
                ? String(object.stakingTxHash)
                : "",
            slashingTxSigs: Array.isArray(object === null || object === void 0 ? void 0 : object.slashingTxSigs)
                ? object.slashingTxSigs.map((e) => bytesFromBase64(e))
                : [],
            unbondingTxSig: isSet(object.unbondingTxSig)
                ? bytesFromBase64(object.unbondingTxSig)
                : new Uint8Array(),
            slashingUnbondingTxSigs: Array.isArray(object === null || object === void 0 ? void 0 : object.slashingUnbondingTxSigs)
                ? object.slashingUnbondingTxSigs.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.pk !== undefined &&
            (obj.pk = base64FromBytes(message.pk !== undefined ? message.pk : new Uint8Array()));
        message.stakingTxHash !== undefined &&
            (obj.stakingTxHash = message.stakingTxHash);
        if (message.slashingTxSigs) {
            obj.slashingTxSigs = message.slashingTxSigs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.slashingTxSigs = [];
        }
        message.unbondingTxSig !== undefined &&
            (obj.unbondingTxSig = base64FromBytes(message.unbondingTxSig !== undefined
                ? message.unbondingTxSig
                : new Uint8Array()));
        if (message.slashingUnbondingTxSigs) {
            obj.slashingUnbondingTxSigs = message.slashingUnbondingTxSigs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.slashingUnbondingTxSigs = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseMsgAddCovenantSigs();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.pk = (_b = object.pk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.stakingTxHash = (_c = object.stakingTxHash) !== null && _c !== void 0 ? _c : "";
        message.slashingTxSigs = ((_d = object.slashingTxSigs) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        message.unbondingTxSig = (_e = object.unbondingTxSig) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.slashingUnbondingTxSigs =
            ((_f = object.slashingUnbondingTxSigs) === null || _f === void 0 ? void 0 : _f.map((e) => e)) || [];
        return message;
    },
};
function createBaseMsgAddCovenantSigsResponse() {
    return {};
}
exports.MsgAddCovenantSigsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddCovenantSigsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgAddCovenantSigsResponse();
        return message;
    },
};
function createBaseMsgBTCUndelegate() {
    return {
        signer: "",
        stakingTxHash: "",
        stakeSpendingTx: new Uint8Array(),
        stakeSpendingTxInclusionProof: undefined,
        fundingTransactions: [],
    };
}
exports.MsgBTCUndelegate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.stakingTxHash !== "") {
            writer.uint32(18).string(message.stakingTxHash);
        }
        if (message.stakeSpendingTx.length !== 0) {
            writer.uint32(26).bytes(message.stakeSpendingTx);
        }
        if (message.stakeSpendingTxInclusionProof !== undefined) {
            btcstaking_1.InclusionProof.encode(message.stakeSpendingTxInclusionProof, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.fundingTransactions) {
            writer.uint32(42).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBTCUndelegate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.stakingTxHash = reader.string();
                    break;
                case 3:
                    message.stakeSpendingTx = reader.bytes();
                    break;
                case 4:
                    message.stakeSpendingTxInclusionProof = btcstaking_1.InclusionProof.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.fundingTransactions.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signer: isSet(object.signer) ? String(object.signer) : "",
            stakingTxHash: isSet(object.stakingTxHash)
                ? String(object.stakingTxHash)
                : "",
            stakeSpendingTx: isSet(object.stakeSpendingTx)
                ? bytesFromBase64(object.stakeSpendingTx)
                : new Uint8Array(),
            stakeSpendingTxInclusionProof: isSet(object.stakeSpendingTxInclusionProof)
                ? btcstaking_1.InclusionProof.fromJSON(object.stakeSpendingTxInclusionProof)
                : undefined,
            fundingTransactions: Array.isArray(object === null || object === void 0 ? void 0 : object.fundingTransactions)
                ? object.fundingTransactions.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.stakingTxHash !== undefined &&
            (obj.stakingTxHash = message.stakingTxHash);
        message.stakeSpendingTx !== undefined &&
            (obj.stakeSpendingTx = base64FromBytes(message.stakeSpendingTx !== undefined
                ? message.stakeSpendingTx
                : new Uint8Array()));
        message.stakeSpendingTxInclusionProof !== undefined &&
            (obj.stakeSpendingTxInclusionProof = message.stakeSpendingTxInclusionProof
                ? btcstaking_1.InclusionProof.toJSON(message.stakeSpendingTxInclusionProof)
                : undefined);
        if (message.fundingTransactions) {
            obj.fundingTransactions = message.fundingTransactions.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.fundingTransactions = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgBTCUndelegate();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.stakingTxHash = (_b = object.stakingTxHash) !== null && _b !== void 0 ? _b : "";
        message.stakeSpendingTx = (_c = object.stakeSpendingTx) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.stakeSpendingTxInclusionProof =
            object.stakeSpendingTxInclusionProof !== undefined &&
                object.stakeSpendingTxInclusionProof !== null
                ? btcstaking_1.InclusionProof.fromPartial(object.stakeSpendingTxInclusionProof)
                : undefined;
        message.fundingTransactions =
            ((_d = object.fundingTransactions) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        return message;
    },
};
function createBaseMsgBTCUndelegateResponse() {
    return {};
}
exports.MsgBTCUndelegateResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBTCUndelegateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgBTCUndelegateResponse();
        return message;
    },
};
function createBaseMsgSelectiveSlashingEvidence() {
    return { signer: "", stakingTxHash: "", recoveredFpBtcSk: new Uint8Array() };
}
exports.MsgSelectiveSlashingEvidence = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.stakingTxHash !== "") {
            writer.uint32(18).string(message.stakingTxHash);
        }
        if (message.recoveredFpBtcSk.length !== 0) {
            writer.uint32(26).bytes(message.recoveredFpBtcSk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSelectiveSlashingEvidence();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signer = reader.string();
                    break;
                case 2:
                    message.stakingTxHash = reader.string();
                    break;
                case 3:
                    message.recoveredFpBtcSk = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            signer: isSet(object.signer) ? String(object.signer) : "",
            stakingTxHash: isSet(object.stakingTxHash)
                ? String(object.stakingTxHash)
                : "",
            recoveredFpBtcSk: isSet(object.recoveredFpBtcSk)
                ? bytesFromBase64(object.recoveredFpBtcSk)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.signer !== undefined && (obj.signer = message.signer);
        message.stakingTxHash !== undefined &&
            (obj.stakingTxHash = message.stakingTxHash);
        message.recoveredFpBtcSk !== undefined &&
            (obj.recoveredFpBtcSk = base64FromBytes(message.recoveredFpBtcSk !== undefined
                ? message.recoveredFpBtcSk
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgSelectiveSlashingEvidence();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.stakingTxHash = (_b = object.stakingTxHash) !== null && _b !== void 0 ? _b : "";
        message.recoveredFpBtcSk = (_c = object.recoveredFpBtcSk) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    },
};
function createBaseMsgSelectiveSlashingEvidenceResponse() {
    return {};
}
exports.MsgSelectiveSlashingEvidenceResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSelectiveSlashingEvidenceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgSelectiveSlashingEvidenceResponse();
        return message;
    },
};
function createBaseMsgUpdateParams() {
    return { authority: "", params: undefined };
}
exports.MsgUpdateParams = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.authority !== "") {
            writer.uint32(10).string(message.authority);
        }
        if (message.params !== undefined) {
            params_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authority = reader.string();
                    break;
                case 2:
                    message.params = params_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            authority: isSet(object.authority) ? String(object.authority) : "",
            params: isSet(object.params) ? params_1.Params.fromJSON(object.params) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.authority !== undefined && (obj.authority = message.authority);
        message.params !== undefined &&
            (obj.params = message.params ? params_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.authority = (_a = object.authority) !== null && _a !== void 0 ? _a : "";
        message.params =
            object.params !== undefined && object.params !== null
                ? params_1.Params.fromPartial(object.params)
                : undefined;
        return message;
    },
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
exports.MsgUpdateParamsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map