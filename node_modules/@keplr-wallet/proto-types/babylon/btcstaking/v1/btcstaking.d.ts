import _m0 from "protobufjs/minimal";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { ProofOfPossessionBTC } from "../../../babylon/btcstaking/v1/pop";
import { TransactionKey } from "../../../babylon/btccheckpoint/v1/btccheckpoint";
import { BTCHeaderInfo } from "../../../babylon/btclightclient/v1/btclightclient";
export declare const protobufPackage = "babylon.btcstaking.v1";
/**
 * BTCDelegationStatus is the status of a delegation.
 * There are two possible valid state transition paths for a BTC delegation:
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED -> EXPIRED
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED/EXPIRED
 * and one invalid state transition path:
 * - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
 * activating delegation on Babylon chain.
 * In valid transition paths, the delegation becomes UNBONDED when:
 * - either the staking transaction timelock expires
 * - or the staker requests early undelegation through MsgBTCUndelegate message.
 */
export declare enum BTCDelegationStatus {
    /** PENDING - PENDING defines a delegation that is waiting for covenant signatures. */
    PENDING = 0,
    /**
     * VERIFIED - VERIFIED defines a delegation that has covenant signatures but is not yet
     * included in the BTC chain.
     */
    VERIFIED = 1,
    /** ACTIVE - ACTIVE defines a delegation that has voting power */
    ACTIVE = 2,
    /**
     * UNBONDED - UNBONDED defines a delegation no longer has voting power
     * by receiving unbonding tx with signatures from staker and covenant
     * committee
     */
    UNBONDED = 3,
    /**
     * EXPIRED - EXPIRED defines a delegation no longer has voting power
     * for reaching the end of staking transaction timelock
     */
    EXPIRED = 4,
    /** ANY - ANY is any of the above status */
    ANY = 5,
    UNRECOGNIZED = -1
}
export declare function bTCDelegationStatusFromJSON(object: any): BTCDelegationStatus;
export declare function bTCDelegationStatusToJSON(object: BTCDelegationStatus): string;
/** FinalityProvider defines a finality provider */
export interface FinalityProvider {
    /** addr is the bech32 address identifier of the finality provider. */
    addr: string;
    /** description defines the description terms for the finality provider. */
    description: Description | undefined;
    /** commission defines the commission rate of the finality provider. */
    commission: string;
    /**
     * btc_pk is the Bitcoin secp256k1 PK of this finality provider
     * the PK follows encoding in BIP-340 spec
     */
    btcPk: Uint8Array;
    /**
     * pop is the proof of possession of the btc_pk, where the BTC
     * private key signs the bech32 bbn addr of the finality provider.
     */
    pop: ProofOfPossessionBTC | undefined;
    /**
     * slashed_babylon_height indicates the Babylon height when
     * the finality provider is slashed.
     * if it's 0 then the finality provider is not slashed
     */
    slashedBabylonHeight: string;
    /**
     * slashed_btc_height indicates the BTC height when
     * the finality provider is slashed.
     * if it's 0 then the finality provider is not slashed
     */
    slashedBtcHeight: number;
    /** jailed defines whether the finality provider is jailed */
    jailed: boolean;
    /**
     * highest_voted_height is the highest height for which the
     * finality provider has voted
     */
    highestVotedHeight: number;
    /** commission_info contains information details of the finality provider commission. */
    commissionInfo: CommissionInfo | undefined;
}
/**
 * CommissionInfo defines the information related to the commission of
 * a finality provider.
 */
export interface CommissionInfo {
    /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
    maxRate: string;
    /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
    maxChangeRate: string;
    /** update_time is the last time the commission rate was changed. */
    updateTime: Date | undefined;
}
/** FinalityProviderWithMeta wraps the FinalityProvider with metadata. */
export interface FinalityProviderWithMeta {
    /**
     * btc_pk is the Bitcoin secp256k1 PK of thisfinality provider
     * the PK follows encoding in BIP-340 spec
     */
    btcPk: Uint8Array;
    /** height is the queried Babylon height */
    height: string;
    /**
     * voting_power is the voting power of this finality provider at the given
     * height
     */
    votingPower: string;
    /**
     * slashed_babylon_height indicates the Babylon height when
     * the finality provider is slashed.
     * if it's 0 then the finality provider is not slashed
     */
    slashedBabylonHeight: string;
    /**
     * slashed_btc_height indicates the BTC height when
     * the finality provider is slashed.
     * if it's 0 then the finality provider is not slashed
     */
    slashedBtcHeight: number;
    /** jailed defines whether the finality provider is detected jailed */
    jailed: boolean;
    /**
     * highest_voted_height is the highest height for which the
     * finality provider has voted
     */
    highestVotedHeight: number;
}
/** BTCDelegation defines a BTC delegation */
export interface BTCDelegation {
    /** staker_addr is the address to receive rewards from BTC delegation. */
    stakerAddr: string;
    /**
     * btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
     * the PK follows encoding in BIP-340 spec
     */
    btcPk: Uint8Array;
    /** pop is the proof of possession of babylon_pk and btc_pk */
    pop: ProofOfPossessionBTC | undefined;
    /**
     * fp_btc_pk_list is the list of BIP-340 PKs of the finality providers that
     * this BTC delegation delegates to
     * If there is more than 1 PKs, then this means the delegation is restaked
     * to multiple finality providers
     */
    fpBtcPkList: Uint8Array[];
    /**
     * staking_time is the number of blocks for which the delegation is locked on
     * BTC chain
     */
    stakingTime: number;
    /**
     * start_height is the start BTC height of the BTC delegation
     * it is the start BTC height of the timelock
     */
    startHeight: number;
    /**
     * end_height is the end height of the BTC delegation
     * it is calculated by end_height = start_height + staking_time
     */
    endHeight: number;
    /**
     * total_sat is the total amount of BTC stakes in this delegation
     * quantified in satoshi
     */
    totalSat: string;
    /** staking_tx is the staking tx */
    stakingTx: Uint8Array;
    /** staking_output_idx is the index of the staking output in the staking tx */
    stakingOutputIdx: number;
    /**
     * slashing_tx is the slashing tx
     * It is partially signed by SK corresponding to btc_pk, but not signed by
     * finality provider or covenant yet.
     */
    slashingTx: Uint8Array;
    /**
     * delegator_sig is the signature on the slashing tx
     * by the delegator (i.e., SK corresponding to btc_pk).
     * It will be a part of the witness for the staking tx output.
     */
    delegatorSig: Uint8Array;
    /**
     * covenant_sigs is a list of adaptor signatures on the slashing tx
     * by each covenant member
     * It will be a part of the witness for the staking tx output.
     */
    covenantSigs: CovenantAdaptorSignatures[];
    /**
     * unbonding_time describes how long the funds will be locked either in
     * unbonding output or slashing change output
     */
    unbondingTime: number;
    /**
     * btc_undelegation is the information about the early unbonding path of the
     * BTC delegation
     */
    btcUndelegation: BTCUndelegation | undefined;
    /** version of the params used to validate the delegation */
    paramsVersion: number;
    /**
     * btc_tip_height is the height of the BTC light client tip at the time of
     * the delegation creation
     */
    btcTipHeight: number;
}
/**
 * DelegatorUnbondingInfo contains the information about transaction which spent
 * the staking output. It contains:
 * - spend_stake_tx: the transaction which spent the staking output
 */
export interface DelegatorUnbondingInfo {
    /**
     * spend_stake_tx is the transaction which spent the staking output. It is
     * filled only if spend_stake_tx is different than unbonding_tx registered
     * on the Babylon chain.
     */
    spendStakeTx: Uint8Array;
}
/**
 * BTCUndelegation contains the information about the early unbonding path of
 * the BTC delegation
 */
export interface BTCUndelegation {
    /**
     * unbonding_tx is the transaction which will transfer the funds from staking
     * output to unbonding output. Unbonding output will usually have lower
     * timelock than staking output.
     */
    unbondingTx: Uint8Array;
    /**
     * slashing_tx is the slashing tx for unbonding transactions
     * It is partially signed by SK corresponding to btc_pk, but not signed by
     * finality provider or covenant yet.
     */
    slashingTx: Uint8Array;
    /**
     * delegator_slashing_sig is the signature on the slashing tx
     * by the delegator (i.e., SK corresponding to btc_pk).
     * It will be a part of the witness for the unbonding tx output.
     */
    delegatorSlashingSig: Uint8Array;
    /**
     * covenant_slashing_sigs is a list of adaptor signatures on the slashing tx
     * by each covenant member
     * It will be a part of the witness for the staking tx output.
     */
    covenantSlashingSigs: CovenantAdaptorSignatures[];
    /**
     * covenant_unbonding_sig_list is the list of signatures on the unbonding tx
     * by covenant members
     * It must be provided after processing undelegate message by Babylon
     */
    covenantUnbondingSigList: SignatureInfo[];
    /**
     * delegator_unbonding_info is the information about transaction which spent
     * the staking output
     */
    delegatorUnbondingInfo: DelegatorUnbondingInfo | undefined;
}
/**
 * BTCDelegatorDelegations is a collection of BTC delegations from the same
 * delegator.
 */
export interface BTCDelegatorDelegations {
    dels: BTCDelegation[];
}
/**
 * BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations
 * from the same delegator.
 */
export interface BTCDelegatorDelegationIndex {
    stakingTxHashList: Uint8Array[];
}
/** SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK */
export interface SignatureInfo {
    pk: Uint8Array;
    sig: Uint8Array;
}
/**
 * CovenantAdaptorSignatures is a list adaptor signatures signed by the
 * covenant with different finality provider's public keys as encryption keys
 */
export interface CovenantAdaptorSignatures {
    /**
     * cov_pk is the public key of the covenant emulator, used as the public key
     * of the adaptor signature
     */
    covPk: Uint8Array;
    /**
     * adaptor_sigs is a list of adaptor signatures, each encrypted by a restaked
     * BTC finality provider's public key
     */
    adaptorSigs: Uint8Array[];
}
/**
 * SelectiveSlashingEvidence is the evidence that the finality provider
 * selectively slashed a BTC delegation
 * NOTE: it's possible that a slashed finality provider exploits the
 * SelectiveSlashingEvidence endpoint while it is actually slashed due to
 * equivocation. But such behaviour does not affect the system's security
 * or gives any benefit for the adversary
 */
export interface SelectiveSlashingEvidence {
    /**
     * staking_tx_hash is the hash of the staking tx.
     * It uniquely identifies a BTC delegation
     */
    stakingTxHash: string;
    /**
     * fp_btc_pk is the BTC PK of the finality provider who
     * launches the selective slashing offence
     */
    fpBtcPk: Uint8Array;
    /**
     * recovered_fp_btc_sk is the finality provider's BTC SK recovered from
     * the covenant adaptor/Schnorr signature pair. It is the consequence
     * of selective slashing.
     */
    recoveredFpBtcSk: Uint8Array;
}
/**
 * InclusionProof proves the existence of tx on BTC blockchain
 * including
 * - the position of the tx on BTC blockchain
 * - the Merkle proof that this tx is on the above position
 */
export interface InclusionProof {
    /** key is the position (txIdx, blockHash) of this tx on BTC blockchain */
    key: TransactionKey | undefined;
    /** proof is the Merkle proof that this tx is included in the position in `key` */
    proof: Uint8Array;
}
/** LargestBtcReOrg stores the largest BTC reorg recorded */
export interface LargestBtcReOrg {
    /**
     * BlockDiff is the difference of the block height of the BTC header Tip - the btc height
     * which it was rolled back
     */
    blockDiff: number;
    /** RollbackFrom is the latest BTC block header prior to rollback */
    rollbackFrom: BTCHeaderInfo | undefined;
    /** RollbackTo is the BTC block header which we rollback to */
    rollbackTo: BTCHeaderInfo | undefined;
}
export declare const FinalityProvider: {
    encode(message: FinalityProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FinalityProvider;
    fromJSON(object: any): FinalityProvider;
    toJSON(message: FinalityProvider): unknown;
    fromPartial<I extends {
        addr?: string | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
        commission?: string | undefined;
        btcPk?: Uint8Array | undefined;
        pop?: {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } | undefined;
        slashedBabylonHeight?: string | undefined;
        slashedBtcHeight?: number | undefined;
        jailed?: boolean | undefined;
        highestVotedHeight?: number | undefined;
        commissionInfo?: {
            maxRate?: string | undefined;
            maxChangeRate?: string | undefined;
            updateTime?: Date | undefined;
        } | undefined;
    } & {
        addr?: string | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
        commission?: string | undefined;
        btcPk?: Uint8Array | undefined;
        pop?: ({
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["pop"], keyof ProofOfPossessionBTC>, never>) | undefined;
        slashedBabylonHeight?: string | undefined;
        slashedBtcHeight?: number | undefined;
        jailed?: boolean | undefined;
        highestVotedHeight?: number | undefined;
        commissionInfo?: ({
            maxRate?: string | undefined;
            maxChangeRate?: string | undefined;
            updateTime?: Date | undefined;
        } & {
            maxRate?: string | undefined;
            maxChangeRate?: string | undefined;
            updateTime?: Date | undefined;
        } & Record<Exclude<keyof I["commissionInfo"], keyof CommissionInfo>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof FinalityProvider>, never>>(object: I): FinalityProvider;
};
export declare const CommissionInfo: {
    encode(message: CommissionInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommissionInfo;
    fromJSON(object: any): CommissionInfo;
    toJSON(message: CommissionInfo): unknown;
    fromPartial<I extends {
        maxRate?: string | undefined;
        maxChangeRate?: string | undefined;
        updateTime?: Date | undefined;
    } & {
        maxRate?: string | undefined;
        maxChangeRate?: string | undefined;
        updateTime?: Date | undefined;
    } & Record<Exclude<keyof I, keyof CommissionInfo>, never>>(object: I): CommissionInfo;
};
export declare const FinalityProviderWithMeta: {
    encode(message: FinalityProviderWithMeta, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FinalityProviderWithMeta;
    fromJSON(object: any): FinalityProviderWithMeta;
    toJSON(message: FinalityProviderWithMeta): unknown;
    fromPartial<I extends {
        btcPk?: Uint8Array | undefined;
        height?: string | undefined;
        votingPower?: string | undefined;
        slashedBabylonHeight?: string | undefined;
        slashedBtcHeight?: number | undefined;
        jailed?: boolean | undefined;
        highestVotedHeight?: number | undefined;
    } & {
        btcPk?: Uint8Array | undefined;
        height?: string | undefined;
        votingPower?: string | undefined;
        slashedBabylonHeight?: string | undefined;
        slashedBtcHeight?: number | undefined;
        jailed?: boolean | undefined;
        highestVotedHeight?: number | undefined;
    } & Record<Exclude<keyof I, keyof FinalityProviderWithMeta>, never>>(object: I): FinalityProviderWithMeta;
};
export declare const BTCDelegation: {
    encode(message: BTCDelegation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BTCDelegation;
    fromJSON(object: any): BTCDelegation;
    toJSON(message: BTCDelegation): unknown;
    fromPartial<I extends {
        stakerAddr?: string | undefined;
        btcPk?: Uint8Array | undefined;
        pop?: {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } | undefined;
        fpBtcPkList?: Uint8Array[] | undefined;
        stakingTime?: number | undefined;
        startHeight?: number | undefined;
        endHeight?: number | undefined;
        totalSat?: string | undefined;
        stakingTx?: Uint8Array | undefined;
        stakingOutputIdx?: number | undefined;
        slashingTx?: Uint8Array | undefined;
        delegatorSig?: Uint8Array | undefined;
        covenantSigs?: {
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        }[] | undefined;
        unbondingTime?: number | undefined;
        btcUndelegation?: {
            unbondingTx?: Uint8Array | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSlashingSig?: Uint8Array | undefined;
            covenantSlashingSigs?: {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] | undefined;
            covenantUnbondingSigList?: {
                pk?: Uint8Array | undefined;
                sig?: Uint8Array | undefined;
            }[] | undefined;
            delegatorUnbondingInfo?: {
                spendStakeTx?: Uint8Array | undefined;
            } | undefined;
        } | undefined;
        paramsVersion?: number | undefined;
        btcTipHeight?: number | undefined;
    } & {
        stakerAddr?: string | undefined;
        btcPk?: Uint8Array | undefined;
        pop?: ({
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["pop"], keyof ProofOfPossessionBTC>, never>) | undefined;
        fpBtcPkList?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["fpBtcPkList"], keyof Uint8Array[]>, never>) | undefined;
        stakingTime?: number | undefined;
        startHeight?: number | undefined;
        endHeight?: number | undefined;
        totalSat?: string | undefined;
        stakingTx?: Uint8Array | undefined;
        stakingOutputIdx?: number | undefined;
        slashingTx?: Uint8Array | undefined;
        delegatorSig?: Uint8Array | undefined;
        covenantSigs?: ({
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        }[] & ({
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        } & {
            covPk?: Uint8Array | undefined;
            adaptorSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["covenantSigs"][number]["adaptorSigs"], keyof Uint8Array[]>, never>) | undefined;
        } & Record<Exclude<keyof I["covenantSigs"][number], keyof CovenantAdaptorSignatures>, never>)[] & Record<Exclude<keyof I["covenantSigs"], keyof {
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        }[]>, never>) | undefined;
        unbondingTime?: number | undefined;
        btcUndelegation?: ({
            unbondingTx?: Uint8Array | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSlashingSig?: Uint8Array | undefined;
            covenantSlashingSigs?: {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] | undefined;
            covenantUnbondingSigList?: {
                pk?: Uint8Array | undefined;
                sig?: Uint8Array | undefined;
            }[] | undefined;
            delegatorUnbondingInfo?: {
                spendStakeTx?: Uint8Array | undefined;
            } | undefined;
        } & {
            unbondingTx?: Uint8Array | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSlashingSig?: Uint8Array | undefined;
            covenantSlashingSigs?: ({
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] & ({
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            } & {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["btcUndelegation"]["covenantSlashingSigs"][number]["adaptorSigs"], keyof Uint8Array[]>, never>) | undefined;
            } & Record<Exclude<keyof I["btcUndelegation"]["covenantSlashingSigs"][number], keyof CovenantAdaptorSignatures>, never>)[] & Record<Exclude<keyof I["btcUndelegation"]["covenantSlashingSigs"], keyof {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[]>, never>) | undefined;
            covenantUnbondingSigList?: ({
                pk?: Uint8Array | undefined;
                sig?: Uint8Array | undefined;
            }[] & ({
                pk?: Uint8Array | undefined;
                sig?: Uint8Array | undefined;
            } & {
                pk?: Uint8Array | undefined;
                sig?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["btcUndelegation"]["covenantUnbondingSigList"][number], keyof SignatureInfo>, never>)[] & Record<Exclude<keyof I["btcUndelegation"]["covenantUnbondingSigList"], keyof {
                pk?: Uint8Array | undefined;
                sig?: Uint8Array | undefined;
            }[]>, never>) | undefined;
            delegatorUnbondingInfo?: ({
                spendStakeTx?: Uint8Array | undefined;
            } & {
                spendStakeTx?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["btcUndelegation"]["delegatorUnbondingInfo"], "spendStakeTx">, never>) | undefined;
        } & Record<Exclude<keyof I["btcUndelegation"], keyof BTCUndelegation>, never>) | undefined;
        paramsVersion?: number | undefined;
        btcTipHeight?: number | undefined;
    } & Record<Exclude<keyof I, keyof BTCDelegation>, never>>(object: I): BTCDelegation;
};
export declare const DelegatorUnbondingInfo: {
    encode(message: DelegatorUnbondingInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DelegatorUnbondingInfo;
    fromJSON(object: any): DelegatorUnbondingInfo;
    toJSON(message: DelegatorUnbondingInfo): unknown;
    fromPartial<I extends {
        spendStakeTx?: Uint8Array | undefined;
    } & {
        spendStakeTx?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, "spendStakeTx">, never>>(object: I): DelegatorUnbondingInfo;
};
export declare const BTCUndelegation: {
    encode(message: BTCUndelegation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BTCUndelegation;
    fromJSON(object: any): BTCUndelegation;
    toJSON(message: BTCUndelegation): unknown;
    fromPartial<I extends {
        unbondingTx?: Uint8Array | undefined;
        slashingTx?: Uint8Array | undefined;
        delegatorSlashingSig?: Uint8Array | undefined;
        covenantSlashingSigs?: {
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        }[] | undefined;
        covenantUnbondingSigList?: {
            pk?: Uint8Array | undefined;
            sig?: Uint8Array | undefined;
        }[] | undefined;
        delegatorUnbondingInfo?: {
            spendStakeTx?: Uint8Array | undefined;
        } | undefined;
    } & {
        unbondingTx?: Uint8Array | undefined;
        slashingTx?: Uint8Array | undefined;
        delegatorSlashingSig?: Uint8Array | undefined;
        covenantSlashingSigs?: ({
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        }[] & ({
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        } & {
            covPk?: Uint8Array | undefined;
            adaptorSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["covenantSlashingSigs"][number]["adaptorSigs"], keyof Uint8Array[]>, never>) | undefined;
        } & Record<Exclude<keyof I["covenantSlashingSigs"][number], keyof CovenantAdaptorSignatures>, never>)[] & Record<Exclude<keyof I["covenantSlashingSigs"], keyof {
            covPk?: Uint8Array | undefined;
            adaptorSigs?: Uint8Array[] | undefined;
        }[]>, never>) | undefined;
        covenantUnbondingSigList?: ({
            pk?: Uint8Array | undefined;
            sig?: Uint8Array | undefined;
        }[] & ({
            pk?: Uint8Array | undefined;
            sig?: Uint8Array | undefined;
        } & {
            pk?: Uint8Array | undefined;
            sig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["covenantUnbondingSigList"][number], keyof SignatureInfo>, never>)[] & Record<Exclude<keyof I["covenantUnbondingSigList"], keyof {
            pk?: Uint8Array | undefined;
            sig?: Uint8Array | undefined;
        }[]>, never>) | undefined;
        delegatorUnbondingInfo?: ({
            spendStakeTx?: Uint8Array | undefined;
        } & {
            spendStakeTx?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["delegatorUnbondingInfo"], "spendStakeTx">, never>) | undefined;
    } & Record<Exclude<keyof I, keyof BTCUndelegation>, never>>(object: I): BTCUndelegation;
};
export declare const BTCDelegatorDelegations: {
    encode(message: BTCDelegatorDelegations, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BTCDelegatorDelegations;
    fromJSON(object: any): BTCDelegatorDelegations;
    toJSON(message: BTCDelegatorDelegations): unknown;
    fromPartial<I extends {
        dels?: {
            stakerAddr?: string | undefined;
            btcPk?: Uint8Array | undefined;
            pop?: {
                btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
                btcSig?: Uint8Array | undefined;
            } | undefined;
            fpBtcPkList?: Uint8Array[] | undefined;
            stakingTime?: number | undefined;
            startHeight?: number | undefined;
            endHeight?: number | undefined;
            totalSat?: string | undefined;
            stakingTx?: Uint8Array | undefined;
            stakingOutputIdx?: number | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSig?: Uint8Array | undefined;
            covenantSigs?: {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] | undefined;
            unbondingTime?: number | undefined;
            btcUndelegation?: {
                unbondingTx?: Uint8Array | undefined;
                slashingTx?: Uint8Array | undefined;
                delegatorSlashingSig?: Uint8Array | undefined;
                covenantSlashingSigs?: {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[] | undefined;
                covenantUnbondingSigList?: {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[] | undefined;
                delegatorUnbondingInfo?: {
                    spendStakeTx?: Uint8Array | undefined;
                } | undefined;
            } | undefined;
            paramsVersion?: number | undefined;
            btcTipHeight?: number | undefined;
        }[] | undefined;
    } & {
        dels?: ({
            stakerAddr?: string | undefined;
            btcPk?: Uint8Array | undefined;
            pop?: {
                btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
                btcSig?: Uint8Array | undefined;
            } | undefined;
            fpBtcPkList?: Uint8Array[] | undefined;
            stakingTime?: number | undefined;
            startHeight?: number | undefined;
            endHeight?: number | undefined;
            totalSat?: string | undefined;
            stakingTx?: Uint8Array | undefined;
            stakingOutputIdx?: number | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSig?: Uint8Array | undefined;
            covenantSigs?: {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] | undefined;
            unbondingTime?: number | undefined;
            btcUndelegation?: {
                unbondingTx?: Uint8Array | undefined;
                slashingTx?: Uint8Array | undefined;
                delegatorSlashingSig?: Uint8Array | undefined;
                covenantSlashingSigs?: {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[] | undefined;
                covenantUnbondingSigList?: {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[] | undefined;
                delegatorUnbondingInfo?: {
                    spendStakeTx?: Uint8Array | undefined;
                } | undefined;
            } | undefined;
            paramsVersion?: number | undefined;
            btcTipHeight?: number | undefined;
        }[] & ({
            stakerAddr?: string | undefined;
            btcPk?: Uint8Array | undefined;
            pop?: {
                btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
                btcSig?: Uint8Array | undefined;
            } | undefined;
            fpBtcPkList?: Uint8Array[] | undefined;
            stakingTime?: number | undefined;
            startHeight?: number | undefined;
            endHeight?: number | undefined;
            totalSat?: string | undefined;
            stakingTx?: Uint8Array | undefined;
            stakingOutputIdx?: number | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSig?: Uint8Array | undefined;
            covenantSigs?: {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] | undefined;
            unbondingTime?: number | undefined;
            btcUndelegation?: {
                unbondingTx?: Uint8Array | undefined;
                slashingTx?: Uint8Array | undefined;
                delegatorSlashingSig?: Uint8Array | undefined;
                covenantSlashingSigs?: {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[] | undefined;
                covenantUnbondingSigList?: {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[] | undefined;
                delegatorUnbondingInfo?: {
                    spendStakeTx?: Uint8Array | undefined;
                } | undefined;
            } | undefined;
            paramsVersion?: number | undefined;
            btcTipHeight?: number | undefined;
        } & {
            stakerAddr?: string | undefined;
            btcPk?: Uint8Array | undefined;
            pop?: ({
                btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
                btcSig?: Uint8Array | undefined;
            } & {
                btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
                btcSig?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["dels"][number]["pop"], keyof ProofOfPossessionBTC>, never>) | undefined;
            fpBtcPkList?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["dels"][number]["fpBtcPkList"], keyof Uint8Array[]>, never>) | undefined;
            stakingTime?: number | undefined;
            startHeight?: number | undefined;
            endHeight?: number | undefined;
            totalSat?: string | undefined;
            stakingTx?: Uint8Array | undefined;
            stakingOutputIdx?: number | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSig?: Uint8Array | undefined;
            covenantSigs?: ({
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] & ({
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            } & {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["dels"][number]["covenantSigs"][number]["adaptorSigs"], keyof Uint8Array[]>, never>) | undefined;
            } & Record<Exclude<keyof I["dels"][number]["covenantSigs"][number], keyof CovenantAdaptorSignatures>, never>)[] & Record<Exclude<keyof I["dels"][number]["covenantSigs"], keyof {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[]>, never>) | undefined;
            unbondingTime?: number | undefined;
            btcUndelegation?: ({
                unbondingTx?: Uint8Array | undefined;
                slashingTx?: Uint8Array | undefined;
                delegatorSlashingSig?: Uint8Array | undefined;
                covenantSlashingSigs?: {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[] | undefined;
                covenantUnbondingSigList?: {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[] | undefined;
                delegatorUnbondingInfo?: {
                    spendStakeTx?: Uint8Array | undefined;
                } | undefined;
            } & {
                unbondingTx?: Uint8Array | undefined;
                slashingTx?: Uint8Array | undefined;
                delegatorSlashingSig?: Uint8Array | undefined;
                covenantSlashingSigs?: ({
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[] & ({
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                } & {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["dels"][number]["btcUndelegation"]["covenantSlashingSigs"][number]["adaptorSigs"], keyof Uint8Array[]>, never>) | undefined;
                } & Record<Exclude<keyof I["dels"][number]["btcUndelegation"]["covenantSlashingSigs"][number], keyof CovenantAdaptorSignatures>, never>)[] & Record<Exclude<keyof I["dels"][number]["btcUndelegation"]["covenantSlashingSigs"], keyof {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[]>, never>) | undefined;
                covenantUnbondingSigList?: ({
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[] & ({
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                } & {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                } & Record<Exclude<keyof I["dels"][number]["btcUndelegation"]["covenantUnbondingSigList"][number], keyof SignatureInfo>, never>)[] & Record<Exclude<keyof I["dels"][number]["btcUndelegation"]["covenantUnbondingSigList"], keyof {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[]>, never>) | undefined;
                delegatorUnbondingInfo?: ({
                    spendStakeTx?: Uint8Array | undefined;
                } & {
                    spendStakeTx?: Uint8Array | undefined;
                } & Record<Exclude<keyof I["dels"][number]["btcUndelegation"]["delegatorUnbondingInfo"], "spendStakeTx">, never>) | undefined;
            } & Record<Exclude<keyof I["dels"][number]["btcUndelegation"], keyof BTCUndelegation>, never>) | undefined;
            paramsVersion?: number | undefined;
            btcTipHeight?: number | undefined;
        } & Record<Exclude<keyof I["dels"][number], keyof BTCDelegation>, never>)[] & Record<Exclude<keyof I["dels"], keyof {
            stakerAddr?: string | undefined;
            btcPk?: Uint8Array | undefined;
            pop?: {
                btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
                btcSig?: Uint8Array | undefined;
            } | undefined;
            fpBtcPkList?: Uint8Array[] | undefined;
            stakingTime?: number | undefined;
            startHeight?: number | undefined;
            endHeight?: number | undefined;
            totalSat?: string | undefined;
            stakingTx?: Uint8Array | undefined;
            stakingOutputIdx?: number | undefined;
            slashingTx?: Uint8Array | undefined;
            delegatorSig?: Uint8Array | undefined;
            covenantSigs?: {
                covPk?: Uint8Array | undefined;
                adaptorSigs?: Uint8Array[] | undefined;
            }[] | undefined;
            unbondingTime?: number | undefined;
            btcUndelegation?: {
                unbondingTx?: Uint8Array | undefined;
                slashingTx?: Uint8Array | undefined;
                delegatorSlashingSig?: Uint8Array | undefined;
                covenantSlashingSigs?: {
                    covPk?: Uint8Array | undefined;
                    adaptorSigs?: Uint8Array[] | undefined;
                }[] | undefined;
                covenantUnbondingSigList?: {
                    pk?: Uint8Array | undefined;
                    sig?: Uint8Array | undefined;
                }[] | undefined;
                delegatorUnbondingInfo?: {
                    spendStakeTx?: Uint8Array | undefined;
                } | undefined;
            } | undefined;
            paramsVersion?: number | undefined;
            btcTipHeight?: number | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, "dels">, never>>(object: I): BTCDelegatorDelegations;
};
export declare const BTCDelegatorDelegationIndex: {
    encode(message: BTCDelegatorDelegationIndex, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BTCDelegatorDelegationIndex;
    fromJSON(object: any): BTCDelegatorDelegationIndex;
    toJSON(message: BTCDelegatorDelegationIndex): unknown;
    fromPartial<I extends {
        stakingTxHashList?: Uint8Array[] | undefined;
    } & {
        stakingTxHashList?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["stakingTxHashList"], keyof Uint8Array[]>, never>) | undefined;
    } & Record<Exclude<keyof I, "stakingTxHashList">, never>>(object: I): BTCDelegatorDelegationIndex;
};
export declare const SignatureInfo: {
    encode(message: SignatureInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SignatureInfo;
    fromJSON(object: any): SignatureInfo;
    toJSON(message: SignatureInfo): unknown;
    fromPartial<I extends {
        pk?: Uint8Array | undefined;
        sig?: Uint8Array | undefined;
    } & {
        pk?: Uint8Array | undefined;
        sig?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof SignatureInfo>, never>>(object: I): SignatureInfo;
};
export declare const CovenantAdaptorSignatures: {
    encode(message: CovenantAdaptorSignatures, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CovenantAdaptorSignatures;
    fromJSON(object: any): CovenantAdaptorSignatures;
    toJSON(message: CovenantAdaptorSignatures): unknown;
    fromPartial<I extends {
        covPk?: Uint8Array | undefined;
        adaptorSigs?: Uint8Array[] | undefined;
    } & {
        covPk?: Uint8Array | undefined;
        adaptorSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["adaptorSigs"], keyof Uint8Array[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof CovenantAdaptorSignatures>, never>>(object: I): CovenantAdaptorSignatures;
};
export declare const SelectiveSlashingEvidence: {
    encode(message: SelectiveSlashingEvidence, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SelectiveSlashingEvidence;
    fromJSON(object: any): SelectiveSlashingEvidence;
    toJSON(message: SelectiveSlashingEvidence): unknown;
    fromPartial<I extends {
        stakingTxHash?: string | undefined;
        fpBtcPk?: Uint8Array | undefined;
        recoveredFpBtcSk?: Uint8Array | undefined;
    } & {
        stakingTxHash?: string | undefined;
        fpBtcPk?: Uint8Array | undefined;
        recoveredFpBtcSk?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof SelectiveSlashingEvidence>, never>>(object: I): SelectiveSlashingEvidence;
};
export declare const InclusionProof: {
    encode(message: InclusionProof, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InclusionProof;
    fromJSON(object: any): InclusionProof;
    toJSON(message: InclusionProof): unknown;
    fromPartial<I extends {
        key?: {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } | undefined;
        proof?: Uint8Array | undefined;
    } & {
        key?: ({
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } & {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["key"], keyof TransactionKey>, never>) | undefined;
        proof?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof InclusionProof>, never>>(object: I): InclusionProof;
};
export declare const LargestBtcReOrg: {
    encode(message: LargestBtcReOrg, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LargestBtcReOrg;
    fromJSON(object: any): LargestBtcReOrg;
    toJSON(message: LargestBtcReOrg): unknown;
    fromPartial<I extends {
        blockDiff?: number | undefined;
        rollbackFrom?: {
            header?: Uint8Array | undefined;
            hash?: Uint8Array | undefined;
            height?: number | undefined;
            work?: Uint8Array | undefined;
        } | undefined;
        rollbackTo?: {
            header?: Uint8Array | undefined;
            hash?: Uint8Array | undefined;
            height?: number | undefined;
            work?: Uint8Array | undefined;
        } | undefined;
    } & {
        blockDiff?: number | undefined;
        rollbackFrom?: ({
            header?: Uint8Array | undefined;
            hash?: Uint8Array | undefined;
            height?: number | undefined;
            work?: Uint8Array | undefined;
        } & {
            header?: Uint8Array | undefined;
            hash?: Uint8Array | undefined;
            height?: number | undefined;
            work?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["rollbackFrom"], keyof BTCHeaderInfo>, never>) | undefined;
        rollbackTo?: ({
            header?: Uint8Array | undefined;
            hash?: Uint8Array | undefined;
            height?: number | undefined;
            work?: Uint8Array | undefined;
        } & {
            header?: Uint8Array | undefined;
            hash?: Uint8Array | undefined;
            height?: number | undefined;
            work?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["rollbackTo"], keyof BTCHeaderInfo>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof LargestBtcReOrg>, never>>(object: I): LargestBtcReOrg;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
