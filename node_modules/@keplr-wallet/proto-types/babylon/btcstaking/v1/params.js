"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoredParams = exports.HeightToVersionMap = exports.HeightVersionPair = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "babylon.btcstaking.v1";
function createBaseParams() {
    return {
        covenantPks: [],
        covenantQuorum: 0,
        minStakingValueSat: "0",
        maxStakingValueSat: "0",
        minStakingTimeBlocks: 0,
        maxStakingTimeBlocks: 0,
        slashingPkScript: new Uint8Array(),
        minSlashingTxFeeSat: "0",
        slashingRate: "",
        unbondingTimeBlocks: 0,
        unbondingFeeSat: "0",
        minCommissionRate: "",
        delegationCreationBaseGasFee: "0",
        allowListExpirationHeight: "0",
        btcActivationHeight: 0,
    };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.covenantPks) {
            writer.uint32(10).bytes(v);
        }
        if (message.covenantQuorum !== 0) {
            writer.uint32(16).uint32(message.covenantQuorum);
        }
        if (message.minStakingValueSat !== "0") {
            writer.uint32(24).int64(message.minStakingValueSat);
        }
        if (message.maxStakingValueSat !== "0") {
            writer.uint32(32).int64(message.maxStakingValueSat);
        }
        if (message.minStakingTimeBlocks !== 0) {
            writer.uint32(40).uint32(message.minStakingTimeBlocks);
        }
        if (message.maxStakingTimeBlocks !== 0) {
            writer.uint32(48).uint32(message.maxStakingTimeBlocks);
        }
        if (message.slashingPkScript.length !== 0) {
            writer.uint32(58).bytes(message.slashingPkScript);
        }
        if (message.minSlashingTxFeeSat !== "0") {
            writer.uint32(64).int64(message.minSlashingTxFeeSat);
        }
        if (message.slashingRate !== "") {
            writer.uint32(74).string(message.slashingRate);
        }
        if (message.unbondingTimeBlocks !== 0) {
            writer.uint32(80).uint32(message.unbondingTimeBlocks);
        }
        if (message.unbondingFeeSat !== "0") {
            writer.uint32(88).int64(message.unbondingFeeSat);
        }
        if (message.minCommissionRate !== "") {
            writer.uint32(98).string(message.minCommissionRate);
        }
        if (message.delegationCreationBaseGasFee !== "0") {
            writer.uint32(104).uint64(message.delegationCreationBaseGasFee);
        }
        if (message.allowListExpirationHeight !== "0") {
            writer.uint32(112).uint64(message.allowListExpirationHeight);
        }
        if (message.btcActivationHeight !== 0) {
            writer.uint32(120).uint32(message.btcActivationHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.covenantPks.push(reader.bytes());
                    break;
                case 2:
                    message.covenantQuorum = reader.uint32();
                    break;
                case 3:
                    message.minStakingValueSat = longToString(reader.int64());
                    break;
                case 4:
                    message.maxStakingValueSat = longToString(reader.int64());
                    break;
                case 5:
                    message.minStakingTimeBlocks = reader.uint32();
                    break;
                case 6:
                    message.maxStakingTimeBlocks = reader.uint32();
                    break;
                case 7:
                    message.slashingPkScript = reader.bytes();
                    break;
                case 8:
                    message.minSlashingTxFeeSat = longToString(reader.int64());
                    break;
                case 9:
                    message.slashingRate = reader.string();
                    break;
                case 10:
                    message.unbondingTimeBlocks = reader.uint32();
                    break;
                case 11:
                    message.unbondingFeeSat = longToString(reader.int64());
                    break;
                case 12:
                    message.minCommissionRate = reader.string();
                    break;
                case 13:
                    message.delegationCreationBaseGasFee = longToString(reader.uint64());
                    break;
                case 14:
                    message.allowListExpirationHeight = longToString(reader.uint64());
                    break;
                case 15:
                    message.btcActivationHeight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            covenantPks: Array.isArray(object === null || object === void 0 ? void 0 : object.covenantPks)
                ? object.covenantPks.map((e) => bytesFromBase64(e))
                : [],
            covenantQuorum: isSet(object.covenantQuorum)
                ? Number(object.covenantQuorum)
                : 0,
            minStakingValueSat: isSet(object.minStakingValueSat)
                ? String(object.minStakingValueSat)
                : "0",
            maxStakingValueSat: isSet(object.maxStakingValueSat)
                ? String(object.maxStakingValueSat)
                : "0",
            minStakingTimeBlocks: isSet(object.minStakingTimeBlocks)
                ? Number(object.minStakingTimeBlocks)
                : 0,
            maxStakingTimeBlocks: isSet(object.maxStakingTimeBlocks)
                ? Number(object.maxStakingTimeBlocks)
                : 0,
            slashingPkScript: isSet(object.slashingPkScript)
                ? bytesFromBase64(object.slashingPkScript)
                : new Uint8Array(),
            minSlashingTxFeeSat: isSet(object.minSlashingTxFeeSat)
                ? String(object.minSlashingTxFeeSat)
                : "0",
            slashingRate: isSet(object.slashingRate)
                ? String(object.slashingRate)
                : "",
            unbondingTimeBlocks: isSet(object.unbondingTimeBlocks)
                ? Number(object.unbondingTimeBlocks)
                : 0,
            unbondingFeeSat: isSet(object.unbondingFeeSat)
                ? String(object.unbondingFeeSat)
                : "0",
            minCommissionRate: isSet(object.minCommissionRate)
                ? String(object.minCommissionRate)
                : "",
            delegationCreationBaseGasFee: isSet(object.delegationCreationBaseGasFee)
                ? String(object.delegationCreationBaseGasFee)
                : "0",
            allowListExpirationHeight: isSet(object.allowListExpirationHeight)
                ? String(object.allowListExpirationHeight)
                : "0",
            btcActivationHeight: isSet(object.btcActivationHeight)
                ? Number(object.btcActivationHeight)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.covenantPks) {
            obj.covenantPks = message.covenantPks.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.covenantPks = [];
        }
        message.covenantQuorum !== undefined &&
            (obj.covenantQuorum = Math.round(message.covenantQuorum));
        message.minStakingValueSat !== undefined &&
            (obj.minStakingValueSat = message.minStakingValueSat);
        message.maxStakingValueSat !== undefined &&
            (obj.maxStakingValueSat = message.maxStakingValueSat);
        message.minStakingTimeBlocks !== undefined &&
            (obj.minStakingTimeBlocks = Math.round(message.minStakingTimeBlocks));
        message.maxStakingTimeBlocks !== undefined &&
            (obj.maxStakingTimeBlocks = Math.round(message.maxStakingTimeBlocks));
        message.slashingPkScript !== undefined &&
            (obj.slashingPkScript = base64FromBytes(message.slashingPkScript !== undefined
                ? message.slashingPkScript
                : new Uint8Array()));
        message.minSlashingTxFeeSat !== undefined &&
            (obj.minSlashingTxFeeSat = message.minSlashingTxFeeSat);
        message.slashingRate !== undefined &&
            (obj.slashingRate = message.slashingRate);
        message.unbondingTimeBlocks !== undefined &&
            (obj.unbondingTimeBlocks = Math.round(message.unbondingTimeBlocks));
        message.unbondingFeeSat !== undefined &&
            (obj.unbondingFeeSat = message.unbondingFeeSat);
        message.minCommissionRate !== undefined &&
            (obj.minCommissionRate = message.minCommissionRate);
        message.delegationCreationBaseGasFee !== undefined &&
            (obj.delegationCreationBaseGasFee = message.delegationCreationBaseGasFee);
        message.allowListExpirationHeight !== undefined &&
            (obj.allowListExpirationHeight = message.allowListExpirationHeight);
        message.btcActivationHeight !== undefined &&
            (obj.btcActivationHeight = Math.round(message.btcActivationHeight));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const message = createBaseParams();
        message.covenantPks = ((_a = object.covenantPks) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.covenantQuorum = (_b = object.covenantQuorum) !== null && _b !== void 0 ? _b : 0;
        message.minStakingValueSat = (_c = object.minStakingValueSat) !== null && _c !== void 0 ? _c : "0";
        message.maxStakingValueSat = (_d = object.maxStakingValueSat) !== null && _d !== void 0 ? _d : "0";
        message.minStakingTimeBlocks = (_e = object.minStakingTimeBlocks) !== null && _e !== void 0 ? _e : 0;
        message.maxStakingTimeBlocks = (_f = object.maxStakingTimeBlocks) !== null && _f !== void 0 ? _f : 0;
        message.slashingPkScript = (_g = object.slashingPkScript) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.minSlashingTxFeeSat = (_h = object.minSlashingTxFeeSat) !== null && _h !== void 0 ? _h : "0";
        message.slashingRate = (_j = object.slashingRate) !== null && _j !== void 0 ? _j : "";
        message.unbondingTimeBlocks = (_k = object.unbondingTimeBlocks) !== null && _k !== void 0 ? _k : 0;
        message.unbondingFeeSat = (_l = object.unbondingFeeSat) !== null && _l !== void 0 ? _l : "0";
        message.minCommissionRate = (_m = object.minCommissionRate) !== null && _m !== void 0 ? _m : "";
        message.delegationCreationBaseGasFee =
            (_o = object.delegationCreationBaseGasFee) !== null && _o !== void 0 ? _o : "0";
        message.allowListExpirationHeight = (_p = object.allowListExpirationHeight) !== null && _p !== void 0 ? _p : "0";
        message.btcActivationHeight = (_q = object.btcActivationHeight) !== null && _q !== void 0 ? _q : 0;
        return message;
    },
};
function createBaseHeightVersionPair() {
    return { startHeight: "0", version: 0 };
}
exports.HeightVersionPair = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.startHeight !== "0") {
            writer.uint32(8).uint64(message.startHeight);
        }
        if (message.version !== 0) {
            writer.uint32(16).uint32(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeightVersionPair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.startHeight = longToString(reader.uint64());
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            startHeight: isSet(object.startHeight) ? String(object.startHeight) : "0",
            version: isSet(object.version) ? Number(object.version) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.startHeight !== undefined &&
            (obj.startHeight = message.startHeight);
        message.version !== undefined &&
            (obj.version = Math.round(message.version));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseHeightVersionPair();
        message.startHeight = (_a = object.startHeight) !== null && _a !== void 0 ? _a : "0";
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseHeightToVersionMap() {
    return { pairs: [] };
}
exports.HeightToVersionMap = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pairs) {
            exports.HeightVersionPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeightToVersionMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pairs.push(exports.HeightVersionPair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pairs: Array.isArray(object === null || object === void 0 ? void 0 : object.pairs)
                ? object.pairs.map((e) => exports.HeightVersionPair.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pairs) {
            obj.pairs = message.pairs.map((e) => e ? exports.HeightVersionPair.toJSON(e) : undefined);
        }
        else {
            obj.pairs = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseHeightToVersionMap();
        message.pairs =
            ((_a = object.pairs) === null || _a === void 0 ? void 0 : _a.map((e) => exports.HeightVersionPair.fromPartial(e))) || [];
        return message;
    },
};
function createBaseStoredParams() {
    return { version: 0, params: undefined };
}
exports.StoredParams = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== 0) {
            writer.uint32(8).uint32(message.version);
        }
        if (message.params !== undefined) {
            exports.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStoredParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.params = exports.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            version: isSet(object.version) ? Number(object.version) : 0,
            params: isSet(object.params) ? exports.Params.fromJSON(object.params) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.version !== undefined &&
            (obj.version = Math.round(message.version));
        message.params !== undefined &&
            (obj.params = message.params ? exports.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStoredParams();
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : 0;
        message.params =
            object.params !== undefined && object.params !== null
                ? exports.Params.fromPartial(object.params)
                : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=params.js.map