import _m0 from "protobufjs/minimal";
import { Description } from "../../../cosmos/staking/v1beta1/staking";
import { ProofOfPossessionBTC } from "../../../babylon/btcstaking/v1/pop";
import { InclusionProof } from "../../../babylon/btcstaking/v1/btcstaking";
import { Params } from "../../../babylon/btcstaking/v1/params";
export declare const protobufPackage = "babylon.btcstaking.v1";
/** MsgCreateFinalityProvider is the message for creating a finality provider */
export interface MsgCreateFinalityProvider {
    /**
     * addr defines the address of the finality provider that will receive
     * the commissions to all the delegations.
     */
    addr: string;
    /** description defines the description terms for the finality provider */
    description: Description | undefined;
    /**
     * btc_pk is the Bitcoin secp256k1 PK of this finality provider
     * the PK follows encoding in BIP-340 spec
     */
    btcPk: Uint8Array;
    /** pop is the proof of possession of btc_pk over the FP signer address. */
    pop: ProofOfPossessionBTC | undefined;
    /** commission is the finality provider commission information */
    commission: CommissionRates | undefined;
}
/**
 * MsgCreateFinalityProviderResponse is the response for
 * MsgCreateFinalityProvider
 */
export interface MsgCreateFinalityProviderResponse {
}
/**
 * CommissionRates defines the initial commission rates to be used for creating
 * a finality provider.
 */
export interface CommissionRates {
    /** rate is the commission rate charged to delegators, as a fraction. */
    rate: string;
    /**
     * max_rate defines the maximum commission rate which finality provider can
     * ever charge, as a fraction.
     */
    maxRate: string;
    /**
     * max_change_rate defines the maximum daily increase of the finality provider
     * commission, as a fraction.
     */
    maxChangeRate: string;
}
/**
 * MsgEditFinalityProvider is the message for editing an existing finality
 * provider
 */
export interface MsgEditFinalityProvider {
    /**
     * addr the address of the finality provider that whishes to edit his
     * information.
     */
    addr: string;
    /** btc_pk is the Bitcoin secp256k1 PK of the finality provider to be edited */
    btcPk: Uint8Array;
    /** description defines the updated description terms for the finality provider */
    description: Description | undefined;
    /** commission defines the updated commission rate of the finality provider */
    commission: string;
}
/** MsgEditFinalityProviderResponse is the response for MsgEditFinalityProvider */
export interface MsgEditFinalityProviderResponse {
}
/** MsgCreateBTCDelegation is the message for creating a BTC delegation */
export interface MsgCreateBTCDelegation {
    /** staker_addr is the address to receive rewards from BTC delegation. */
    stakerAddr: string;
    /** pop is the proof of possession of btc_pk by the staker_addr. */
    pop: ProofOfPossessionBTC | undefined;
    /** btc_pk is the Bitcoin secp256k1 PK of the BTC delegator */
    btcPk: Uint8Array;
    /**
     * fp_btc_pk_list is the list of Bitcoin secp256k1 PKs of the finality
     * providers, if there is more than one finality provider pk it means that
     * delegation is re-staked
     */
    fpBtcPkList: Uint8Array[];
    /** staking_time is the time lock used in staking transaction */
    stakingTime: number;
    /** staking_value  is the amount of satoshis locked in staking output */
    stakingValue: string;
    /**
     * staking_tx is a bitcoin staking transaction i.e transaction that locks
     * funds
     */
    stakingTx: Uint8Array;
    /**
     * staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC
     * chain
     */
    stakingTxInclusionProof: InclusionProof | undefined;
    /**
     * slashing_tx is the slashing tx
     * Note that the tx itself does not contain signatures, which are off-chain.
     */
    slashingTx: Uint8Array;
    /**
     * delegator_slashing_sig is the signature on the slashing tx by the delegator
     * (i.e., SK corresponding to btc_pk). It will be a part of the witness for
     * the staking tx output. The staking tx output further needs signatures from
     * covenant and finality provider in order to be spendable.
     */
    delegatorSlashingSig: Uint8Array;
    /**
     * unbonding_time is the time lock used when funds are being unbonded. It is
     * be used in:
     * - unbonding transaction, time lock spending path
     * - staking slashing transaction, change output
     * - unbonding slashing transaction, change output
     * It must be smaller than math.MaxUInt16 and larger that
     * max(MinUnbondingTime, CheckpointFinalizationTimeout)
     */
    unbondingTime: number;
    /**
     * fields related to unbonding transaction
     * unbonding_tx is a bitcoin unbonding transaction i.e transaction that spends
     * staking output and sends it to the unbonding output
     */
    unbondingTx: Uint8Array;
    /**
     * unbonding_value is amount of satoshis locked in unbonding output.
     * NOTE: staking_value and unbonding_value could be different because of the
     * difference between the fee for staking tx and that for unbonding
     */
    unbondingValue: string;
    /**
     * unbonding_slashing_tx is the slashing tx which slash unbonding contract
     * Note that the tx itself does not contain signatures, which are off-chain.
     */
    unbondingSlashingTx: Uint8Array;
    /**
     * delegator_unbonding_slashing_sig is the signature on the slashing tx by the
     * delegator (i.e., SK corresponding to btc_pk).
     */
    delegatorUnbondingSlashingSig: Uint8Array;
}
/** MsgCreateBTCDelegationResponse is the response for MsgCreateBTCDelegation */
export interface MsgCreateBTCDelegationResponse {
}
/**
 * MsgAddBTCDelegationInclusionProof is the message for adding proof of
 * inclusion of BTC delegation on BTC chain
 */
export interface MsgAddBTCDelegationInclusionProof {
    signer: string;
    /**
     * staking_tx_hash is the hash of the staking tx.
     * It uniquely identifies a BTC delegation
     */
    stakingTxHash: string;
    /**
     * staking_tx_inclusion_proof is the inclusion proof of the staking tx in BTC
     * chain
     */
    stakingTxInclusionProof: InclusionProof | undefined;
}
/**
 * MsgAddBTCDelegationInclusionProofResponse is the response for
 * MsgAddBTCDelegationInclusionProof
 */
export interface MsgAddBTCDelegationInclusionProofResponse {
}
/**
 * MsgAddCovenantSigs is the message for handling signatures from a covenant
 * member
 */
export interface MsgAddCovenantSigs {
    signer: string;
    /** pk is the BTC public key of the covenant member */
    pk: Uint8Array;
    /**
     * staking_tx_hash is the hash of the staking tx.
     * It uniquely identifies a BTC delegation
     */
    stakingTxHash: string;
    /**
     * sigs is a list of adaptor signatures of the covenant
     * the order of sigs should respect the order of finality providers
     * of the corresponding delegation
     */
    slashingTxSigs: Uint8Array[];
    /**
     * unbonding_tx_sig is the signature of the covenant on the unbonding tx
     * submitted to babylon the signature follows encoding in BIP-340 spec
     */
    unbondingTxSig: Uint8Array;
    /**
     * slashing_unbonding_tx_sigs is a list of adaptor signatures of the covenant
     * on slashing tx corresponding to unbonding tx submitted to babylon
     * the order of sigs should respect the order of finality providers
     * of the corresponding delegation
     */
    slashingUnbondingTxSigs: Uint8Array[];
}
/** MsgAddCovenantSigsResponse is the response for MsgAddCovenantSigs */
export interface MsgAddCovenantSigsResponse {
}
/**
 * MsgBTCUndelegate is the message for handling signature on unbonding tx
 * from its delegator. This signature effectively proves that the delegator
 * wants to unbond this BTC delegation
 */
export interface MsgBTCUndelegate {
    signer: string;
    /**
     * staking_tx_hash is the hash of the staking tx.
     * It uniquely identifies a BTC delegation
     */
    stakingTxHash: string;
    /**
     * stake_spending_tx is a bitcoin transaction that spends the staking
     * transaction i.e it has staking output as an input
     */
    stakeSpendingTx: Uint8Array;
    /**
     * spend_spending_tx_inclusion_proof is the proof of inclusion of the
     * stake_spending_tx in the BTC chain
     */
    stakeSpendingTxInclusionProof: InclusionProof | undefined;
    /**
     * funding_transactions is a list of bitcoin transactions that funds the stake_spending_tx
     * i.e. they are inputs of the stake_spending_tx
     */
    fundingTransactions: Uint8Array[];
}
/** MsgBTCUndelegateResponse is the response for MsgBTCUndelegate */
export interface MsgBTCUndelegateResponse {
}
/**
 * MsgSelectiveSlashingEvidence is the message for handling evidence of
 * selective slashing launched by a finality provider
 */
export interface MsgSelectiveSlashingEvidence {
    signer: string;
    /**
     * staking_tx_hash is the hash of the staking tx.
     * It uniquely identifies a BTC delegation
     */
    stakingTxHash: string;
    /**
     * recovered_fp_btc_sk is the BTC SK of the finality provider who
     * launches the selective slashing offence. The SK is recovered by
     * using a covenant adaptor signature and the corresponding Schnorr
     * signature
     */
    recoveredFpBtcSk: Uint8Array;
}
/**
 * MsgSelectiveSlashingEvidenceResponse is the response for
 * MsgSelectiveSlashingEvidence
 */
export interface MsgSelectiveSlashingEvidenceResponse {
}
/** MsgUpdateParams defines a message for updating btcstaking module parameters. */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     * just FYI: cosmos.AddressString marks that this field should use type alias
     * for AddressString instead of string, but the functionality is not yet
     * implemented in cosmos-proto
     */
    authority: string;
    /**
     * params defines the finality parameters to update.
     *
     * NOTE: All parameters must be supplied.
     */
    params: Params | undefined;
}
/** MsgUpdateParamsResponse is the response to the MsgUpdateParams message. */
export interface MsgUpdateParamsResponse {
}
export declare const MsgCreateFinalityProvider: {
    encode(message: MsgCreateFinalityProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateFinalityProvider;
    fromJSON(object: any): MsgCreateFinalityProvider;
    toJSON(message: MsgCreateFinalityProvider): unknown;
    fromPartial<I extends {
        addr?: string | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
        btcPk?: Uint8Array | undefined;
        pop?: {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } | undefined;
        commission?: {
            rate?: string | undefined;
            maxRate?: string | undefined;
            maxChangeRate?: string | undefined;
        } | undefined;
    } & {
        addr?: string | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
        btcPk?: Uint8Array | undefined;
        pop?: ({
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["pop"], keyof ProofOfPossessionBTC>, never>) | undefined;
        commission?: ({
            rate?: string | undefined;
            maxRate?: string | undefined;
            maxChangeRate?: string | undefined;
        } & {
            rate?: string | undefined;
            maxRate?: string | undefined;
            maxChangeRate?: string | undefined;
        } & Record<Exclude<keyof I["commission"], keyof CommissionRates>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgCreateFinalityProvider>, never>>(object: I): MsgCreateFinalityProvider;
};
export declare const MsgCreateFinalityProviderResponse: {
    encode(_: MsgCreateFinalityProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateFinalityProviderResponse;
    fromJSON(_: any): MsgCreateFinalityProviderResponse;
    toJSON(_: MsgCreateFinalityProviderResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCreateFinalityProviderResponse;
};
export declare const CommissionRates: {
    encode(message: CommissionRates, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CommissionRates;
    fromJSON(object: any): CommissionRates;
    toJSON(message: CommissionRates): unknown;
    fromPartial<I extends {
        rate?: string | undefined;
        maxRate?: string | undefined;
        maxChangeRate?: string | undefined;
    } & {
        rate?: string | undefined;
        maxRate?: string | undefined;
        maxChangeRate?: string | undefined;
    } & Record<Exclude<keyof I, keyof CommissionRates>, never>>(object: I): CommissionRates;
};
export declare const MsgEditFinalityProvider: {
    encode(message: MsgEditFinalityProvider, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditFinalityProvider;
    fromJSON(object: any): MsgEditFinalityProvider;
    toJSON(message: MsgEditFinalityProvider): unknown;
    fromPartial<I extends {
        addr?: string | undefined;
        btcPk?: Uint8Array | undefined;
        description?: {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } | undefined;
        commission?: string | undefined;
    } & {
        addr?: string | undefined;
        btcPk?: Uint8Array | undefined;
        description?: ({
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & {
            moniker?: string | undefined;
            identity?: string | undefined;
            website?: string | undefined;
            securityContact?: string | undefined;
            details?: string | undefined;
        } & Record<Exclude<keyof I["description"], keyof Description>, never>) | undefined;
        commission?: string | undefined;
    } & Record<Exclude<keyof I, keyof MsgEditFinalityProvider>, never>>(object: I): MsgEditFinalityProvider;
};
export declare const MsgEditFinalityProviderResponse: {
    encode(_: MsgEditFinalityProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgEditFinalityProviderResponse;
    fromJSON(_: any): MsgEditFinalityProviderResponse;
    toJSON(_: MsgEditFinalityProviderResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgEditFinalityProviderResponse;
};
export declare const MsgCreateBTCDelegation: {
    encode(message: MsgCreateBTCDelegation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBTCDelegation;
    fromJSON(object: any): MsgCreateBTCDelegation;
    toJSON(message: MsgCreateBTCDelegation): unknown;
    fromPartial<I extends {
        stakerAddr?: string | undefined;
        pop?: {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } | undefined;
        btcPk?: Uint8Array | undefined;
        fpBtcPkList?: Uint8Array[] | undefined;
        stakingTime?: number | undefined;
        stakingValue?: string | undefined;
        stakingTx?: Uint8Array | undefined;
        stakingTxInclusionProof?: {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            proof?: Uint8Array | undefined;
        } | undefined;
        slashingTx?: Uint8Array | undefined;
        delegatorSlashingSig?: Uint8Array | undefined;
        unbondingTime?: number | undefined;
        unbondingTx?: Uint8Array | undefined;
        unbondingValue?: string | undefined;
        unbondingSlashingTx?: Uint8Array | undefined;
        delegatorUnbondingSlashingSig?: Uint8Array | undefined;
    } & {
        stakerAddr?: string | undefined;
        pop?: ({
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & {
            btcSigType?: import("../../../babylon/btcstaking/v1/pop").BTCSigType | undefined;
            btcSig?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["pop"], keyof ProofOfPossessionBTC>, never>) | undefined;
        btcPk?: Uint8Array | undefined;
        fpBtcPkList?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["fpBtcPkList"], keyof Uint8Array[]>, never>) | undefined;
        stakingTime?: number | undefined;
        stakingValue?: string | undefined;
        stakingTx?: Uint8Array | undefined;
        stakingTxInclusionProof?: ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            proof?: Uint8Array | undefined;
        } & {
            key?: ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["stakingTxInclusionProof"]["key"], keyof import("../../btccheckpoint/v1/btccheckpoint").TransactionKey>, never>) | undefined;
            proof?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["stakingTxInclusionProof"], keyof InclusionProof>, never>) | undefined;
        slashingTx?: Uint8Array | undefined;
        delegatorSlashingSig?: Uint8Array | undefined;
        unbondingTime?: number | undefined;
        unbondingTx?: Uint8Array | undefined;
        unbondingValue?: string | undefined;
        unbondingSlashingTx?: Uint8Array | undefined;
        delegatorUnbondingSlashingSig?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof MsgCreateBTCDelegation>, never>>(object: I): MsgCreateBTCDelegation;
};
export declare const MsgCreateBTCDelegationResponse: {
    encode(_: MsgCreateBTCDelegationResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBTCDelegationResponse;
    fromJSON(_: any): MsgCreateBTCDelegationResponse;
    toJSON(_: MsgCreateBTCDelegationResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCreateBTCDelegationResponse;
};
export declare const MsgAddBTCDelegationInclusionProof: {
    encode(message: MsgAddBTCDelegationInclusionProof, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddBTCDelegationInclusionProof;
    fromJSON(object: any): MsgAddBTCDelegationInclusionProof;
    toJSON(message: MsgAddBTCDelegationInclusionProof): unknown;
    fromPartial<I extends {
        signer?: string | undefined;
        stakingTxHash?: string | undefined;
        stakingTxInclusionProof?: {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            proof?: Uint8Array | undefined;
        } | undefined;
    } & {
        signer?: string | undefined;
        stakingTxHash?: string | undefined;
        stakingTxInclusionProof?: ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            proof?: Uint8Array | undefined;
        } & {
            key?: ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["stakingTxInclusionProof"]["key"], keyof import("../../btccheckpoint/v1/btccheckpoint").TransactionKey>, never>) | undefined;
            proof?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["stakingTxInclusionProof"], keyof InclusionProof>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgAddBTCDelegationInclusionProof>, never>>(object: I): MsgAddBTCDelegationInclusionProof;
};
export declare const MsgAddBTCDelegationInclusionProofResponse: {
    encode(_: MsgAddBTCDelegationInclusionProofResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddBTCDelegationInclusionProofResponse;
    fromJSON(_: any): MsgAddBTCDelegationInclusionProofResponse;
    toJSON(_: MsgAddBTCDelegationInclusionProofResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgAddBTCDelegationInclusionProofResponse;
};
export declare const MsgAddCovenantSigs: {
    encode(message: MsgAddCovenantSigs, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddCovenantSigs;
    fromJSON(object: any): MsgAddCovenantSigs;
    toJSON(message: MsgAddCovenantSigs): unknown;
    fromPartial<I extends {
        signer?: string | undefined;
        pk?: Uint8Array | undefined;
        stakingTxHash?: string | undefined;
        slashingTxSigs?: Uint8Array[] | undefined;
        unbondingTxSig?: Uint8Array | undefined;
        slashingUnbondingTxSigs?: Uint8Array[] | undefined;
    } & {
        signer?: string | undefined;
        pk?: Uint8Array | undefined;
        stakingTxHash?: string | undefined;
        slashingTxSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["slashingTxSigs"], keyof Uint8Array[]>, never>) | undefined;
        unbondingTxSig?: Uint8Array | undefined;
        slashingUnbondingTxSigs?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["slashingUnbondingTxSigs"], keyof Uint8Array[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgAddCovenantSigs>, never>>(object: I): MsgAddCovenantSigs;
};
export declare const MsgAddCovenantSigsResponse: {
    encode(_: MsgAddCovenantSigsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddCovenantSigsResponse;
    fromJSON(_: any): MsgAddCovenantSigsResponse;
    toJSON(_: MsgAddCovenantSigsResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgAddCovenantSigsResponse;
};
export declare const MsgBTCUndelegate: {
    encode(message: MsgBTCUndelegate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgBTCUndelegate;
    fromJSON(object: any): MsgBTCUndelegate;
    toJSON(message: MsgBTCUndelegate): unknown;
    fromPartial<I extends {
        signer?: string | undefined;
        stakingTxHash?: string | undefined;
        stakeSpendingTx?: Uint8Array | undefined;
        stakeSpendingTxInclusionProof?: {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            proof?: Uint8Array | undefined;
        } | undefined;
        fundingTransactions?: Uint8Array[] | undefined;
    } & {
        signer?: string | undefined;
        stakingTxHash?: string | undefined;
        stakeSpendingTx?: Uint8Array | undefined;
        stakeSpendingTxInclusionProof?: ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            proof?: Uint8Array | undefined;
        } & {
            key?: ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["stakeSpendingTxInclusionProof"]["key"], keyof import("../../btccheckpoint/v1/btccheckpoint").TransactionKey>, never>) | undefined;
            proof?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["stakeSpendingTxInclusionProof"], keyof InclusionProof>, never>) | undefined;
        fundingTransactions?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["fundingTransactions"], keyof Uint8Array[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgBTCUndelegate>, never>>(object: I): MsgBTCUndelegate;
};
export declare const MsgBTCUndelegateResponse: {
    encode(_: MsgBTCUndelegateResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgBTCUndelegateResponse;
    fromJSON(_: any): MsgBTCUndelegateResponse;
    toJSON(_: MsgBTCUndelegateResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgBTCUndelegateResponse;
};
export declare const MsgSelectiveSlashingEvidence: {
    encode(message: MsgSelectiveSlashingEvidence, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSelectiveSlashingEvidence;
    fromJSON(object: any): MsgSelectiveSlashingEvidence;
    toJSON(message: MsgSelectiveSlashingEvidence): unknown;
    fromPartial<I extends {
        signer?: string | undefined;
        stakingTxHash?: string | undefined;
        recoveredFpBtcSk?: Uint8Array | undefined;
    } & {
        signer?: string | undefined;
        stakingTxHash?: string | undefined;
        recoveredFpBtcSk?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof MsgSelectiveSlashingEvidence>, never>>(object: I): MsgSelectiveSlashingEvidence;
};
export declare const MsgSelectiveSlashingEvidenceResponse: {
    encode(_: MsgSelectiveSlashingEvidenceResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSelectiveSlashingEvidenceResponse;
    fromJSON(_: any): MsgSelectiveSlashingEvidenceResponse;
    toJSON(_: MsgSelectiveSlashingEvidenceResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgSelectiveSlashingEvidenceResponse;
};
export declare const MsgUpdateParams: {
    encode(message: MsgUpdateParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams;
    fromJSON(object: any): MsgUpdateParams;
    toJSON(message: MsgUpdateParams): unknown;
    fromPartial<I extends {
        authority?: string | undefined;
        params?: {
            covenantPks?: Uint8Array[] | undefined;
            covenantQuorum?: number | undefined;
            minStakingValueSat?: string | undefined;
            maxStakingValueSat?: string | undefined;
            minStakingTimeBlocks?: number | undefined;
            maxStakingTimeBlocks?: number | undefined;
            slashingPkScript?: Uint8Array | undefined;
            minSlashingTxFeeSat?: string | undefined;
            slashingRate?: string | undefined;
            unbondingTimeBlocks?: number | undefined;
            unbondingFeeSat?: string | undefined;
            minCommissionRate?: string | undefined;
            delegationCreationBaseGasFee?: string | undefined;
            allowListExpirationHeight?: string | undefined;
            btcActivationHeight?: number | undefined;
        } | undefined;
    } & {
        authority?: string | undefined;
        params?: ({
            covenantPks?: Uint8Array[] | undefined;
            covenantQuorum?: number | undefined;
            minStakingValueSat?: string | undefined;
            maxStakingValueSat?: string | undefined;
            minStakingTimeBlocks?: number | undefined;
            maxStakingTimeBlocks?: number | undefined;
            slashingPkScript?: Uint8Array | undefined;
            minSlashingTxFeeSat?: string | undefined;
            slashingRate?: string | undefined;
            unbondingTimeBlocks?: number | undefined;
            unbondingFeeSat?: string | undefined;
            minCommissionRate?: string | undefined;
            delegationCreationBaseGasFee?: string | undefined;
            allowListExpirationHeight?: string | undefined;
            btcActivationHeight?: number | undefined;
        } & {
            covenantPks?: (Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["params"]["covenantPks"], keyof Uint8Array[]>, never>) | undefined;
            covenantQuorum?: number | undefined;
            minStakingValueSat?: string | undefined;
            maxStakingValueSat?: string | undefined;
            minStakingTimeBlocks?: number | undefined;
            maxStakingTimeBlocks?: number | undefined;
            slashingPkScript?: Uint8Array | undefined;
            minSlashingTxFeeSat?: string | undefined;
            slashingRate?: string | undefined;
            unbondingTimeBlocks?: number | undefined;
            unbondingFeeSat?: string | undefined;
            minCommissionRate?: string | undefined;
            delegationCreationBaseGasFee?: string | undefined;
            allowListExpirationHeight?: string | undefined;
            btcActivationHeight?: number | undefined;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof MsgUpdateParams>, never>>(object: I): MsgUpdateParams;
};
export declare const MsgUpdateParamsResponse: {
    encode(_: MsgUpdateParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse;
    fromJSON(_: any): MsgUpdateParamsResponse;
    toJSON(_: MsgUpdateParamsResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateParamsResponse;
};
/**
 * Msg defines the Msg service.
 * TODO: handle unbonding tx with full witness
 */
export interface Msg {
    /** CreateFinalityProvider creates a new finality provider */
    CreateFinalityProvider(request: MsgCreateFinalityProvider): Promise<MsgCreateFinalityProviderResponse>;
    /** EditFinalityProvider edits an existing finality provider */
    EditFinalityProvider(request: MsgEditFinalityProvider): Promise<MsgEditFinalityProviderResponse>;
    /** CreateBTCDelegation creates a new BTC delegation */
    CreateBTCDelegation(request: MsgCreateBTCDelegation): Promise<MsgCreateBTCDelegationResponse>;
    /**
     * AddBTCDelegationInclusionProof adds inclusion proof of a given delegation
     * on BTC chain
     */
    AddBTCDelegationInclusionProof(request: MsgAddBTCDelegationInclusionProof): Promise<MsgAddBTCDelegationInclusionProofResponse>;
    /** AddCovenantSigs handles signatures from a covenant member */
    AddCovenantSigs(request: MsgAddCovenantSigs): Promise<MsgAddCovenantSigsResponse>;
    /** BTCUndelegate handles a signature on unbonding tx from its delegator */
    BTCUndelegate(request: MsgBTCUndelegate): Promise<MsgBTCUndelegateResponse>;
    /**
     * SelectiveSlashingEvidence handles the evidence of selective slashing
     * launched by a finality provider
     */
    SelectiveSlashingEvidence(request: MsgSelectiveSlashingEvidence): Promise<MsgSelectiveSlashingEvidenceResponse>;
    /** UpdateParams updates the btcstaking module parameters. */
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
