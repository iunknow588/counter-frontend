import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "babylon.btcstaking.v1";
/** BTCSigType indicates the type of btc_sig in a pop */
export declare enum BTCSigType {
    /** BIP340 - BIP340 means the btc_sig will follow the BIP-340 encoding */
    BIP340 = 0,
    /** BIP322 - BIP322 means the btc_sig will follow the BIP-322 encoding */
    BIP322 = 1,
    /**
     * ECDSA - ECDSA means the btc_sig will follow the ECDSA encoding
     * ref: https://github.com/okx/js-wallet-sdk/blob/a57c2acbe6ce917c0aa4e951d96c4e562ad58444/packages/coin-bitcoin/src/BtcWallet.ts#L331
     */
    ECDSA = 2,
    UNRECOGNIZED = -1
}
export declare function bTCSigTypeFromJSON(object: any): BTCSigType;
export declare function bTCSigTypeToJSON(object: BTCSigType): string;
/**
 * ProofOfPossessionBTC is the proof of possession that a Babylon
 * address and a Bitcoin secp256k1 secret key are held by the same
 * person
 */
export interface ProofOfPossessionBTC {
    /** btc_sig_type indicates the type of btc_sig in the pop */
    btcSigType: BTCSigType;
    /**
     * btc_sig is the signature generated via sign(sk_btc, babylon_staker_address)
     * the signature follows encoding in either BIP-340 spec or BIP-322 spec
     */
    btcSig: Uint8Array;
}
/**
 * BIP322Sig is a BIP-322 signature together with the address corresponding to
 * the signer
 */
export interface BIP322Sig {
    /** address is the signer's address */
    address: string;
    /** sig is the actual signature in BIP-322 format */
    sig: Uint8Array;
}
export declare const ProofOfPossessionBTC: {
    encode(message: ProofOfPossessionBTC, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ProofOfPossessionBTC;
    fromJSON(object: any): ProofOfPossessionBTC;
    toJSON(message: ProofOfPossessionBTC): unknown;
    fromPartial<I extends {
        btcSigType?: BTCSigType | undefined;
        btcSig?: Uint8Array | undefined;
    } & {
        btcSigType?: BTCSigType | undefined;
        btcSig?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof ProofOfPossessionBTC>, never>>(object: I): ProofOfPossessionBTC;
};
export declare const BIP322Sig: {
    encode(message: BIP322Sig, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BIP322Sig;
    fromJSON(object: any): BIP322Sig;
    toJSON(message: BIP322Sig): unknown;
    fromPartial<I extends {
        address?: string | undefined;
        sig?: Uint8Array | undefined;
    } & {
        address?: string | undefined;
        sig?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof BIP322Sig>, never>>(object: I): BIP322Sig;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
