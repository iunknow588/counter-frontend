"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LargestBtcReOrg = exports.InclusionProof = exports.SelectiveSlashingEvidence = exports.CovenantAdaptorSignatures = exports.SignatureInfo = exports.BTCDelegatorDelegationIndex = exports.BTCDelegatorDelegations = exports.BTCUndelegation = exports.DelegatorUnbondingInfo = exports.BTCDelegation = exports.FinalityProviderWithMeta = exports.CommissionInfo = exports.FinalityProvider = exports.bTCDelegationStatusToJSON = exports.bTCDelegationStatusFromJSON = exports.BTCDelegationStatus = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const timestamp_1 = require("../../../google/protobuf/timestamp");
const staking_1 = require("../../../cosmos/staking/v1beta1/staking");
const pop_1 = require("../../../babylon/btcstaking/v1/pop");
const btccheckpoint_1 = require("../../../babylon/btccheckpoint/v1/btccheckpoint");
const btclightclient_1 = require("../../../babylon/btclightclient/v1/btclightclient");
exports.protobufPackage = "babylon.btcstaking.v1";
/**
 * BTCDelegationStatus is the status of a delegation.
 * There are two possible valid state transition paths for a BTC delegation:
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED -> EXPIRED
 * - PENDING -> VERIFIED -> ACTIVE -> UNBONDED/EXPIRED
 * and one invalid state transition path:
 * - PENDING -> VERIFIED -> UNBONDED i.e the staker unbonded before
 * activating delegation on Babylon chain.
 * In valid transition paths, the delegation becomes UNBONDED when:
 * - either the staking transaction timelock expires
 * - or the staker requests early undelegation through MsgBTCUndelegate message.
 */
var BTCDelegationStatus;
(function (BTCDelegationStatus) {
    /** PENDING - PENDING defines a delegation that is waiting for covenant signatures. */
    BTCDelegationStatus[BTCDelegationStatus["PENDING"] = 0] = "PENDING";
    /**
     * VERIFIED - VERIFIED defines a delegation that has covenant signatures but is not yet
     * included in the BTC chain.
     */
    BTCDelegationStatus[BTCDelegationStatus["VERIFIED"] = 1] = "VERIFIED";
    /** ACTIVE - ACTIVE defines a delegation that has voting power */
    BTCDelegationStatus[BTCDelegationStatus["ACTIVE"] = 2] = "ACTIVE";
    /**
     * UNBONDED - UNBONDED defines a delegation no longer has voting power
     * by receiving unbonding tx with signatures from staker and covenant
     * committee
     */
    BTCDelegationStatus[BTCDelegationStatus["UNBONDED"] = 3] = "UNBONDED";
    /**
     * EXPIRED - EXPIRED defines a delegation no longer has voting power
     * for reaching the end of staking transaction timelock
     */
    BTCDelegationStatus[BTCDelegationStatus["EXPIRED"] = 4] = "EXPIRED";
    /** ANY - ANY is any of the above status */
    BTCDelegationStatus[BTCDelegationStatus["ANY"] = 5] = "ANY";
    BTCDelegationStatus[BTCDelegationStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BTCDelegationStatus = exports.BTCDelegationStatus || (exports.BTCDelegationStatus = {}));
function bTCDelegationStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "PENDING":
            return BTCDelegationStatus.PENDING;
        case 1:
        case "VERIFIED":
            return BTCDelegationStatus.VERIFIED;
        case 2:
        case "ACTIVE":
            return BTCDelegationStatus.ACTIVE;
        case 3:
        case "UNBONDED":
            return BTCDelegationStatus.UNBONDED;
        case 4:
        case "EXPIRED":
            return BTCDelegationStatus.EXPIRED;
        case 5:
        case "ANY":
            return BTCDelegationStatus.ANY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BTCDelegationStatus.UNRECOGNIZED;
    }
}
exports.bTCDelegationStatusFromJSON = bTCDelegationStatusFromJSON;
function bTCDelegationStatusToJSON(object) {
    switch (object) {
        case BTCDelegationStatus.PENDING:
            return "PENDING";
        case BTCDelegationStatus.VERIFIED:
            return "VERIFIED";
        case BTCDelegationStatus.ACTIVE:
            return "ACTIVE";
        case BTCDelegationStatus.UNBONDED:
            return "UNBONDED";
        case BTCDelegationStatus.EXPIRED:
            return "EXPIRED";
        case BTCDelegationStatus.ANY:
            return "ANY";
        default:
            return "UNKNOWN";
    }
}
exports.bTCDelegationStatusToJSON = bTCDelegationStatusToJSON;
function createBaseFinalityProvider() {
    return {
        addr: "",
        description: undefined,
        commission: "",
        btcPk: new Uint8Array(),
        pop: undefined,
        slashedBabylonHeight: "0",
        slashedBtcHeight: 0,
        jailed: false,
        highestVotedHeight: 0,
        commissionInfo: undefined,
    };
}
exports.FinalityProvider = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.addr !== "") {
            writer.uint32(10).string(message.addr);
        }
        if (message.description !== undefined) {
            staking_1.Description.encode(message.description, writer.uint32(18).fork()).ldelim();
        }
        if (message.commission !== "") {
            writer.uint32(26).string(message.commission);
        }
        if (message.btcPk.length !== 0) {
            writer.uint32(34).bytes(message.btcPk);
        }
        if (message.pop !== undefined) {
            pop_1.ProofOfPossessionBTC.encode(message.pop, writer.uint32(42).fork()).ldelim();
        }
        if (message.slashedBabylonHeight !== "0") {
            writer.uint32(48).uint64(message.slashedBabylonHeight);
        }
        if (message.slashedBtcHeight !== 0) {
            writer.uint32(56).uint32(message.slashedBtcHeight);
        }
        if (message.jailed === true) {
            writer.uint32(64).bool(message.jailed);
        }
        if (message.highestVotedHeight !== 0) {
            writer.uint32(72).uint32(message.highestVotedHeight);
        }
        if (message.commissionInfo !== undefined) {
            exports.CommissionInfo.encode(message.commissionInfo, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFinalityProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.description = staking_1.Description.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.commission = reader.string();
                    break;
                case 4:
                    message.btcPk = reader.bytes();
                    break;
                case 5:
                    message.pop = pop_1.ProofOfPossessionBTC.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.slashedBabylonHeight = longToString(reader.uint64());
                    break;
                case 7:
                    message.slashedBtcHeight = reader.uint32();
                    break;
                case 8:
                    message.jailed = reader.bool();
                    break;
                case 9:
                    message.highestVotedHeight = reader.uint32();
                    break;
                case 11:
                    message.commissionInfo = exports.CommissionInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            addr: isSet(object.addr) ? String(object.addr) : "",
            description: isSet(object.description)
                ? staking_1.Description.fromJSON(object.description)
                : undefined,
            commission: isSet(object.commission) ? String(object.commission) : "",
            btcPk: isSet(object.btcPk)
                ? bytesFromBase64(object.btcPk)
                : new Uint8Array(),
            pop: isSet(object.pop)
                ? pop_1.ProofOfPossessionBTC.fromJSON(object.pop)
                : undefined,
            slashedBabylonHeight: isSet(object.slashedBabylonHeight)
                ? String(object.slashedBabylonHeight)
                : "0",
            slashedBtcHeight: isSet(object.slashedBtcHeight)
                ? Number(object.slashedBtcHeight)
                : 0,
            jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,
            highestVotedHeight: isSet(object.highestVotedHeight)
                ? Number(object.highestVotedHeight)
                : 0,
            commissionInfo: isSet(object.commissionInfo)
                ? exports.CommissionInfo.fromJSON(object.commissionInfo)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.addr !== undefined && (obj.addr = message.addr);
        message.description !== undefined &&
            (obj.description = message.description
                ? staking_1.Description.toJSON(message.description)
                : undefined);
        message.commission !== undefined && (obj.commission = message.commission);
        message.btcPk !== undefined &&
            (obj.btcPk = base64FromBytes(message.btcPk !== undefined ? message.btcPk : new Uint8Array()));
        message.pop !== undefined &&
            (obj.pop = message.pop
                ? pop_1.ProofOfPossessionBTC.toJSON(message.pop)
                : undefined);
        message.slashedBabylonHeight !== undefined &&
            (obj.slashedBabylonHeight = message.slashedBabylonHeight);
        message.slashedBtcHeight !== undefined &&
            (obj.slashedBtcHeight = Math.round(message.slashedBtcHeight));
        message.jailed !== undefined && (obj.jailed = message.jailed);
        message.highestVotedHeight !== undefined &&
            (obj.highestVotedHeight = Math.round(message.highestVotedHeight));
        message.commissionInfo !== undefined &&
            (obj.commissionInfo = message.commissionInfo
                ? exports.CommissionInfo.toJSON(message.commissionInfo)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseFinalityProvider();
        message.addr = (_a = object.addr) !== null && _a !== void 0 ? _a : "";
        message.description =
            object.description !== undefined && object.description !== null
                ? staking_1.Description.fromPartial(object.description)
                : undefined;
        message.commission = (_b = object.commission) !== null && _b !== void 0 ? _b : "";
        message.btcPk = (_c = object.btcPk) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.pop =
            object.pop !== undefined && object.pop !== null
                ? pop_1.ProofOfPossessionBTC.fromPartial(object.pop)
                : undefined;
        message.slashedBabylonHeight = (_d = object.slashedBabylonHeight) !== null && _d !== void 0 ? _d : "0";
        message.slashedBtcHeight = (_e = object.slashedBtcHeight) !== null && _e !== void 0 ? _e : 0;
        message.jailed = (_f = object.jailed) !== null && _f !== void 0 ? _f : false;
        message.highestVotedHeight = (_g = object.highestVotedHeight) !== null && _g !== void 0 ? _g : 0;
        message.commissionInfo =
            object.commissionInfo !== undefined && object.commissionInfo !== null
                ? exports.CommissionInfo.fromPartial(object.commissionInfo)
                : undefined;
        return message;
    },
};
function createBaseCommissionInfo() {
    return { maxRate: "", maxChangeRate: "", updateTime: undefined };
}
exports.CommissionInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.maxRate !== "") {
            writer.uint32(10).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
            writer.uint32(18).string(message.maxChangeRate);
        }
        if (message.updateTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommissionInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maxRate = reader.string();
                    break;
                case 2:
                    message.maxChangeRate = reader.string();
                    break;
                case 3:
                    message.updateTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxRate: isSet(object.maxRate) ? String(object.maxRate) : "",
            maxChangeRate: isSet(object.maxChangeRate)
                ? String(object.maxChangeRate)
                : "",
            updateTime: isSet(object.updateTime)
                ? fromJsonTimestamp(object.updateTime)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.maxRate !== undefined && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== undefined &&
            (obj.maxChangeRate = message.maxChangeRate);
        message.updateTime !== undefined &&
            (obj.updateTime = message.updateTime.toISOString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseCommissionInfo();
        message.maxRate = (_a = object.maxRate) !== null && _a !== void 0 ? _a : "";
        message.maxChangeRate = (_b = object.maxChangeRate) !== null && _b !== void 0 ? _b : "";
        message.updateTime = (_c = object.updateTime) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseFinalityProviderWithMeta() {
    return {
        btcPk: new Uint8Array(),
        height: "0",
        votingPower: "0",
        slashedBabylonHeight: "0",
        slashedBtcHeight: 0,
        jailed: false,
        highestVotedHeight: 0,
    };
}
exports.FinalityProviderWithMeta = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.btcPk.length !== 0) {
            writer.uint32(10).bytes(message.btcPk);
        }
        if (message.height !== "0") {
            writer.uint32(16).uint64(message.height);
        }
        if (message.votingPower !== "0") {
            writer.uint32(24).uint64(message.votingPower);
        }
        if (message.slashedBabylonHeight !== "0") {
            writer.uint32(32).uint64(message.slashedBabylonHeight);
        }
        if (message.slashedBtcHeight !== 0) {
            writer.uint32(40).uint32(message.slashedBtcHeight);
        }
        if (message.jailed === true) {
            writer.uint32(48).bool(message.jailed);
        }
        if (message.highestVotedHeight !== 0) {
            writer.uint32(56).uint32(message.highestVotedHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFinalityProviderWithMeta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.btcPk = reader.bytes();
                    break;
                case 2:
                    message.height = longToString(reader.uint64());
                    break;
                case 3:
                    message.votingPower = longToString(reader.uint64());
                    break;
                case 4:
                    message.slashedBabylonHeight = longToString(reader.uint64());
                    break;
                case 5:
                    message.slashedBtcHeight = reader.uint32();
                    break;
                case 6:
                    message.jailed = reader.bool();
                    break;
                case 7:
                    message.highestVotedHeight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            btcPk: isSet(object.btcPk)
                ? bytesFromBase64(object.btcPk)
                : new Uint8Array(),
            height: isSet(object.height) ? String(object.height) : "0",
            votingPower: isSet(object.votingPower) ? String(object.votingPower) : "0",
            slashedBabylonHeight: isSet(object.slashedBabylonHeight)
                ? String(object.slashedBabylonHeight)
                : "0",
            slashedBtcHeight: isSet(object.slashedBtcHeight)
                ? Number(object.slashedBtcHeight)
                : 0,
            jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,
            highestVotedHeight: isSet(object.highestVotedHeight)
                ? Number(object.highestVotedHeight)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.btcPk !== undefined &&
            (obj.btcPk = base64FromBytes(message.btcPk !== undefined ? message.btcPk : new Uint8Array()));
        message.height !== undefined && (obj.height = message.height);
        message.votingPower !== undefined &&
            (obj.votingPower = message.votingPower);
        message.slashedBabylonHeight !== undefined &&
            (obj.slashedBabylonHeight = message.slashedBabylonHeight);
        message.slashedBtcHeight !== undefined &&
            (obj.slashedBtcHeight = Math.round(message.slashedBtcHeight));
        message.jailed !== undefined && (obj.jailed = message.jailed);
        message.highestVotedHeight !== undefined &&
            (obj.highestVotedHeight = Math.round(message.highestVotedHeight));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseFinalityProviderWithMeta();
        message.btcPk = (_a = object.btcPk) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : "0";
        message.votingPower = (_c = object.votingPower) !== null && _c !== void 0 ? _c : "0";
        message.slashedBabylonHeight = (_d = object.slashedBabylonHeight) !== null && _d !== void 0 ? _d : "0";
        message.slashedBtcHeight = (_e = object.slashedBtcHeight) !== null && _e !== void 0 ? _e : 0;
        message.jailed = (_f = object.jailed) !== null && _f !== void 0 ? _f : false;
        message.highestVotedHeight = (_g = object.highestVotedHeight) !== null && _g !== void 0 ? _g : 0;
        return message;
    },
};
function createBaseBTCDelegation() {
    return {
        stakerAddr: "",
        btcPk: new Uint8Array(),
        pop: undefined,
        fpBtcPkList: [],
        stakingTime: 0,
        startHeight: 0,
        endHeight: 0,
        totalSat: "0",
        stakingTx: new Uint8Array(),
        stakingOutputIdx: 0,
        slashingTx: new Uint8Array(),
        delegatorSig: new Uint8Array(),
        covenantSigs: [],
        unbondingTime: 0,
        btcUndelegation: undefined,
        paramsVersion: 0,
        btcTipHeight: 0,
    };
}
exports.BTCDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stakerAddr !== "") {
            writer.uint32(10).string(message.stakerAddr);
        }
        if (message.btcPk.length !== 0) {
            writer.uint32(18).bytes(message.btcPk);
        }
        if (message.pop !== undefined) {
            pop_1.ProofOfPossessionBTC.encode(message.pop, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.fpBtcPkList) {
            writer.uint32(34).bytes(v);
        }
        if (message.stakingTime !== 0) {
            writer.uint32(40).uint32(message.stakingTime);
        }
        if (message.startHeight !== 0) {
            writer.uint32(48).uint32(message.startHeight);
        }
        if (message.endHeight !== 0) {
            writer.uint32(56).uint32(message.endHeight);
        }
        if (message.totalSat !== "0") {
            writer.uint32(64).uint64(message.totalSat);
        }
        if (message.stakingTx.length !== 0) {
            writer.uint32(74).bytes(message.stakingTx);
        }
        if (message.stakingOutputIdx !== 0) {
            writer.uint32(80).uint32(message.stakingOutputIdx);
        }
        if (message.slashingTx.length !== 0) {
            writer.uint32(90).bytes(message.slashingTx);
        }
        if (message.delegatorSig.length !== 0) {
            writer.uint32(98).bytes(message.delegatorSig);
        }
        for (const v of message.covenantSigs) {
            exports.CovenantAdaptorSignatures.encode(v, writer.uint32(106).fork()).ldelim();
        }
        if (message.unbondingTime !== 0) {
            writer.uint32(112).uint32(message.unbondingTime);
        }
        if (message.btcUndelegation !== undefined) {
            exports.BTCUndelegation.encode(message.btcUndelegation, writer.uint32(122).fork()).ldelim();
        }
        if (message.paramsVersion !== 0) {
            writer.uint32(128).uint32(message.paramsVersion);
        }
        if (message.btcTipHeight !== 0) {
            writer.uint32(136).uint32(message.btcTipHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBTCDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stakerAddr = reader.string();
                    break;
                case 2:
                    message.btcPk = reader.bytes();
                    break;
                case 3:
                    message.pop = pop_1.ProofOfPossessionBTC.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.fpBtcPkList.push(reader.bytes());
                    break;
                case 5:
                    message.stakingTime = reader.uint32();
                    break;
                case 6:
                    message.startHeight = reader.uint32();
                    break;
                case 7:
                    message.endHeight = reader.uint32();
                    break;
                case 8:
                    message.totalSat = longToString(reader.uint64());
                    break;
                case 9:
                    message.stakingTx = reader.bytes();
                    break;
                case 10:
                    message.stakingOutputIdx = reader.uint32();
                    break;
                case 11:
                    message.slashingTx = reader.bytes();
                    break;
                case 12:
                    message.delegatorSig = reader.bytes();
                    break;
                case 13:
                    message.covenantSigs.push(exports.CovenantAdaptorSignatures.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.unbondingTime = reader.uint32();
                    break;
                case 15:
                    message.btcUndelegation = exports.BTCUndelegation.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.paramsVersion = reader.uint32();
                    break;
                case 17:
                    message.btcTipHeight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            stakerAddr: isSet(object.stakerAddr) ? String(object.stakerAddr) : "",
            btcPk: isSet(object.btcPk)
                ? bytesFromBase64(object.btcPk)
                : new Uint8Array(),
            pop: isSet(object.pop)
                ? pop_1.ProofOfPossessionBTC.fromJSON(object.pop)
                : undefined,
            fpBtcPkList: Array.isArray(object === null || object === void 0 ? void 0 : object.fpBtcPkList)
                ? object.fpBtcPkList.map((e) => bytesFromBase64(e))
                : [],
            stakingTime: isSet(object.stakingTime) ? Number(object.stakingTime) : 0,
            startHeight: isSet(object.startHeight) ? Number(object.startHeight) : 0,
            endHeight: isSet(object.endHeight) ? Number(object.endHeight) : 0,
            totalSat: isSet(object.totalSat) ? String(object.totalSat) : "0",
            stakingTx: isSet(object.stakingTx)
                ? bytesFromBase64(object.stakingTx)
                : new Uint8Array(),
            stakingOutputIdx: isSet(object.stakingOutputIdx)
                ? Number(object.stakingOutputIdx)
                : 0,
            slashingTx: isSet(object.slashingTx)
                ? bytesFromBase64(object.slashingTx)
                : new Uint8Array(),
            delegatorSig: isSet(object.delegatorSig)
                ? bytesFromBase64(object.delegatorSig)
                : new Uint8Array(),
            covenantSigs: Array.isArray(object === null || object === void 0 ? void 0 : object.covenantSigs)
                ? object.covenantSigs.map((e) => exports.CovenantAdaptorSignatures.fromJSON(e))
                : [],
            unbondingTime: isSet(object.unbondingTime)
                ? Number(object.unbondingTime)
                : 0,
            btcUndelegation: isSet(object.btcUndelegation)
                ? exports.BTCUndelegation.fromJSON(object.btcUndelegation)
                : undefined,
            paramsVersion: isSet(object.paramsVersion)
                ? Number(object.paramsVersion)
                : 0,
            btcTipHeight: isSet(object.btcTipHeight)
                ? Number(object.btcTipHeight)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.stakerAddr !== undefined && (obj.stakerAddr = message.stakerAddr);
        message.btcPk !== undefined &&
            (obj.btcPk = base64FromBytes(message.btcPk !== undefined ? message.btcPk : new Uint8Array()));
        message.pop !== undefined &&
            (obj.pop = message.pop
                ? pop_1.ProofOfPossessionBTC.toJSON(message.pop)
                : undefined);
        if (message.fpBtcPkList) {
            obj.fpBtcPkList = message.fpBtcPkList.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.fpBtcPkList = [];
        }
        message.stakingTime !== undefined &&
            (obj.stakingTime = Math.round(message.stakingTime));
        message.startHeight !== undefined &&
            (obj.startHeight = Math.round(message.startHeight));
        message.endHeight !== undefined &&
            (obj.endHeight = Math.round(message.endHeight));
        message.totalSat !== undefined && (obj.totalSat = message.totalSat);
        message.stakingTx !== undefined &&
            (obj.stakingTx = base64FromBytes(message.stakingTx !== undefined ? message.stakingTx : new Uint8Array()));
        message.stakingOutputIdx !== undefined &&
            (obj.stakingOutputIdx = Math.round(message.stakingOutputIdx));
        message.slashingTx !== undefined &&
            (obj.slashingTx = base64FromBytes(message.slashingTx !== undefined ? message.slashingTx : new Uint8Array()));
        message.delegatorSig !== undefined &&
            (obj.delegatorSig = base64FromBytes(message.delegatorSig !== undefined
                ? message.delegatorSig
                : new Uint8Array()));
        if (message.covenantSigs) {
            obj.covenantSigs = message.covenantSigs.map((e) => e ? exports.CovenantAdaptorSignatures.toJSON(e) : undefined);
        }
        else {
            obj.covenantSigs = [];
        }
        message.unbondingTime !== undefined &&
            (obj.unbondingTime = Math.round(message.unbondingTime));
        message.btcUndelegation !== undefined &&
            (obj.btcUndelegation = message.btcUndelegation
                ? exports.BTCUndelegation.toJSON(message.btcUndelegation)
                : undefined);
        message.paramsVersion !== undefined &&
            (obj.paramsVersion = Math.round(message.paramsVersion));
        message.btcTipHeight !== undefined &&
            (obj.btcTipHeight = Math.round(message.btcTipHeight));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const message = createBaseBTCDelegation();
        message.stakerAddr = (_a = object.stakerAddr) !== null && _a !== void 0 ? _a : "";
        message.btcPk = (_b = object.btcPk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.pop =
            object.pop !== undefined && object.pop !== null
                ? pop_1.ProofOfPossessionBTC.fromPartial(object.pop)
                : undefined;
        message.fpBtcPkList = ((_c = object.fpBtcPkList) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.stakingTime = (_d = object.stakingTime) !== null && _d !== void 0 ? _d : 0;
        message.startHeight = (_e = object.startHeight) !== null && _e !== void 0 ? _e : 0;
        message.endHeight = (_f = object.endHeight) !== null && _f !== void 0 ? _f : 0;
        message.totalSat = (_g = object.totalSat) !== null && _g !== void 0 ? _g : "0";
        message.stakingTx = (_h = object.stakingTx) !== null && _h !== void 0 ? _h : new Uint8Array();
        message.stakingOutputIdx = (_j = object.stakingOutputIdx) !== null && _j !== void 0 ? _j : 0;
        message.slashingTx = (_k = object.slashingTx) !== null && _k !== void 0 ? _k : new Uint8Array();
        message.delegatorSig = (_l = object.delegatorSig) !== null && _l !== void 0 ? _l : new Uint8Array();
        message.covenantSigs =
            ((_m = object.covenantSigs) === null || _m === void 0 ? void 0 : _m.map((e) => exports.CovenantAdaptorSignatures.fromPartial(e))) || [];
        message.unbondingTime = (_o = object.unbondingTime) !== null && _o !== void 0 ? _o : 0;
        message.btcUndelegation =
            object.btcUndelegation !== undefined && object.btcUndelegation !== null
                ? exports.BTCUndelegation.fromPartial(object.btcUndelegation)
                : undefined;
        message.paramsVersion = (_p = object.paramsVersion) !== null && _p !== void 0 ? _p : 0;
        message.btcTipHeight = (_q = object.btcTipHeight) !== null && _q !== void 0 ? _q : 0;
        return message;
    },
};
function createBaseDelegatorUnbondingInfo() {
    return { spendStakeTx: new Uint8Array() };
}
exports.DelegatorUnbondingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spendStakeTx.length !== 0) {
            writer.uint32(10).bytes(message.spendStakeTx);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegatorUnbondingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spendStakeTx = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            spendStakeTx: isSet(object.spendStakeTx)
                ? bytesFromBase64(object.spendStakeTx)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.spendStakeTx !== undefined &&
            (obj.spendStakeTx = base64FromBytes(message.spendStakeTx !== undefined
                ? message.spendStakeTx
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseDelegatorUnbondingInfo();
        message.spendStakeTx = (_a = object.spendStakeTx) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseBTCUndelegation() {
    return {
        unbondingTx: new Uint8Array(),
        slashingTx: new Uint8Array(),
        delegatorSlashingSig: new Uint8Array(),
        covenantSlashingSigs: [],
        covenantUnbondingSigList: [],
        delegatorUnbondingInfo: undefined,
    };
}
exports.BTCUndelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingTx.length !== 0) {
            writer.uint32(10).bytes(message.unbondingTx);
        }
        if (message.slashingTx.length !== 0) {
            writer.uint32(18).bytes(message.slashingTx);
        }
        if (message.delegatorSlashingSig.length !== 0) {
            writer.uint32(26).bytes(message.delegatorSlashingSig);
        }
        for (const v of message.covenantSlashingSigs) {
            exports.CovenantAdaptorSignatures.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.covenantUnbondingSigList) {
            exports.SignatureInfo.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.delegatorUnbondingInfo !== undefined) {
            exports.DelegatorUnbondingInfo.encode(message.delegatorUnbondingInfo, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBTCUndelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.unbondingTx = reader.bytes();
                    break;
                case 2:
                    message.slashingTx = reader.bytes();
                    break;
                case 3:
                    message.delegatorSlashingSig = reader.bytes();
                    break;
                case 4:
                    message.covenantSlashingSigs.push(exports.CovenantAdaptorSignatures.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.covenantUnbondingSigList.push(exports.SignatureInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.delegatorUnbondingInfo = exports.DelegatorUnbondingInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            unbondingTx: isSet(object.unbondingTx)
                ? bytesFromBase64(object.unbondingTx)
                : new Uint8Array(),
            slashingTx: isSet(object.slashingTx)
                ? bytesFromBase64(object.slashingTx)
                : new Uint8Array(),
            delegatorSlashingSig: isSet(object.delegatorSlashingSig)
                ? bytesFromBase64(object.delegatorSlashingSig)
                : new Uint8Array(),
            covenantSlashingSigs: Array.isArray(object === null || object === void 0 ? void 0 : object.covenantSlashingSigs)
                ? object.covenantSlashingSigs.map((e) => exports.CovenantAdaptorSignatures.fromJSON(e))
                : [],
            covenantUnbondingSigList: Array.isArray(object === null || object === void 0 ? void 0 : object.covenantUnbondingSigList)
                ? object.covenantUnbondingSigList.map((e) => exports.SignatureInfo.fromJSON(e))
                : [],
            delegatorUnbondingInfo: isSet(object.delegatorUnbondingInfo)
                ? exports.DelegatorUnbondingInfo.fromJSON(object.delegatorUnbondingInfo)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.unbondingTx !== undefined &&
            (obj.unbondingTx = base64FromBytes(message.unbondingTx !== undefined
                ? message.unbondingTx
                : new Uint8Array()));
        message.slashingTx !== undefined &&
            (obj.slashingTx = base64FromBytes(message.slashingTx !== undefined ? message.slashingTx : new Uint8Array()));
        message.delegatorSlashingSig !== undefined &&
            (obj.delegatorSlashingSig = base64FromBytes(message.delegatorSlashingSig !== undefined
                ? message.delegatorSlashingSig
                : new Uint8Array()));
        if (message.covenantSlashingSigs) {
            obj.covenantSlashingSigs = message.covenantSlashingSigs.map((e) => e ? exports.CovenantAdaptorSignatures.toJSON(e) : undefined);
        }
        else {
            obj.covenantSlashingSigs = [];
        }
        if (message.covenantUnbondingSigList) {
            obj.covenantUnbondingSigList = message.covenantUnbondingSigList.map((e) => e ? exports.SignatureInfo.toJSON(e) : undefined);
        }
        else {
            obj.covenantUnbondingSigList = [];
        }
        message.delegatorUnbondingInfo !== undefined &&
            (obj.delegatorUnbondingInfo = message.delegatorUnbondingInfo
                ? exports.DelegatorUnbondingInfo.toJSON(message.delegatorUnbondingInfo)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseBTCUndelegation();
        message.unbondingTx = (_a = object.unbondingTx) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.slashingTx = (_b = object.slashingTx) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.delegatorSlashingSig =
            (_c = object.delegatorSlashingSig) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.covenantSlashingSigs =
            ((_d = object.covenantSlashingSigs) === null || _d === void 0 ? void 0 : _d.map((e) => exports.CovenantAdaptorSignatures.fromPartial(e))) || [];
        message.covenantUnbondingSigList =
            ((_e = object.covenantUnbondingSigList) === null || _e === void 0 ? void 0 : _e.map((e) => exports.SignatureInfo.fromPartial(e))) || [];
        message.delegatorUnbondingInfo =
            object.delegatorUnbondingInfo !== undefined &&
                object.delegatorUnbondingInfo !== null
                ? exports.DelegatorUnbondingInfo.fromPartial(object.delegatorUnbondingInfo)
                : undefined;
        return message;
    },
};
function createBaseBTCDelegatorDelegations() {
    return { dels: [] };
}
exports.BTCDelegatorDelegations = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.dels) {
            exports.BTCDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBTCDelegatorDelegations();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dels.push(exports.BTCDelegation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            dels: Array.isArray(object === null || object === void 0 ? void 0 : object.dels)
                ? object.dels.map((e) => exports.BTCDelegation.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.dels) {
            obj.dels = message.dels.map((e) => e ? exports.BTCDelegation.toJSON(e) : undefined);
        }
        else {
            obj.dels = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBTCDelegatorDelegations();
        message.dels = ((_a = object.dels) === null || _a === void 0 ? void 0 : _a.map((e) => exports.BTCDelegation.fromPartial(e))) || [];
        return message;
    },
};
function createBaseBTCDelegatorDelegationIndex() {
    return { stakingTxHashList: [] };
}
exports.BTCDelegatorDelegationIndex = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.stakingTxHashList) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBTCDelegatorDelegationIndex();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stakingTxHashList.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            stakingTxHashList: Array.isArray(object === null || object === void 0 ? void 0 : object.stakingTxHashList)
                ? object.stakingTxHashList.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.stakingTxHashList) {
            obj.stakingTxHashList = message.stakingTxHashList.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.stakingTxHashList = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseBTCDelegatorDelegationIndex();
        message.stakingTxHashList = ((_a = object.stakingTxHashList) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
    },
};
function createBaseSignatureInfo() {
    return { pk: new Uint8Array(), sig: new Uint8Array() };
}
exports.SignatureInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pk.length !== 0) {
            writer.uint32(10).bytes(message.pk);
        }
        if (message.sig.length !== 0) {
            writer.uint32(18).bytes(message.sig);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignatureInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pk = reader.bytes();
                    break;
                case 2:
                    message.sig = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pk: isSet(object.pk) ? bytesFromBase64(object.pk) : new Uint8Array(),
            sig: isSet(object.sig) ? bytesFromBase64(object.sig) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.pk !== undefined &&
            (obj.pk = base64FromBytes(message.pk !== undefined ? message.pk : new Uint8Array()));
        message.sig !== undefined &&
            (obj.sig = base64FromBytes(message.sig !== undefined ? message.sig : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSignatureInfo();
        message.pk = (_a = object.pk) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.sig = (_b = object.sig) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseCovenantAdaptorSignatures() {
    return { covPk: new Uint8Array(), adaptorSigs: [] };
}
exports.CovenantAdaptorSignatures = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.covPk.length !== 0) {
            writer.uint32(10).bytes(message.covPk);
        }
        for (const v of message.adaptorSigs) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCovenantAdaptorSignatures();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.covPk = reader.bytes();
                    break;
                case 2:
                    message.adaptorSigs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            covPk: isSet(object.covPk)
                ? bytesFromBase64(object.covPk)
                : new Uint8Array(),
            adaptorSigs: Array.isArray(object === null || object === void 0 ? void 0 : object.adaptorSigs)
                ? object.adaptorSigs.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.covPk !== undefined &&
            (obj.covPk = base64FromBytes(message.covPk !== undefined ? message.covPk : new Uint8Array()));
        if (message.adaptorSigs) {
            obj.adaptorSigs = message.adaptorSigs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.adaptorSigs = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseCovenantAdaptorSignatures();
        message.covPk = (_a = object.covPk) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.adaptorSigs = ((_b = object.adaptorSigs) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseSelectiveSlashingEvidence() {
    return {
        stakingTxHash: "",
        fpBtcPk: new Uint8Array(),
        recoveredFpBtcSk: new Uint8Array(),
    };
}
exports.SelectiveSlashingEvidence = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stakingTxHash !== "") {
            writer.uint32(10).string(message.stakingTxHash);
        }
        if (message.fpBtcPk.length !== 0) {
            writer.uint32(18).bytes(message.fpBtcPk);
        }
        if (message.recoveredFpBtcSk.length !== 0) {
            writer.uint32(26).bytes(message.recoveredFpBtcSk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelectiveSlashingEvidence();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stakingTxHash = reader.string();
                    break;
                case 2:
                    message.fpBtcPk = reader.bytes();
                    break;
                case 3:
                    message.recoveredFpBtcSk = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            stakingTxHash: isSet(object.stakingTxHash)
                ? String(object.stakingTxHash)
                : "",
            fpBtcPk: isSet(object.fpBtcPk)
                ? bytesFromBase64(object.fpBtcPk)
                : new Uint8Array(),
            recoveredFpBtcSk: isSet(object.recoveredFpBtcSk)
                ? bytesFromBase64(object.recoveredFpBtcSk)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.stakingTxHash !== undefined &&
            (obj.stakingTxHash = message.stakingTxHash);
        message.fpBtcPk !== undefined &&
            (obj.fpBtcPk = base64FromBytes(message.fpBtcPk !== undefined ? message.fpBtcPk : new Uint8Array()));
        message.recoveredFpBtcSk !== undefined &&
            (obj.recoveredFpBtcSk = base64FromBytes(message.recoveredFpBtcSk !== undefined
                ? message.recoveredFpBtcSk
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSelectiveSlashingEvidence();
        message.stakingTxHash = (_a = object.stakingTxHash) !== null && _a !== void 0 ? _a : "";
        message.fpBtcPk = (_b = object.fpBtcPk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.recoveredFpBtcSk = (_c = object.recoveredFpBtcSk) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    },
};
function createBaseInclusionProof() {
    return { key: undefined, proof: new Uint8Array() };
}
exports.InclusionProof = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== undefined) {
            btccheckpoint_1.TransactionKey.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
            writer.uint32(18).bytes(message.proof);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInclusionProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = btccheckpoint_1.TransactionKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proof = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? btccheckpoint_1.TransactionKey.fromJSON(object.key) : undefined,
            proof: isSet(object.proof)
                ? bytesFromBase64(object.proof)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined &&
            (obj.key = message.key ? btccheckpoint_1.TransactionKey.toJSON(message.key) : undefined);
        message.proof !== undefined &&
            (obj.proof = base64FromBytes(message.proof !== undefined ? message.proof : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInclusionProof();
        message.key =
            object.key !== undefined && object.key !== null
                ? btccheckpoint_1.TransactionKey.fromPartial(object.key)
                : undefined;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    },
};
function createBaseLargestBtcReOrg() {
    return { blockDiff: 0, rollbackFrom: undefined, rollbackTo: undefined };
}
exports.LargestBtcReOrg = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockDiff !== 0) {
            writer.uint32(8).uint32(message.blockDiff);
        }
        if (message.rollbackFrom !== undefined) {
            btclightclient_1.BTCHeaderInfo.encode(message.rollbackFrom, writer.uint32(18).fork()).ldelim();
        }
        if (message.rollbackTo !== undefined) {
            btclightclient_1.BTCHeaderInfo.encode(message.rollbackTo, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLargestBtcReOrg();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockDiff = reader.uint32();
                    break;
                case 2:
                    message.rollbackFrom = btclightclient_1.BTCHeaderInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.rollbackTo = btclightclient_1.BTCHeaderInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockDiff: isSet(object.blockDiff) ? Number(object.blockDiff) : 0,
            rollbackFrom: isSet(object.rollbackFrom)
                ? btclightclient_1.BTCHeaderInfo.fromJSON(object.rollbackFrom)
                : undefined,
            rollbackTo: isSet(object.rollbackTo)
                ? btclightclient_1.BTCHeaderInfo.fromJSON(object.rollbackTo)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.blockDiff !== undefined &&
            (obj.blockDiff = Math.round(message.blockDiff));
        message.rollbackFrom !== undefined &&
            (obj.rollbackFrom = message.rollbackFrom
                ? btclightclient_1.BTCHeaderInfo.toJSON(message.rollbackFrom)
                : undefined);
        message.rollbackTo !== undefined &&
            (obj.rollbackTo = message.rollbackTo
                ? btclightclient_1.BTCHeaderInfo.toJSON(message.rollbackTo)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseLargestBtcReOrg();
        message.blockDiff = (_a = object.blockDiff) !== null && _a !== void 0 ? _a : 0;
        message.rollbackFrom =
            object.rollbackFrom !== undefined && object.rollbackFrom !== null
                ? btclightclient_1.BTCHeaderInfo.fromPartial(object.rollbackFrom)
                : undefined;
        message.rollbackTo =
            object.rollbackTo !== undefined && object.rollbackTo !== null
                ? btclightclient_1.BTCHeaderInfo.fromPartial(object.rollbackTo)
                : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000).toString();
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = Number(t.seconds) * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=btcstaking.js.map