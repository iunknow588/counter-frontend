"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BTCCheckpointInfo = exports.CheckpointAddresses = exports.EpochData = exports.SubmissionData = exports.TransactionInfo = exports.SubmissionKey = exports.TransactionKey = exports.BTCSpvProof = exports.btcStatusToJSON = exports.btcStatusFromJSON = exports.BtcStatus = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "babylon.btccheckpoint.v1";
/** BtcStatus is an enum describing the current btc status of the checkpoint */
var BtcStatus;
(function (BtcStatus) {
    /**
     * EPOCH_STATUS_SUBMITTED - SUBMITTED Epoch has Submitted btc status if there ever was at least one
     * known submission on btc main chain
     */
    BtcStatus[BtcStatus["EPOCH_STATUS_SUBMITTED"] = 0] = "EPOCH_STATUS_SUBMITTED";
    /**
     * EPOCH_STATUS_CONFIRMED - CONFIRMED Epoch has Confirmed btc status if there ever was at least one
     * known submission on btc main chain which was k-deep
     */
    BtcStatus[BtcStatus["EPOCH_STATUS_CONFIRMED"] = 1] = "EPOCH_STATUS_CONFIRMED";
    /**
     * EPOCH_STATUS_FINALIZED - CONFIRMED Epoch has Finalized btc status if there is was at exactly one
     * knon submission on btc main chain which is w-deep
     */
    BtcStatus[BtcStatus["EPOCH_STATUS_FINALIZED"] = 2] = "EPOCH_STATUS_FINALIZED";
    BtcStatus[BtcStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BtcStatus = exports.BtcStatus || (exports.BtcStatus = {}));
function btcStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "EPOCH_STATUS_SUBMITTED":
            return BtcStatus.EPOCH_STATUS_SUBMITTED;
        case 1:
        case "EPOCH_STATUS_CONFIRMED":
            return BtcStatus.EPOCH_STATUS_CONFIRMED;
        case 2:
        case "EPOCH_STATUS_FINALIZED":
            return BtcStatus.EPOCH_STATUS_FINALIZED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BtcStatus.UNRECOGNIZED;
    }
}
exports.btcStatusFromJSON = btcStatusFromJSON;
function btcStatusToJSON(object) {
    switch (object) {
        case BtcStatus.EPOCH_STATUS_SUBMITTED:
            return "EPOCH_STATUS_SUBMITTED";
        case BtcStatus.EPOCH_STATUS_CONFIRMED:
            return "EPOCH_STATUS_CONFIRMED";
        case BtcStatus.EPOCH_STATUS_FINALIZED:
            return "EPOCH_STATUS_FINALIZED";
        default:
            return "UNKNOWN";
    }
}
exports.btcStatusToJSON = btcStatusToJSON;
function createBaseBTCSpvProof() {
    return {
        btcTransaction: new Uint8Array(),
        btcTransactionIndex: 0,
        merkleNodes: new Uint8Array(),
        confirmingBtcHeader: new Uint8Array(),
    };
}
exports.BTCSpvProof = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.btcTransaction.length !== 0) {
            writer.uint32(10).bytes(message.btcTransaction);
        }
        if (message.btcTransactionIndex !== 0) {
            writer.uint32(16).uint32(message.btcTransactionIndex);
        }
        if (message.merkleNodes.length !== 0) {
            writer.uint32(26).bytes(message.merkleNodes);
        }
        if (message.confirmingBtcHeader.length !== 0) {
            writer.uint32(34).bytes(message.confirmingBtcHeader);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBTCSpvProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.btcTransaction = reader.bytes();
                    break;
                case 2:
                    message.btcTransactionIndex = reader.uint32();
                    break;
                case 3:
                    message.merkleNodes = reader.bytes();
                    break;
                case 4:
                    message.confirmingBtcHeader = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            btcTransaction: isSet(object.btcTransaction)
                ? bytesFromBase64(object.btcTransaction)
                : new Uint8Array(),
            btcTransactionIndex: isSet(object.btcTransactionIndex)
                ? Number(object.btcTransactionIndex)
                : 0,
            merkleNodes: isSet(object.merkleNodes)
                ? bytesFromBase64(object.merkleNodes)
                : new Uint8Array(),
            confirmingBtcHeader: isSet(object.confirmingBtcHeader)
                ? bytesFromBase64(object.confirmingBtcHeader)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.btcTransaction !== undefined &&
            (obj.btcTransaction = base64FromBytes(message.btcTransaction !== undefined
                ? message.btcTransaction
                : new Uint8Array()));
        message.btcTransactionIndex !== undefined &&
            (obj.btcTransactionIndex = Math.round(message.btcTransactionIndex));
        message.merkleNodes !== undefined &&
            (obj.merkleNodes = base64FromBytes(message.merkleNodes !== undefined
                ? message.merkleNodes
                : new Uint8Array()));
        message.confirmingBtcHeader !== undefined &&
            (obj.confirmingBtcHeader = base64FromBytes(message.confirmingBtcHeader !== undefined
                ? message.confirmingBtcHeader
                : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseBTCSpvProof();
        message.btcTransaction = (_a = object.btcTransaction) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.btcTransactionIndex = (_b = object.btcTransactionIndex) !== null && _b !== void 0 ? _b : 0;
        message.merkleNodes = (_c = object.merkleNodes) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.confirmingBtcHeader =
            (_d = object.confirmingBtcHeader) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    },
};
function createBaseTransactionKey() {
    return { index: 0, hash: new Uint8Array() };
}
exports.TransactionKey = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
            writer.uint32(8).uint32(message.index);
        }
        if (message.hash.length !== 0) {
            writer.uint32(18).bytes(message.hash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.uint32();
                    break;
                case 2:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet(object.index) ? Number(object.index) : 0,
            hash: isSet(object.hash)
                ? bytesFromBase64(object.hash)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.hash !== undefined &&
            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTransactionKey();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseSubmissionKey() {
    return { key: [] };
}
exports.SubmissionKey = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.key) {
            exports.TransactionKey.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key.push(exports.TransactionKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: Array.isArray(object === null || object === void 0 ? void 0 : object.key)
                ? object.key.map((e) => exports.TransactionKey.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key) {
            obj.key = message.key.map((e) => e ? exports.TransactionKey.toJSON(e) : undefined);
        }
        else {
            obj.key = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseSubmissionKey();
        message.key = ((_a = object.key) === null || _a === void 0 ? void 0 : _a.map((e) => exports.TransactionKey.fromPartial(e))) || [];
        return message;
    },
};
function createBaseTransactionInfo() {
    return {
        key: undefined,
        transaction: new Uint8Array(),
        proof: new Uint8Array(),
    };
}
exports.TransactionInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== undefined) {
            exports.TransactionKey.encode(message.key, writer.uint32(10).fork()).ldelim();
        }
        if (message.transaction.length !== 0) {
            writer.uint32(18).bytes(message.transaction);
        }
        if (message.proof.length !== 0) {
            writer.uint32(26).bytes(message.proof);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransactionInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = exports.TransactionKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.transaction = reader.bytes();
                    break;
                case 3:
                    message.proof = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? exports.TransactionKey.fromJSON(object.key) : undefined,
            transaction: isSet(object.transaction)
                ? bytesFromBase64(object.transaction)
                : new Uint8Array(),
            proof: isSet(object.proof)
                ? bytesFromBase64(object.proof)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined &&
            (obj.key = message.key ? exports.TransactionKey.toJSON(message.key) : undefined);
        message.transaction !== undefined &&
            (obj.transaction = base64FromBytes(message.transaction !== undefined
                ? message.transaction
                : new Uint8Array()));
        message.proof !== undefined &&
            (obj.proof = base64FromBytes(message.proof !== undefined ? message.proof : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTransactionInfo();
        message.key =
            object.key !== undefined && object.key !== null
                ? exports.TransactionKey.fromPartial(object.key)
                : undefined;
        message.transaction = (_a = object.transaction) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseSubmissionData() {
    return { vigilanteAddresses: undefined, txsInfo: [], epoch: "0" };
}
exports.SubmissionData = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.vigilanteAddresses !== undefined) {
            exports.CheckpointAddresses.encode(message.vigilanteAddresses, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txsInfo) {
            exports.TransactionInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.epoch !== "0") {
            writer.uint32(24).uint64(message.epoch);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubmissionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vigilanteAddresses = exports.CheckpointAddresses.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.txsInfo.push(exports.TransactionInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.epoch = longToString(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            vigilanteAddresses: isSet(object.vigilanteAddresses)
                ? exports.CheckpointAddresses.fromJSON(object.vigilanteAddresses)
                : undefined,
            txsInfo: Array.isArray(object === null || object === void 0 ? void 0 : object.txsInfo)
                ? object.txsInfo.map((e) => exports.TransactionInfo.fromJSON(e))
                : [],
            epoch: isSet(object.epoch) ? String(object.epoch) : "0",
        };
    },
    toJSON(message) {
        const obj = {};
        message.vigilanteAddresses !== undefined &&
            (obj.vigilanteAddresses = message.vigilanteAddresses
                ? exports.CheckpointAddresses.toJSON(message.vigilanteAddresses)
                : undefined);
        if (message.txsInfo) {
            obj.txsInfo = message.txsInfo.map((e) => e ? exports.TransactionInfo.toJSON(e) : undefined);
        }
        else {
            obj.txsInfo = [];
        }
        message.epoch !== undefined && (obj.epoch = message.epoch);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSubmissionData();
        message.vigilanteAddresses =
            object.vigilanteAddresses !== undefined &&
                object.vigilanteAddresses !== null
                ? exports.CheckpointAddresses.fromPartial(object.vigilanteAddresses)
                : undefined;
        message.txsInfo =
            ((_a = object.txsInfo) === null || _a === void 0 ? void 0 : _a.map((e) => exports.TransactionInfo.fromPartial(e))) || [];
        message.epoch = (_b = object.epoch) !== null && _b !== void 0 ? _b : "0";
        return message;
    },
};
function createBaseEpochData() {
    return { keys: [], status: 0 };
}
exports.EpochData = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.keys) {
            exports.SubmissionKey.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEpochData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keys.push(exports.SubmissionKey.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            keys: Array.isArray(object === null || object === void 0 ? void 0 : object.keys)
                ? object.keys.map((e) => exports.SubmissionKey.fromJSON(e))
                : [],
            status: isSet(object.status) ? btcStatusFromJSON(object.status) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keys) {
            obj.keys = message.keys.map((e) => e ? exports.SubmissionKey.toJSON(e) : undefined);
        }
        else {
            obj.keys = [];
        }
        message.status !== undefined &&
            (obj.status = btcStatusToJSON(message.status));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseEpochData();
        message.keys = ((_a = object.keys) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SubmissionKey.fromPartial(e))) || [];
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseCheckpointAddresses() {
    return { submitter: new Uint8Array(), reporter: new Uint8Array() };
}
exports.CheckpointAddresses = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.submitter.length !== 0) {
            writer.uint32(10).bytes(message.submitter);
        }
        if (message.reporter.length !== 0) {
            writer.uint32(18).bytes(message.reporter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckpointAddresses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.submitter = reader.bytes();
                    break;
                case 2:
                    message.reporter = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            submitter: isSet(object.submitter)
                ? bytesFromBase64(object.submitter)
                : new Uint8Array(),
            reporter: isSet(object.reporter)
                ? bytesFromBase64(object.reporter)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.submitter !== undefined &&
            (obj.submitter = base64FromBytes(message.submitter !== undefined ? message.submitter : new Uint8Array()));
        message.reporter !== undefined &&
            (obj.reporter = base64FromBytes(message.reporter !== undefined ? message.reporter : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseCheckpointAddresses();
        message.submitter = (_a = object.submitter) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.reporter = (_b = object.reporter) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    },
};
function createBaseBTCCheckpointInfo() {
    return {
        epochNumber: "0",
        bestSubmissionBtcBlockHeight: 0,
        bestSubmissionBtcBlockHash: new Uint8Array(),
        bestSubmissionTransactions: [],
        bestSubmissionVigilanteAddressList: [],
    };
}
exports.BTCCheckpointInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.epochNumber !== "0") {
            writer.uint32(8).uint64(message.epochNumber);
        }
        if (message.bestSubmissionBtcBlockHeight !== 0) {
            writer.uint32(16).uint32(message.bestSubmissionBtcBlockHeight);
        }
        if (message.bestSubmissionBtcBlockHash.length !== 0) {
            writer.uint32(26).bytes(message.bestSubmissionBtcBlockHash);
        }
        for (const v of message.bestSubmissionTransactions) {
            exports.TransactionInfo.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.bestSubmissionVigilanteAddressList) {
            exports.CheckpointAddresses.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBTCCheckpointInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.epochNumber = longToString(reader.uint64());
                    break;
                case 2:
                    message.bestSubmissionBtcBlockHeight = reader.uint32();
                    break;
                case 3:
                    message.bestSubmissionBtcBlockHash = reader.bytes();
                    break;
                case 4:
                    message.bestSubmissionTransactions.push(exports.TransactionInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.bestSubmissionVigilanteAddressList.push(exports.CheckpointAddresses.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            epochNumber: isSet(object.epochNumber) ? String(object.epochNumber) : "0",
            bestSubmissionBtcBlockHeight: isSet(object.bestSubmissionBtcBlockHeight)
                ? Number(object.bestSubmissionBtcBlockHeight)
                : 0,
            bestSubmissionBtcBlockHash: isSet(object.bestSubmissionBtcBlockHash)
                ? bytesFromBase64(object.bestSubmissionBtcBlockHash)
                : new Uint8Array(),
            bestSubmissionTransactions: Array.isArray(object === null || object === void 0 ? void 0 : object.bestSubmissionTransactions)
                ? object.bestSubmissionTransactions.map((e) => exports.TransactionInfo.fromJSON(e))
                : [],
            bestSubmissionVigilanteAddressList: Array.isArray(object === null || object === void 0 ? void 0 : object.bestSubmissionVigilanteAddressList)
                ? object.bestSubmissionVigilanteAddressList.map((e) => exports.CheckpointAddresses.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.epochNumber !== undefined &&
            (obj.epochNumber = message.epochNumber);
        message.bestSubmissionBtcBlockHeight !== undefined &&
            (obj.bestSubmissionBtcBlockHeight = Math.round(message.bestSubmissionBtcBlockHeight));
        message.bestSubmissionBtcBlockHash !== undefined &&
            (obj.bestSubmissionBtcBlockHash = base64FromBytes(message.bestSubmissionBtcBlockHash !== undefined
                ? message.bestSubmissionBtcBlockHash
                : new Uint8Array()));
        if (message.bestSubmissionTransactions) {
            obj.bestSubmissionTransactions = message.bestSubmissionTransactions.map((e) => (e ? exports.TransactionInfo.toJSON(e) : undefined));
        }
        else {
            obj.bestSubmissionTransactions = [];
        }
        if (message.bestSubmissionVigilanteAddressList) {
            obj.bestSubmissionVigilanteAddressList =
                message.bestSubmissionVigilanteAddressList.map((e) => e ? exports.CheckpointAddresses.toJSON(e) : undefined);
        }
        else {
            obj.bestSubmissionVigilanteAddressList = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseBTCCheckpointInfo();
        message.epochNumber = (_a = object.epochNumber) !== null && _a !== void 0 ? _a : "0";
        message.bestSubmissionBtcBlockHeight =
            (_b = object.bestSubmissionBtcBlockHeight) !== null && _b !== void 0 ? _b : 0;
        message.bestSubmissionBtcBlockHash =
            (_c = object.bestSubmissionBtcBlockHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.bestSubmissionTransactions =
            ((_d = object.bestSubmissionTransactions) === null || _d === void 0 ? void 0 : _d.map((e) => exports.TransactionInfo.fromPartial(e))) || [];
        message.bestSubmissionVigilanteAddressList =
            ((_e = object.bestSubmissionVigilanteAddressList) === null || _e === void 0 ? void 0 : _e.map((e) => exports.CheckpointAddresses.fromPartial(e))) || [];
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=btccheckpoint.js.map