import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "babylon.btccheckpoint.v1";
/** BtcStatus is an enum describing the current btc status of the checkpoint */
export declare enum BtcStatus {
    /**
     * EPOCH_STATUS_SUBMITTED - SUBMITTED Epoch has Submitted btc status if there ever was at least one
     * known submission on btc main chain
     */
    EPOCH_STATUS_SUBMITTED = 0,
    /**
     * EPOCH_STATUS_CONFIRMED - CONFIRMED Epoch has Confirmed btc status if there ever was at least one
     * known submission on btc main chain which was k-deep
     */
    EPOCH_STATUS_CONFIRMED = 1,
    /**
     * EPOCH_STATUS_FINALIZED - CONFIRMED Epoch has Finalized btc status if there is was at exactly one
     * knon submission on btc main chain which is w-deep
     */
    EPOCH_STATUS_FINALIZED = 2,
    UNRECOGNIZED = -1
}
export declare function btcStatusFromJSON(object: any): BtcStatus;
export declare function btcStatusToJSON(object: BtcStatus): string;
/**
 * Consider we have a Merkle tree with following structure:
 *            ROOT
 *           /    \
 *      H1234      H5555
 *     /     \       \
 *   H12     H34      H55
 *  /  \    /  \     /
 * H1  H2  H3  H4  H5
 * L1  L2  L3  L4  L5
 * To prove L3 was part of ROOT we need:
 * - btc_transaction_index = 2 which in binary is 010
 * (where 0 means going left, 1 means going right in the tree)
 * - merkle_nodes we'd have H4 || H12 || H5555
 * By looking at 010 we would know that H4 is a right sibling,
 * H12 is left, H5555 is right again.
 */
export interface BTCSpvProof {
    /** Valid bitcoin transaction containing OP_RETURN opcode. */
    btcTransaction: Uint8Array;
    /**
     * Index of transaction within the block. Index is needed to determine if
     * currently hashed node is left or right.
     */
    btcTransactionIndex: number;
    /**
     * List of concatenated intermediate merkle tree nodes, without root node and
     * leaf node against which we calculate the proof. Each node has 32 byte
     * length. Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2
     * ||  32_bytes_of_node3 so the length of the proof will always be divisible
     * by 32.
     */
    merkleNodes: Uint8Array;
    /**
     * Valid btc header which confirms btc_transaction.
     * Should have exactly 80 bytes
     */
    confirmingBtcHeader: Uint8Array;
}
/**
 * Each provided OP_RETURN transaction can be identified by hash of block in
 * which transaction was included and transaction index in the block
 */
export interface TransactionKey {
    index: number;
    hash: Uint8Array;
}
/**
 * Checkpoint can be composed from multiple transactions, so to identify whole
 * submission we need list of transaction keys.
 * Each submission can generally be identified by this list of (txIdx,
 * blockHash) tuples. Note: this could possibly be optimized as if transactions
 * were in one block they would have the same block hash and different indexes,
 * but each blockhash is only 33 (1  byte for prefix encoding and 32 byte hash),
 * so there should be other strong arguments for this optimization
 */
export interface SubmissionKey {
    key: TransactionKey[];
}
/**
 * TransactionInfo is the info of a tx on Bitcoin,
 * including
 * - the position of the tx on BTC blockchain
 * - the full tx content
 * - the Merkle proof that this tx is on the above position
 */
export interface TransactionInfo {
    /**
     * key is the position (txIdx, blockHash) of this tx on BTC blockchain
     * Although it is already a part of SubmissionKey, we store it here again
     * to make TransactionInfo self-contained.
     * For example, storing the key allows TransactionInfo to not relay on
     * the fact that TransactionInfo will be ordered in the same order as
     * TransactionKeys in SubmissionKey.
     */
    key: TransactionKey | undefined;
    /** transaction is the full transaction in bytes */
    transaction: Uint8Array;
    /**
     * proof is the Merkle proof that this tx is included in the position in `key`
     * TODO: maybe it could use here better format as we already processed and
     * validated the proof?
     */
    proof: Uint8Array;
}
/**
 * TODO: Determine if we should keep any block number or depth info.
 * On one hand it may be useful to determine if block is stable or not, on
 * other depth/block number info, without context (i.e info about chain) is
 * pretty useless and blockhash in enough to retrieve is from lightclient
 */
export interface SubmissionData {
    /** address of the submitter and reporter */
    vigilanteAddresses: CheckpointAddresses | undefined;
    /**
     * txs_info is the two `TransactionInfo`s corresponding to the submission
     * It is used for
     * - recovering address of sender of btc transaction to payup the reward.
     * - allowing the ZoneConcierge module to prove the checkpoint is submitted to
     * BTC
     */
    txsInfo: TransactionInfo[];
    epoch: string;
}
/**
 * Data stored in db and indexed by epoch number
 * TODO: Add btc blockheight at epoch end, when adding handling of epoching
 * callbacks
 */
export interface EpochData {
    /**
     * keys is the list of all received checkpoints during this epoch, sorted by
     * order of submission.
     */
    keys: SubmissionKey[];
    /** status is the current btc status of the epoch */
    status: BtcStatus;
}
/**
 * CheckpointAddresses contains the addresses of the submitter and reporter of a
 * given checkpoint
 */
export interface CheckpointAddresses {
    /**
     * TODO: this could probably be better typed
     * submitter is the address of the checkpoint submitter to BTC, extracted from
     * the checkpoint itself.
     */
    submitter: Uint8Array;
    /**
     * reporter is the address of the reporter who reported the submissions,
     * calculated from submission message MsgInsertBTCSpvProof itself
     */
    reporter: Uint8Array;
}
/**
 * BTCCheckpointInfo contains all data about best submission of checkpoint for
 * given epoch. Best submission is the submission which is deeper in btc ledger
 */
export interface BTCCheckpointInfo {
    /** epoch number of this checkpoint */
    epochNumber: string;
    /** btc height of the best submission of the epoch */
    bestSubmissionBtcBlockHeight: number;
    /**
     * hash of the btc block which determines checkpoint btc block height i.e.
     * youngest block of best submission
     */
    bestSubmissionBtcBlockHash: Uint8Array;
    /** the BTC checkpoint transactions of the best submission */
    bestSubmissionTransactions: TransactionInfo[];
    /** list of vigilantes' addresses of the best submission */
    bestSubmissionVigilanteAddressList: CheckpointAddresses[];
}
export declare const BTCSpvProof: {
    encode(message: BTCSpvProof, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BTCSpvProof;
    fromJSON(object: any): BTCSpvProof;
    toJSON(message: BTCSpvProof): unknown;
    fromPartial<I extends {
        btcTransaction?: Uint8Array | undefined;
        btcTransactionIndex?: number | undefined;
        merkleNodes?: Uint8Array | undefined;
        confirmingBtcHeader?: Uint8Array | undefined;
    } & {
        btcTransaction?: Uint8Array | undefined;
        btcTransactionIndex?: number | undefined;
        merkleNodes?: Uint8Array | undefined;
        confirmingBtcHeader?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof BTCSpvProof>, never>>(object: I): BTCSpvProof;
};
export declare const TransactionKey: {
    encode(message: TransactionKey, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionKey;
    fromJSON(object: any): TransactionKey;
    toJSON(message: TransactionKey): unknown;
    fromPartial<I extends {
        index?: number | undefined;
        hash?: Uint8Array | undefined;
    } & {
        index?: number | undefined;
        hash?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof TransactionKey>, never>>(object: I): TransactionKey;
};
export declare const SubmissionKey: {
    encode(message: SubmissionKey, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmissionKey;
    fromJSON(object: any): SubmissionKey;
    toJSON(message: SubmissionKey): unknown;
    fromPartial<I extends {
        key?: {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        }[] | undefined;
    } & {
        key?: ({
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        }[] & ({
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } & {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["key"][number], keyof TransactionKey>, never>)[] & Record<Exclude<keyof I["key"], keyof {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, "key">, never>>(object: I): SubmissionKey;
};
export declare const TransactionInfo: {
    encode(message: TransactionInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TransactionInfo;
    fromJSON(object: any): TransactionInfo;
    toJSON(message: TransactionInfo): unknown;
    fromPartial<I extends {
        key?: {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } | undefined;
        transaction?: Uint8Array | undefined;
        proof?: Uint8Array | undefined;
    } & {
        key?: ({
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } & {
            index?: number | undefined;
            hash?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["key"], keyof TransactionKey>, never>) | undefined;
        transaction?: Uint8Array | undefined;
        proof?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof TransactionInfo>, never>>(object: I): TransactionInfo;
};
export declare const SubmissionData: {
    encode(message: SubmissionData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SubmissionData;
    fromJSON(object: any): SubmissionData;
    toJSON(message: SubmissionData): unknown;
    fromPartial<I extends {
        vigilanteAddresses?: {
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        } | undefined;
        txsInfo?: {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        }[] | undefined;
        epoch?: string | undefined;
    } & {
        vigilanteAddresses?: ({
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        } & {
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["vigilanteAddresses"], keyof CheckpointAddresses>, never>) | undefined;
        txsInfo?: ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        }[] & ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        } & {
            key?: ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["txsInfo"][number]["key"], keyof TransactionKey>, never>) | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["txsInfo"][number], keyof TransactionInfo>, never>)[] & Record<Exclude<keyof I["txsInfo"], keyof {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        }[]>, never>) | undefined;
        epoch?: string | undefined;
    } & Record<Exclude<keyof I, keyof SubmissionData>, never>>(object: I): SubmissionData;
};
export declare const EpochData: {
    encode(message: EpochData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EpochData;
    fromJSON(object: any): EpochData;
    toJSON(message: EpochData): unknown;
    fromPartial<I extends {
        keys?: {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            }[] | undefined;
        }[] | undefined;
        status?: BtcStatus | undefined;
    } & {
        keys?: ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            }[] | undefined;
        }[] & ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            }[] | undefined;
        } & {
            key?: ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            }[] & ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["keys"][number]["key"][number], keyof TransactionKey>, never>)[] & Record<Exclude<keyof I["keys"][number]["key"], keyof {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            }[]>, never>) | undefined;
        } & Record<Exclude<keyof I["keys"][number], "key">, never>)[] & Record<Exclude<keyof I["keys"], keyof {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            }[] | undefined;
        }[]>, never>) | undefined;
        status?: BtcStatus | undefined;
    } & Record<Exclude<keyof I, keyof EpochData>, never>>(object: I): EpochData;
};
export declare const CheckpointAddresses: {
    encode(message: CheckpointAddresses, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CheckpointAddresses;
    fromJSON(object: any): CheckpointAddresses;
    toJSON(message: CheckpointAddresses): unknown;
    fromPartial<I extends {
        submitter?: Uint8Array | undefined;
        reporter?: Uint8Array | undefined;
    } & {
        submitter?: Uint8Array | undefined;
        reporter?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof CheckpointAddresses>, never>>(object: I): CheckpointAddresses;
};
export declare const BTCCheckpointInfo: {
    encode(message: BTCCheckpointInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BTCCheckpointInfo;
    fromJSON(object: any): BTCCheckpointInfo;
    toJSON(message: BTCCheckpointInfo): unknown;
    fromPartial<I extends {
        epochNumber?: string | undefined;
        bestSubmissionBtcBlockHeight?: number | undefined;
        bestSubmissionBtcBlockHash?: Uint8Array | undefined;
        bestSubmissionTransactions?: {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        }[] | undefined;
        bestSubmissionVigilanteAddressList?: {
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        }[] | undefined;
    } & {
        epochNumber?: string | undefined;
        bestSubmissionBtcBlockHeight?: number | undefined;
        bestSubmissionBtcBlockHash?: Uint8Array | undefined;
        bestSubmissionTransactions?: ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        }[] & ({
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        } & {
            key?: ({
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } & Record<Exclude<keyof I["bestSubmissionTransactions"][number]["key"], keyof TransactionKey>, never>) | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["bestSubmissionTransactions"][number], keyof TransactionInfo>, never>)[] & Record<Exclude<keyof I["bestSubmissionTransactions"], keyof {
            key?: {
                index?: number | undefined;
                hash?: Uint8Array | undefined;
            } | undefined;
            transaction?: Uint8Array | undefined;
            proof?: Uint8Array | undefined;
        }[]>, never>) | undefined;
        bestSubmissionVigilanteAddressList?: ({
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        }[] & ({
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        } & {
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        } & Record<Exclude<keyof I["bestSubmissionVigilanteAddressList"][number], keyof CheckpointAddresses>, never>)[] & Record<Exclude<keyof I["bestSubmissionVigilanteAddressList"], keyof {
            submitter?: Uint8Array | undefined;
            reporter?: Uint8Array | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof BTCCheckpointInfo>, never>>(object: I): BTCCheckpointInfo;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
