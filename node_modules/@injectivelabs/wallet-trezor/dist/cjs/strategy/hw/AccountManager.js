"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hdkey_1 = __importDefault(require("hdkey"));
const exceptions_1 = require("@injectivelabs/exceptions");
const types_js_1 = require("../../types.js");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const trezor_connect_web_1 = require("@bangjelkoski/trezor-connect-web");
const addressOfHDKey = (hdKey) => {
    const shouldSanitizePublicKey = true;
    const derivedPublicKey = hdKey.publicKey;
    const ethereumAddressWithoutPrefix = Buffer.from((0, sdk_ts_1.publicKeyToAddress)(derivedPublicKey, shouldSanitizePublicKey)).toString('hex');
    const address = (0, sdk_ts_1.addHexPrefix)(ethereumAddressWithoutPrefix);
    return address;
};
class AccountManager {
    wallets = [];
    constructor() {
        this.wallets = [];
    }
    async getWallets(baseDerivationPath, derivationPathType) {
        const { start, end } = this.getOffset();
        /**
         * 1. Wallets are not yet fetched at all,
         * 2. Wallets are not yet fetched for that offset
         */
        if (!this.hasWallets() || !this.hasWalletsInOffset(start)) {
            await this.getWalletsBasedOnIndex({
                start,
                end,
                baseDerivationPath,
                derivationPathType,
            });
        }
        return this.wallets.slice(start, end);
    }
    getTrezorDerivationPathBasedOnType = ({ fullBaseDerivationPath, derivationPathType, index, }) => {
        if (derivationPathType === types_js_1.TrezorDerivationPathType.Bip44) {
            return `${fullBaseDerivationPath}/${index}'/0/0`;
        }
        if (derivationPathType === types_js_1.TrezorDerivationPathType.Legacy) {
            return `m/${index}`;
        }
        return `${fullBaseDerivationPath}/0'/0/${index}`;
    };
    async getWalletsBasedOnIndex({ start, end, baseDerivationPath, derivationPathType, }) {
        const pathsToFetch = [];
        for (let index = start; index < end; index += 1) {
            const path = this.getTrezorDerivationPathBasedOnType({
                fullBaseDerivationPath: baseDerivationPath,
                derivationPathType,
                index,
            });
            pathsToFetch.push({
                path,
                showOnTrezor: false,
            });
        }
        const result = await trezor_connect_web_1.TrezorConnect.ethereumGetPublicKey({
            bundle: pathsToFetch,
        });
        if (!result.success) {
            throw new exceptions_1.TrezorException(new Error((result.payload && result.payload.error) ||
                'Please make sure your Trezor is connected and unlocked'));
        }
        for (const item of result.payload) {
            const hdKey = new hdkey_1.default();
            hdKey.publicKey = Buffer.from(item.publicKey, 'hex');
            hdKey.chainCode = Buffer.from(item.chainCode, 'hex');
            const address = addressOfHDKey(hdKey);
            this.wallets.push({
                hdKey,
                derivationPath: item.serializedPath,
                address: address.toLowerCase(),
            });
        }
    }
    hasWallets() {
        return this.wallets.length > 0;
    }
    hasWalletsInOffset(offset) {
        return this.wallets.length > offset;
    }
    getOffset() {
        const totalWallets = this.wallets.length;
        const nextBatchStart = totalWallets;
        const nextBatchEnd = totalWallets + wallet_base_1.DEFAULT_NUM_ADDRESSES_TO_FETCH;
        return {
            start: nextBatchStart,
            end: nextBatchEnd,
        };
    }
    hasWalletForAddress(address) {
        return (this.wallets.find((wallet) => wallet.address.toLowerCase() === address.toLowerCase()) !== undefined);
    }
    async getWalletForAddress(address) {
        return this.wallets.find((wallet) => wallet.address.toLowerCase() === address.toLowerCase());
    }
    reset() {
        this.wallets = [];
    }
}
exports.default = AccountManager;
