"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable camelcase */
/* eslint-disable class-methods-use-this */
const ts_types_1 = require("@injectivelabs/ts-types");
const alchemy_sdk_1 = require("alchemy-sdk");
const ethereumjs_util_1 = require("ethereumjs-util");
const tx_1 = require("@ethereumjs/tx");
const common_1 = require("@ethereumjs/common");
const trezor_connect_web_1 = require("@bangjelkoski/trezor-connect-web");
const exceptions_1 = require("@injectivelabs/exceptions");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const index_js_1 = require("./hw/index.js");
const utils_js_1 = require("../utils.js");
const getNetworkFromChainId = (chainId) => {
    if (chainId === ts_types_1.EthereumChainId.Goerli) {
        return common_1.Chain.Goerli;
    }
    if (chainId === ts_types_1.EthereumChainId.Sepolia) {
        return common_1.Chain.Sepolia;
    }
    if (chainId === ts_types_1.EthereumChainId.Kovan) {
        return common_1.Chain.Goerli;
    }
    return common_1.Chain.Mainnet;
};
class TrezorBase extends wallet_base_1.BaseConcreteStrategy {
    baseDerivationPath;
    trezor;
    ethereumOptions;
    alchemy;
    derivationPathType;
    constructor(args) {
        super(args);
        this.baseDerivationPath = wallet_base_1.DEFAULT_BASE_DERIVATION_PATH;
        this.derivationPathType = args.derivationPathType;
        this.trezor = new index_js_1.TrezorTransportInit();
        this.ethereumOptions = args.ethereumOptions;
    }
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Hardware);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async disconnect() {
        return Promise.resolve();
    }
    async getAddresses() {
        const { baseDerivationPath, derivationPathType } = this;
        try {
            await this.trezor.connect();
            const accountManager = await this.trezor.getAccountManager();
            const wallets = await accountManager.getWallets(baseDerivationPath, derivationPathType);
            return wallets.map((k) => k.address);
        }
        catch (e) {
            throw new exceptions_1.TrezorException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(txData, args) {
        const signedTransaction = await this.signEvmTransaction(txData, args);
        try {
            const alchemy = await this.getAlchemy(args.ethereumChainId);
            const txReceipt = await alchemy.core.sendTransaction((0, ethereumjs_util_1.addHexPrefix)(signedTransaction.serialize().toString('hex')));
            return txReceipt.hash;
        }
        catch (e) {
            throw new exceptions_1.TrezorException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SendEvmTransaction,
            });
        }
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints.grpc within the options for using Ethereum native wallets'));
        }
        const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const object = JSON.parse(eip712json);
        const compatibleObject = {
            ...object,
            domain: {
                ...object.domain,
                chainId: object.domain.chainId,
                salt: '0',
            },
        };
        const dataWithHashes = (0, utils_js_1.transformTypedData)(compatibleObject);
        const { types: { EIP712Domain = [], ...otherTypes } = {}, message = {}, domain = {}, primaryType, domain_separator_hash, message_hash, } = dataWithHashes;
        try {
            await this.trezor.connect();
            const { derivationPath } = await this.getWalletForAddress(address);
            const response = await trezor_connect_web_1.TrezorConnect.ethereumSignTypedData({
                path: derivationPath,
                data: {
                    types: { EIP712Domain, ...otherTypes },
                    message,
                    domain,
                    primaryType,
                },
                message_hash,
                domain_separator_hash,
                metamask_v4_compat: true,
            });
            if (!response.success) {
                // noinspection ExceptionCaughtLocallyJS
                throw new Error((response.payload && response.payload.error) || 'Unknown error');
            }
            return response.payload.signature;
        }
        catch (e) {
            throw new exceptions_1.TrezorException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    async signArbitrary(signer, data) {
        try {
            await this.trezor.connect();
            const { derivationPath } = await this.getWalletForAddress(signer);
            const response = await trezor_connect_web_1.TrezorConnect.ethereumSignMessage({
                path: derivationPath,
                message: (0, sdk_ts_1.toUtf8)(data),
            });
            if (!response.success) {
                throw new Error((response.payload && response.payload.error) || 'Unknown error');
            }
            return response.payload.signature;
        }
        catch (e) {
            throw new exceptions_1.TrezorException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
    }
    async getEthereumChainId() {
        const alchemy = await this.getAlchemy();
        const alchemyProvider = await alchemy.config.getProvider();
        return alchemyProvider.network.chainId.toString();
    }
    async getEvmTransactionReceipt(txHash) {
        return Promise.resolve(txHash);
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async signEvmTransaction(txData, args) {
        const chainId = parseInt(args.ethereumChainId.toString(), 10);
        const alchemy = await this.getAlchemy(args.ethereumChainId);
        const nonce = await alchemy.core.getTransactionCount(args.address);
        const common = new common_1.Common({
            chain: getNetworkFromChainId(chainId),
            hardfork: common_1.Hardfork.London,
        });
        const eip1559TxData = {
            from: txData.from,
            data: txData.data,
            to: txData.to,
            nonce: (0, ethereumjs_util_1.addHexPrefix)(nonce.toString(16)),
            gas: (0, ethereumjs_util_1.addHexPrefix)(txData.gas),
            gasLimit: (0, ethereumjs_util_1.addHexPrefix)(txData.gas),
            maxFeePerGas: (0, ethereumjs_util_1.addHexPrefix)(txData.gasPrice || txData.maxFeePerGas),
            maxPriorityFeePerGas: (0, ethereumjs_util_1.addHexPrefix)(txData.maxPriorityFeePerGas || wallet_base_1.TIP_IN_GWEI.toString(16)),
        };
        const tx = tx_1.FeeMarketEIP1559Transaction.fromTxData(eip1559TxData, {
            common,
        });
        const transaction = {
            ...tx.toJSON(),
            chainId,
        };
        try {
            await this.trezor.connect();
            const { derivationPath } = await this.getWalletForAddress(args.address);
            const response = await trezor_connect_web_1.TrezorConnect.ethereumSignTransaction({
                path: derivationPath,
                transaction,
            });
            if (!response.success) {
                throw new exceptions_1.TrezorException(new Error((response.payload && response.payload.error) ||
                    'Something happened while signing with Trezor'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletError,
                    contextModule: wallet_base_1.WalletAction.SignEvmTransaction,
                });
            }
            const signedTxData = {
                ...eip1559TxData,
                v: `${response.payload.v}`,
                r: `${response.payload.r}`,
                s: `${response.payload.s}`,
            };
            return tx_1.FeeMarketEIP1559Transaction.fromTxData(signedTxData, {
                common,
            });
        }
        catch (e) {
            if (e instanceof exceptions_1.TrezorException) {
                throw e;
            }
            throw new exceptions_1.TrezorException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignEvmTransaction,
            });
        }
    }
    async getWalletForAddress(address) {
        const { baseDerivationPath, derivationPathType } = this;
        const accountManager = await this.trezor.getAccountManager();
        if (!accountManager.hasWalletForAddress(address)) {
            for (let i = 0; i < wallet_base_1.DEFAULT_ADDRESS_SEARCH_LIMIT / wallet_base_1.DEFAULT_NUM_ADDRESSES_TO_FETCH; i += 1) {
                await accountManager.getWallets(baseDerivationPath, derivationPathType);
                if (accountManager.hasWalletForAddress(address)) {
                    return (await accountManager.getWalletForAddress(address));
                }
            }
        }
        return (await accountManager.getWalletForAddress(address));
    }
    async getAlchemy(ethereumChainId) {
        if (this.alchemy) {
            return this.alchemy;
        }
        const options = this.ethereumOptions;
        const chainId = ethereumChainId || options.ethereumChainId;
        const url = options.rpcUrl || options.rpcUrls?.[chainId];
        if (!url) {
            throw new exceptions_1.GeneralException(new Error('Please pass rpcUrl within the ethereumOptions'));
        }
        this.alchemy = new alchemy_sdk_1.Alchemy({
            apiKey: (0, wallet_base_1.getKeyFromRpcUrl)(url),
            network: chainId === ts_types_1.EthereumChainId.Mainnet
                ? alchemy_sdk_1.Network.ETH_MAINNET
                : alchemy_sdk_1.Network.ETH_SEPOLIA,
        });
        return this.alchemy;
    }
}
exports.default = TrezorBase;
