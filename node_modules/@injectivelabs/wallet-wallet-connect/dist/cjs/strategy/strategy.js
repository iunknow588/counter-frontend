"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnect = void 0;
/* eslint-disable class-methods-use-this */
const exceptions_1 = require("@injectivelabs/exceptions");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const wc_ethereum_provider_1 = require("@bangjelkoski/wc-ethereum-provider");
const ts_types_1 = require("@injectivelabs/ts-types");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const WalletConnectIds = {
    FireBlocks: '5864e2ced7c293ed18ac35e0db085c09ed567d67346ccb6f58a0327a75137489',
};
class WalletConnect extends wallet_base_1.BaseConcreteStrategy {
    provider;
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Browser);
    }
    async enable(args) {
        await this.connectWalletConnect(args?.topic);
        return Promise.resolve(true);
    }
    async disconnect() {
        if (this.listeners[wallet_base_1.WalletEventListener.AccountChange]) {
            const wc = await this.getConnectedWalletConnect();
            wc.removeListener('accountsChanged', this.listeners[wallet_base_1.WalletEventListener.AccountChange]);
        }
        if (this.listeners[wallet_base_1.WalletEventListener.ChainIdChange]) {
            const wc = await this.getConnectedWalletConnect();
            wc.removeListener('chainChanged', this.listeners[wallet_base_1.WalletEventListener.ChainIdChange]);
        }
        this.listeners = {};
        if (this.provider) {
            await this.provider.disconnect();
            this.provider = undefined;
        }
    }
    async getAddresses() {
        const wc = await this.getConnectedWalletConnect();
        try {
            return await wc.request({
                method: 'eth_requestAccounts',
            });
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(_address) {
        const wc = await this.getConnectedWalletConnect();
        return wc.session?.topic || '';
    }
    async sendEvmTransaction(transaction, _options) {
        const wc = await this.getConnectedWalletConnect();
        try {
            return await wc.request({
                method: 'eth_sendTransaction',
                params: [transaction],
            });
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SendEvmTransaction,
            });
        }
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints within the options for using Ethereum native wallets'));
        }
        const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const wc = await this.getConnectedWalletConnect();
        try {
            return await wc.request({
                method: 'eth_signTypedData_v4',
                params: [address, eip712json],
            });
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async signArbitrary(signer, data) {
        const wc = await this.getConnectedWalletConnect();
        try {
            const signature = await wc.request({
                method: 'personal_sign',
                params: [(0, sdk_ts_1.toUtf8)(data), signer],
            });
            return signature;
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        const wc = await this.getConnectedWalletConnect();
        try {
            return wc.request({ method: 'eth_chainId' });
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetChainId,
            });
        }
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support awaiting Ethereum transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.GetEvmTransactionReceipt,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async onChainIdChanged(callback) {
        const wc = await this.getConnectedWalletConnect();
        this.listeners = {
            [wallet_base_1.WalletEventListener.ChainIdChange]: callback,
        };
        wc.on('chainChanged', callback);
    }
    async onAccountChange(callback) {
        const wc = await this.getConnectedWalletConnect();
        this.listeners = {
            [wallet_base_1.WalletEventListener.AccountChange]: callback,
        };
        wc.on('accountsChanged', (accounts) => callback(accounts[0]));
    }
    async getWalletConnect() {
        if (this.provider) {
            return this.provider;
        }
        if (!this.metadata?.walletConnect) {
            throw new exceptions_1.WalletException(new Error('Please provide metadata for WalletConnect'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
        if (!this.metadata.walletConnect.projectId) {
            throw new exceptions_1.WalletException(new Error('Please provide projectId alongside the metadata for WalletConnect'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
        try {
            this.provider = await wc_ethereum_provider_1.EthereumProvider.init({
                projectId: this.metadata.walletConnect.projectId,
                metadata: this
                    .metadata,
                showQrModal: true,
                optionalChains: this.ethereumChainId
                    ? [this.ethereumChainId]
                    : [ts_types_1.EthereumChainId.Mainnet, ts_types_1.EthereumChainId.Sepolia],
                qrModalOptions: {
                    explorerRecommendedWalletIds: [WalletConnectIds.FireBlocks],
                    explorerExcludedWalletIds: 'ALL',
                    mobileWallets: [],
                    walletImages: {
                        [WalletConnectIds.FireBlocks]: '/wallet-connect/fireblocks.webp',
                    },
                    desktopWallets: [
                        {
                            id: WalletConnectIds.FireBlocks,
                            name: 'Fireblocks',
                            links: {
                                native: 'fireblocks-wc://',
                                universal: 'https://console.fireblocks.io/v2/',
                            },
                        },
                    ],
                },
            });
            return this.provider;
        }
        catch (e) {
            throw new exceptions_1.WalletException(new Error('WalletConnect not supported for this wallet'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getConnectedWalletConnect() {
        if (!this.provider) {
            await this.getWalletConnect();
        }
        if (!this.provider?.connected) {
            await this.enable();
        }
        return this.provider;
    }
    async connectWalletConnect(topic) {
        if (this.provider && this.provider.connected) {
            return;
        }
        const wc = await this.getWalletConnect();
        await wc.connect({
            ...(topic && { pairingTopic: topic }),
        });
    }
}
exports.WalletConnect = WalletConnect;
