"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Magic = void 0;
/* eslint-disable class-methods-use-this */
const exceptions_1 = require("@injectivelabs/exceptions");
const magic_sdk_1 = require("magic-sdk");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const oauth2_1 = require("@magic-ext/oauth2");
const cosmos_1 = require("@magic-ext/cosmos");
const wallet_base_1 = require("@injectivelabs/wallet-base");
class Magic extends wallet_base_1.BaseConcreteStrategy {
    provider;
    magicWallet;
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Browser);
    }
    async enable({ email, provider, }) {
        if (!provider) {
            return Promise.resolve(true);
        }
        try {
            if (provider === wallet_base_1.MagicProvider.Email) {
                await this.connectViaEmail(email);
            }
            else {
                await this.connectViaOauth(provider);
            }
            await this.pollUserLoggedInState();
            return Promise.resolve(true);
        }
        catch (e) {
            throw new exceptions_1.WalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async connectViaEmail(email) {
        const magicWallet = await this.getMagicWallet();
        if (!email) {
            throw new exceptions_1.WalletException(new Error('You have to pass the email for using Magic wallet'));
        }
        return magicWallet.auth.loginWithMagicLink({ email });
    }
    async connectViaOauth(provider) {
        const magicWallet = await this.getMagicWallet();
        return magicWallet.oauth2.loginWithRedirect({
            provider: provider,
            redirectURI: window.location.origin,
        });
    }
    async disconnect() {
        const magicWallet = await this.getMagicWallet();
        const isUserLoggedIn = await magicWallet.user.isLoggedIn();
        if (!isUserLoggedIn) {
            return;
        }
        await magicWallet.user.logout();
    }
    async getAddresses({ provider, }) {
        const magicWallet = await this.getMagicWallet();
        if (!provider) {
            try {
                await magicWallet.oauth2.getRedirectResult();
            }
            catch {
                // fail silently
            }
        }
        try {
            const { publicAddress } = await magicWallet.user.getInfo();
            if (!publicAddress?.startsWith('inj')) {
                const address = await magicWallet.cosmos.changeAddress('inj');
                return [address || ''];
            }
            return [publicAddress || ''];
        }
        catch (e) {
            throw new exceptions_1.WalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(_transaction, _options) {
        throw new exceptions_1.CosmosWalletException(new Error('sendEvmTransaction is not supported. Leap only supports sending cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints.grpc within the options for using Magic wallet'));
        }
        const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, _address) {
        const magicWallet = await this.getMagicWallet();
        const signature = await magicWallet.cosmos.signTypedData(eip712json);
        return `0x${signature}`;
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signAminoCosmosTransaction'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async signArbitrary(_signer, _data) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signArbitrary'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async getEthereumChainId() {
        throw new exceptions_1.CosmosWalletException(new Error('getEthereumChainId is not supported on Magic wallet'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.GetChainId,
        });
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new exceptions_1.CosmosWalletException(new Error('getEvmTransactionReceipt is not supported on Cosmostation'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            context: wallet_base_1.WalletAction.GetEvmTransactionReceipt,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async pollUserLoggedInState(timeout = 60 * 1000) {
        const magicWallet = await this.getMagicWallet();
        const POLL_INTERVAL = 3 * 1000;
        for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
            try {
                const result = await magicWallet.user.isLoggedIn();
                if (result) {
                    return result;
                }
            }
            catch (e) {
                // We throw only if the transaction failed on chain
                if (e instanceof exceptions_1.TransactionException) {
                    throw e;
                }
            }
            await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
        }
        // Transaction was not included in the block in the desired timeout
        throw new exceptions_1.WalletException(new Error(`User did not verify sign in - timeout of ${timeout}ms`), {
            context: 'Wallet',
            contextModule: 'Magic-Wallet-pollUserLoggedInState',
        });
    }
    async getMagicWallet() {
        const { metadata } = this;
        if (!this.magicWallet) {
            if (!metadata?.magic?.apiKey) {
                throw new exceptions_1.WalletException(new Error('You have to pass the apiKey within metadata to use Magic wallet'));
            }
            if (!metadata?.magic?.rpcEndpoint) {
                throw new exceptions_1.WalletException(new Error('You have to pass the rpc url endpoint within metadata to use Magic wallet'));
            }
            this.magicWallet = new magic_sdk_1.Magic(metadata.magic.apiKey, {
                extensions: [
                    new oauth2_1.OAuthExtension(),
                    new cosmos_1.CosmosExtension({
                        rpcUrl: metadata.magic.rpcEndpoint,
                        chain: 'inj',
                    }),
                ],
            });
        }
        return this.magicWallet;
    }
}
exports.Magic = Magic;
