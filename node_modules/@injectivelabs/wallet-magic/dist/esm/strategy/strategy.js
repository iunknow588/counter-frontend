/* eslint-disable class-methods-use-this */
import { ErrorType, WalletException, UnspecifiedErrorCode, TransactionException, CosmosWalletException, } from '@injectivelabs/exceptions';
import { Magic as MagicWallet } from 'magic-sdk';
import { TxGrpcApi, } from '@injectivelabs/sdk-ts';
import { OAuthExtension } from '@magic-ext/oauth2';
import { CosmosExtension } from '@magic-ext/cosmos';
import { WalletAction, MagicProvider, WalletDeviceType, BaseConcreteStrategy, } from '@injectivelabs/wallet-base';
export class Magic extends BaseConcreteStrategy {
    provider;
    magicWallet;
    async getWalletDeviceType() {
        return Promise.resolve(WalletDeviceType.Browser);
    }
    async enable({ email, provider, }) {
        if (!provider) {
            return Promise.resolve(true);
        }
        try {
            if (provider === MagicProvider.Email) {
                await this.connectViaEmail(email);
            }
            else {
                await this.connectViaOauth(provider);
            }
            await this.pollUserLoggedInState();
            return Promise.resolve(true);
        }
        catch (e) {
            throw new WalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.GetAccounts,
            });
        }
    }
    async connectViaEmail(email) {
        const magicWallet = await this.getMagicWallet();
        if (!email) {
            throw new WalletException(new Error('You have to pass the email for using Magic wallet'));
        }
        return magicWallet.auth.loginWithMagicLink({ email });
    }
    async connectViaOauth(provider) {
        const magicWallet = await this.getMagicWallet();
        return magicWallet.oauth2.loginWithRedirect({
            provider: provider,
            redirectURI: window.location.origin,
        });
    }
    async disconnect() {
        const magicWallet = await this.getMagicWallet();
        const isUserLoggedIn = await magicWallet.user.isLoggedIn();
        if (!isUserLoggedIn) {
            return;
        }
        await magicWallet.user.logout();
    }
    async getAddresses({ provider, }) {
        const magicWallet = await this.getMagicWallet();
        if (!provider) {
            try {
                await magicWallet.oauth2.getRedirectResult();
            }
            catch {
                // fail silently
            }
        }
        try {
            const { publicAddress } = await magicWallet.user.getInfo();
            if (!publicAddress?.startsWith('inj')) {
                const address = await magicWallet.cosmos.changeAddress('inj');
                return [address || ''];
            }
            return [publicAddress || ''];
        }
        catch (e) {
            throw new WalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.GetAccounts,
            });
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(_transaction, _options) {
        throw new CosmosWalletException(new Error('sendEvmTransaction is not supported. Leap only supports sending cosmos transactions'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new WalletException(new Error('You have to pass endpoints.grpc within the options for using Magic wallet'));
        }
        const txApi = new TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new TransactionException(new Error(response.rawLog), {
                code: UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, _address) {
        const magicWallet = await this.getMagicWallet();
        const signature = await magicWallet.cosmos.signTypedData(eip712json);
        return `0x${signature}`;
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            contextModule: WalletAction.SignTransaction,
        });
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new WalletException(new Error('This wallet does not support signAminoCosmosTransaction'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            contextModule: WalletAction.SignTransaction,
        });
    }
    async signArbitrary(_signer, _data) {
        throw new WalletException(new Error('This wallet does not support signArbitrary'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            contextModule: WalletAction.SignTransaction,
        });
    }
    async getEthereumChainId() {
        throw new CosmosWalletException(new Error('getEthereumChainId is not supported on Magic wallet'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.GetChainId,
        });
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new CosmosWalletException(new Error('getEvmTransactionReceipt is not supported on Cosmostation'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            context: WalletAction.GetEvmTransactionReceipt,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async pollUserLoggedInState(timeout = 60 * 1000) {
        const magicWallet = await this.getMagicWallet();
        const POLL_INTERVAL = 3 * 1000;
        for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
            try {
                const result = await magicWallet.user.isLoggedIn();
                if (result) {
                    return result;
                }
            }
            catch (e) {
                // We throw only if the transaction failed on chain
                if (e instanceof TransactionException) {
                    throw e;
                }
            }
            await new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
        }
        // Transaction was not included in the block in the desired timeout
        throw new WalletException(new Error(`User did not verify sign in - timeout of ${timeout}ms`), {
            context: 'Wallet',
            contextModule: 'Magic-Wallet-pollUserLoggedInState',
        });
    }
    async getMagicWallet() {
        const { metadata } = this;
        if (!this.magicWallet) {
            if (!metadata?.magic?.apiKey) {
                throw new WalletException(new Error('You have to pass the apiKey within metadata to use Magic wallet'));
            }
            if (!metadata?.magic?.rpcEndpoint) {
                throw new WalletException(new Error('You have to pass the rpc url endpoint within metadata to use Magic wallet'));
            }
            this.magicWallet = new MagicWallet(metadata.magic.apiKey, {
                extensions: [
                    new OAuthExtension(),
                    new CosmosExtension({
                        rpcUrl: metadata.magic.rpcEndpoint,
                        chain: 'inj',
                    }),
                ],
            });
        }
        return this.magicWallet;
    }
}
