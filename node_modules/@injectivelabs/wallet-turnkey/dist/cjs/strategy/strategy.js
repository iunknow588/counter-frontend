"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TurnkeyWalletStrategy = void 0;
/* eslint-disable class-methods-use-this */
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const exceptions_1 = require("@injectivelabs/exceptions");
const viem_1 = require("viem");
const utils_1 = require("@injectivelabs/utils");
const viem_2 = require("viem");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const types_js_1 = require("./types.js");
const turnkey_js_1 = require("./turnkey/turnkey.js");
const consts_js_1 = require("./consts.js");
class TurnkeyWalletStrategy extends wallet_base_1.BaseConcreteStrategy {
    turnkeyWallet;
    ethereumOptions;
    client;
    constructor(args) {
        super(args);
        const endpoint = args.apiServerEndpoint || this.metadata?.turnkey?.apiServerEndpoint;
        if (!endpoint) {
            throw new exceptions_1.WalletException(new Error('apiServerEndpoint is required'));
        }
        this.client = new utils_1.HttpRestClient(endpoint);
        this.ethereumOptions = args.ethereumOptions;
    }
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Browser);
    }
    setMetadata(metadata) {
        if (metadata?.turnkey) {
            this.metadata = {
                ...this.metadata,
                turnkey: {
                    ...this.metadata?.turnkey,
                    ...metadata.turnkey,
                },
            };
            this.turnkeyWallet?.setMetadata(this.metadata?.turnkey);
        }
    }
    async enable() {
        const turnkeyWallet = await this.getTurnkeyWallet();
        try {
            const session = await turnkeyWallet.getSession();
            if (session.session) {
                // User is already logged in, we don't need to do anything in the next steps
                if (this.metadata?.turnkey) {
                    this.metadata.turnkey.session = session.session;
                }
                return true;
            }
            return !!(await turnkeyWallet.getIframeClient());
        }
        catch (e) {
            return false;
        }
    }
    async disconnect() {
        const turnkeyWallet = await this.getTurnkeyWallet();
        const turnkey = await turnkeyWallet.getTurnkey();
        const isUserLoggedIn = await turnkey.getSession();
        if (!isUserLoggedIn) {
            return;
        }
        await turnkey.logout();
    }
    async getAddresses() {
        const turnkeyWallet = await this.getTurnkeyWallet();
        await turnkeyWallet.getSession();
        try {
            return await turnkeyWallet.getAccounts();
        }
        catch (e) {
            if (e.contextCode === types_js_1.TurnkeyErrorCodes.UserLoggedOut) {
                await this.disconnect();
                throw e;
            }
            throw new exceptions_1.WalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(_address) {
        const turnkeyWallet = await this.getTurnkeyWallet();
        return await turnkeyWallet.refreshSession();
    }
    async getWalletClient() {
        return (await this.getTurnkeyWallet());
    }
    async sendEvmTransaction(transaction, args) {
        try {
            const options = this.ethereumOptions;
            const turnkeyWallet = await this.getTurnkeyWallet();
            const organizationId = await this.getOrganizationId();
            const chainId = args.ethereumChainId || options.ethereumChainId;
            const url = options.rpcUrl || options.rpcUrls?.[args.ethereumChainId];
            if (!url) {
                throw new exceptions_1.WalletException(new Error('Please pass rpcUrl within the ethereumOptions'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    context: wallet_base_1.WalletAction.SendEvmTransaction,
                });
            }
            const account = await turnkeyWallet.getOrCreateAndGetAccount((0, viem_1.getAddress)(args.address), organizationId);
            const accountClient = (0, viem_2.createWalletClient)({
                account: account,
                chain: {
                    ...consts_js_1.DEFAULT_EVM_CHAIN_CONFIG,
                    id: chainId,
                    rpcUrls: {
                        default: {
                            http: [url],
                        },
                    },
                },
                transport: (0, viem_2.http)(url),
            });
            const preparedTransaction = await accountClient.prepareTransactionRequest(transaction);
            delete preparedTransaction.account;
            const signedTransaction = await accountClient.signTransaction(preparedTransaction);
            const tx = await accountClient.sendRawTransaction({
                serializedTransaction: signedTransaction,
            });
            return tx;
        }
        catch (e) {
            throw new exceptions_1.WalletException(e, {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SendEvmTransaction,
            });
        }
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints.grpc within the options for using Turnkey wallet'));
        }
        const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const turnkeyWallet = await this.getTurnkeyWallet();
        const organizationId = await this.getOrganizationId();
        //? Turnkey expects the case sensitive address and the current impl of getChecksumAddress from sdk-ts doesn't play nice with browser envs
        const checksumAddress = (0, viem_1.getAddress)(address);
        const account = await turnkeyWallet.getOrCreateAndGetAccount(checksumAddress, organizationId);
        if (!account) {
            throw new exceptions_1.WalletException(new Error('Turnkey account not found'));
        }
        let parsedData;
        try {
            parsedData = JSON.parse(eip712json);
        }
        catch (e) {
            throw new exceptions_1.WalletException(new Error('Failed to parse EIP-712 data: Invalid JSON format'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
        const signature = await account.signTypedData(parsedData);
        return signature;
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signAminoCosmosTransaction'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async signArbitrary(_signer, _data) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signArbitrary'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async getEthereumChainId() {
        throw new exceptions_1.CosmosWalletException(new Error('getEthereumChainId is not supported on Turnkey wallet'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.GetChainId,
        });
    }
    async getEvmTransactionReceipt(txHash, ethereumChainId) {
        const options = this.ethereumOptions;
        const maxAttempts = 10;
        const interval = 3000;
        const chainId = ethereumChainId || options.ethereumChainId;
        const url = options.rpcUrl || options.rpcUrls?.[chainId];
        if (!url) {
            throw new exceptions_1.WalletException(new Error('Please pass rpcUrl within the ethereumOptions'), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.GetEvmTransactionReceipt,
            });
        }
        const publicClient = (0, viem_2.createPublicClient)({
            chain: {
                ...consts_js_1.DEFAULT_EVM_CHAIN_CONFIG,
                id: chainId,
                rpcUrls: {
                    default: {
                        http: [url],
                    },
                },
            },
            transport: (0, viem_2.http)(url),
        });
        let attempts = 0;
        while (attempts < maxAttempts) {
            attempts++;
            await (0, utils_1.sleep)(interval);
            try {
                const receipt = await publicClient.getTransactionReceipt({
                    hash: txHash,
                });
                if (receipt) {
                    return receipt;
                }
            }
            catch { }
        }
        throw new Error(`Failed to retrieve transaction receipt for txHash: ${txHash}`);
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async getIframeClient() {
        const turnkeyWallet = await this.getTurnkeyWallet();
        return turnkeyWallet.getIframeClient();
    }
    async getTurnkeyWallet() {
        const { metadata } = this;
        if (!this.turnkeyWallet) {
            if (!metadata?.turnkey) {
                throw new exceptions_1.WalletException(new Error('Turnkey metadata is required'));
            }
            if (!metadata.turnkey.apiBaseUrl) {
                throw new exceptions_1.WalletException(new Error('Turnkey apiBaseUrl is required'));
            }
            if (!metadata.turnkey.apiServerEndpoint) {
                throw new exceptions_1.WalletException(new Error('Turnkey apiServerEndpoint is required'));
            }
            if (!metadata.turnkey.defaultOrganizationId) {
                throw new exceptions_1.WalletException(new Error('Turnkey defaultOrganizationId is required'));
            }
            this.turnkeyWallet = new turnkey_js_1.TurnkeyWallet(metadata.turnkey);
        }
        return this.turnkeyWallet;
    }
    async getOrganizationId() {
        const { metadata } = this;
        const organizationId = metadata?.turnkey?.organizationId ||
            metadata?.turnkey?.defaultOrganizationId;
        if (!organizationId) {
            throw new exceptions_1.WalletException(new Error('Organization ID is required'));
        }
        return organizationId;
    }
}
exports.TurnkeyWalletStrategy = TurnkeyWalletStrategy;
