/* eslint-disable class-methods-use-this */
import { toUtf8, createTxRawFromSigResponse, createSignDocFromTransaction, } from '@injectivelabs/sdk-ts';
import { CosmosChainId, } from '@injectivelabs/ts-types';
import { ErrorType, UnspecifiedErrorCode, CosmosWalletException, TransactionException, } from '@injectivelabs/exceptions';
import { WalletAction, WalletDeviceType, BaseConcreteStrategy, } from '@injectivelabs/wallet-base';
import { CosmosTxV1Beta1Tx } from '@injectivelabs/sdk-ts';
import { InstallError } from '@cosmostation/extension-client';
import { makeSignDoc } from '@cosmjs/proto-signing';
import { SEND_TRANSACTION_MODE } from '@cosmostation/extension-client/cosmos.js';
import { CosmostationWallet } from './../wallet.js';
const getChainNameFromChainId = (chainId) => {
    const [chainName] = chainId.split('-');
    if (chainName.includes('cosmoshub')) {
        return 'cosmos';
    }
    if (chainName.includes('core')) {
        return 'persistence';
    }
    if (chainName.includes('evmos')) {
        return 'evmos';
    }
    if (chainId.includes('ssc') || chainId.includes('fetch')) {
        return chainId;
    }
    return chainName;
};
export class Cosmostation extends BaseConcreteStrategy {
    cosmostationWallet;
    chainName;
    constructor(args) {
        super(args);
        this.chainId = args.chainId || CosmosChainId.Injective;
        this.chainName = getChainNameFromChainId(this.chainId);
    }
    async getWalletDeviceType() {
        return Promise.resolve(WalletDeviceType.Browser);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async getAddresses() {
        const cosmostationWallet = await this.getCosmostationWallet();
        try {
            const accounts = await cosmostationWallet.requestAccount(this.chainName);
            return [accounts.address];
        }
        catch (e) {
            if (e.code === 4001) {
                throw new CosmosWalletException(new Error('The user rejected the request'), {
                    code: UnspecifiedErrorCode,
                    context: WalletAction.GetAccounts,
                });
            }
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    // eslint-disable-next-line class-methods-use-this
    async sendEvmTransaction(_transaction, _options) {
        throw new CosmosWalletException(new Error('sendEvmTransaction is not supported. Cosmostation only supports sending cosmos transactions'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, _options) {
        const cosmostationWallet = await this.getCosmostationWallet();
        const txRaw = createTxRawFromSigResponse(transaction);
        try {
            const response = await cosmostationWallet.sendTransaction(this.chainName, CosmosTxV1Beta1Tx.TxRaw.encode(txRaw).finish(), SEND_TRANSACTION_MODE.SYNC);
            return {
                ...response.tx_response,
                gasUsed: parseInt((response.tx_response.gas_used || '0'), 10),
                gasWanted: parseInt((response.tx_response.gas_wanted || '0'), 10),
                height: parseInt((response.tx_response.height || '0'), 10),
                txHash: response.tx_response.txhash,
                rawLog: response.tx_response.raw_log,
            };
        }
        catch (e) {
            if (e instanceof TransactionException) {
                throw e;
            }
            throw new TransactionException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.SendTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new CosmosWalletException(new Error('This wallet does not support signing using amino'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendTransaction,
        });
    }
    async signCosmosTransaction(transaction) {
        const { chainId } = this;
        const cosmostationWallet = await this.getCosmostationWallet();
        const signDoc = createSignDocFromTransaction(transaction);
        try {
            /* Sign the transaction */
            const signDirectResponse = await cosmostationWallet.signDirect(this.chainName, {
                chain_id: chainId,
                body_bytes: signDoc.bodyBytes,
                auth_info_bytes: signDoc.authInfoBytes,
                account_number: signDoc.accountNumber.toString(),
            }, { fee: true, memo: true });
            return {
                signed: makeSignDoc(signDirectResponse.signed_doc.body_bytes, signDirectResponse.signed_doc.auth_info_bytes, signDirectResponse.signed_doc.chain_id, parseInt(signDirectResponse.signed_doc.account_number, 10)),
                signature: {
                    signature: signDirectResponse.signature,
                },
            };
        }
        catch (e) {
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.SendTransaction,
            });
        }
    }
    async getPubKey() {
        const cosmostationWallet = await this.getCosmostationWallet();
        try {
            const account = await cosmostationWallet.requestAccount(this.chainName);
            return Buffer.from(account.publicKey).toString('base64');
        }
        catch (e) {
            if (e.code === 4001) {
                throw new CosmosWalletException(new Error('The user rejected the request'), {
                    code: UnspecifiedErrorCode,
                    context: WalletAction.GetAccounts,
                });
            }
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.GetAccounts,
            });
        }
    }
    async signEip712TypedData(_eip712TypedData, _address) {
        throw new CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendTransaction,
        });
    }
    async signArbitrary(signer, data) {
        try {
            const cosmostationWallet = await this.getCosmostationWallet();
            const signature = await cosmostationWallet.signMessage(this.chainName, signer, toUtf8(data));
            return signature.signature;
        }
        catch (e) {
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        throw new CosmosWalletException(new Error('getEthereumChainId is not supported on Cosmostation'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.GetChainId,
        });
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new CosmosWalletException(new Error('getEvmTransactionReceipt is not supported on Cosmostation'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            context: WalletAction.GetEvmTransactionReceipt,
        });
    }
    async getCosmostationWallet() {
        if (this.cosmostationWallet) {
            return this.cosmostationWallet;
        }
        const cosmostationWallet = new CosmostationWallet(this.chainId);
        try {
            const provider = await cosmostationWallet.getCosmostationWallet();
            this.cosmostationWallet = provider;
            return provider;
        }
        catch (e) {
            if (e instanceof InstallError) {
                throw new CosmosWalletException(new Error('Please install the Cosmostation extension'), {
                    code: UnspecifiedErrorCode,
                    type: ErrorType.WalletNotInstalledError,
                });
            }
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
            });
        }
    }
}
