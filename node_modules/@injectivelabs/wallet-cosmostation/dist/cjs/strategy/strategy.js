"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cosmostation = void 0;
/* eslint-disable class-methods-use-this */
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const ts_types_1 = require("@injectivelabs/ts-types");
const exceptions_1 = require("@injectivelabs/exceptions");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const sdk_ts_2 = require("@injectivelabs/sdk-ts");
const extension_client_1 = require("@cosmostation/extension-client");
const proto_signing_1 = require("@cosmjs/proto-signing");
const cosmos_js_1 = require("@cosmostation/extension-client/cosmos.js");
const wallet_js_1 = require("./../wallet.js");
const getChainNameFromChainId = (chainId) => {
    const [chainName] = chainId.split('-');
    if (chainName.includes('cosmoshub')) {
        return 'cosmos';
    }
    if (chainName.includes('core')) {
        return 'persistence';
    }
    if (chainName.includes('evmos')) {
        return 'evmos';
    }
    if (chainId.includes('ssc') || chainId.includes('fetch')) {
        return chainId;
    }
    return chainName;
};
class Cosmostation extends wallet_base_1.BaseConcreteStrategy {
    cosmostationWallet;
    chainName;
    constructor(args) {
        super(args);
        this.chainId = args.chainId || ts_types_1.CosmosChainId.Injective;
        this.chainName = getChainNameFromChainId(this.chainId);
    }
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Browser);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async getAddresses() {
        const cosmostationWallet = await this.getCosmostationWallet();
        try {
            const accounts = await cosmostationWallet.requestAccount(this.chainName);
            return [accounts.address];
        }
        catch (e) {
            if (e.code === 4001) {
                throw new exceptions_1.CosmosWalletException(new Error('The user rejected the request'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    context: wallet_base_1.WalletAction.GetAccounts,
                });
            }
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    // eslint-disable-next-line class-methods-use-this
    async sendEvmTransaction(_transaction, _options) {
        throw new exceptions_1.CosmosWalletException(new Error('sendEvmTransaction is not supported. Cosmostation only supports sending cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, _options) {
        const cosmostationWallet = await this.getCosmostationWallet();
        const txRaw = (0, sdk_ts_1.createTxRawFromSigResponse)(transaction);
        try {
            const response = await cosmostationWallet.sendTransaction(this.chainName, sdk_ts_2.CosmosTxV1Beta1Tx.TxRaw.encode(txRaw).finish(), cosmos_js_1.SEND_TRANSACTION_MODE.SYNC);
            return {
                ...response.tx_response,
                gasUsed: parseInt((response.tx_response.gas_used || '0'), 10),
                gasWanted: parseInt((response.tx_response.gas_wanted || '0'), 10),
                height: parseInt((response.tx_response.height || '0'), 10),
                txHash: response.tx_response.txhash,
                rawLog: response.tx_response.raw_log,
            };
        }
        catch (e) {
            if (e instanceof exceptions_1.TransactionException) {
                throw e;
            }
            throw new exceptions_1.TransactionException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SendTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.CosmosWalletException(new Error('This wallet does not support signing using amino'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    async signCosmosTransaction(transaction) {
        const { chainId } = this;
        const cosmostationWallet = await this.getCosmostationWallet();
        const signDoc = (0, sdk_ts_1.createSignDocFromTransaction)(transaction);
        try {
            /* Sign the transaction */
            const signDirectResponse = await cosmostationWallet.signDirect(this.chainName, {
                chain_id: chainId,
                body_bytes: signDoc.bodyBytes,
                auth_info_bytes: signDoc.authInfoBytes,
                account_number: signDoc.accountNumber.toString(),
            }, { fee: true, memo: true });
            return {
                signed: (0, proto_signing_1.makeSignDoc)(signDirectResponse.signed_doc.body_bytes, signDirectResponse.signed_doc.auth_info_bytes, signDirectResponse.signed_doc.chain_id, parseInt(signDirectResponse.signed_doc.account_number, 10)),
                signature: {
                    signature: signDirectResponse.signature,
                },
            };
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SendTransaction,
            });
        }
    }
    async getPubKey() {
        const cosmostationWallet = await this.getCosmostationWallet();
        try {
            const account = await cosmostationWallet.requestAccount(this.chainName);
            return Buffer.from(account.publicKey).toString('base64');
        }
        catch (e) {
            if (e.code === 4001) {
                throw new exceptions_1.CosmosWalletException(new Error('The user rejected the request'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    context: wallet_base_1.WalletAction.GetAccounts,
                });
            }
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async signEip712TypedData(_eip712TypedData, _address) {
        throw new exceptions_1.CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    async signArbitrary(signer, data) {
        try {
            const cosmostationWallet = await this.getCosmostationWallet();
            const signature = await cosmostationWallet.signMessage(this.chainName, signer, (0, sdk_ts_1.toUtf8)(data));
            return signature.signature;
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        throw new exceptions_1.CosmosWalletException(new Error('getEthereumChainId is not supported on Cosmostation'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.GetChainId,
        });
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new exceptions_1.CosmosWalletException(new Error('getEvmTransactionReceipt is not supported on Cosmostation'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            context: wallet_base_1.WalletAction.GetEvmTransactionReceipt,
        });
    }
    async getCosmostationWallet() {
        if (this.cosmostationWallet) {
            return this.cosmostationWallet;
        }
        const cosmostationWallet = new wallet_js_1.CosmostationWallet(this.chainId);
        try {
            const provider = await cosmostationWallet.getCosmostationWallet();
            this.cosmostationWallet = provider;
            return provider;
        }
        catch (e) {
            if (e instanceof extension_client_1.InstallError) {
                throw new exceptions_1.CosmosWalletException(new Error('Please install the Cosmostation extension'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletNotInstalledError,
                });
            }
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
            });
        }
    }
}
exports.Cosmostation = Cosmostation;
