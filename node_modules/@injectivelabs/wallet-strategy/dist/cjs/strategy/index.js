"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStrategyFactory = exports.WalletStrategy = void 0;
const wallet_base_1 = require("@injectivelabs/wallet-base");
const wallet_ledger_1 = require("@injectivelabs/wallet-ledger");
const wallet_magic_1 = require("@injectivelabs/wallet-magic");
const wallet_evm_1 = require("@injectivelabs/wallet-evm");
const wallet_core_1 = require("@injectivelabs/wallet-core");
const wallet_cosmos_1 = require("@injectivelabs/wallet-cosmos");
const wallet_trezor_1 = require("@injectivelabs/wallet-trezor");
const wallet_turnkey_1 = require("@injectivelabs/wallet-turnkey");
const wallet_wallet_connect_1 = require("@injectivelabs/wallet-wallet-connect");
const wallet_private_key_1 = require("@injectivelabs/wallet-private-key");
const wallet_cosmostation_1 = require("@injectivelabs/wallet-cosmostation");
const ethereumWalletsDisabled = (args) => {
    const { ethereumOptions } = args;
    if (!ethereumOptions) {
        return true;
    }
    const { ethereumChainId } = ethereumOptions;
    if (!ethereumChainId) {
        return true;
    }
    return false;
};
const createStrategy = ({ args, wallet, }) => {
    /**
     * If we only want to use Cosmos Native Wallets
     * We are not creating strategies for Ethereum Native Wallets
     */
    if ((0, wallet_base_1.isEvmWallet)(wallet) && ethereumWalletsDisabled(args)) {
        return undefined;
    }
    const ethWalletArgs = {
        ...args,
        chainId: args.chainId,
        ethereumOptions: args.ethereumOptions,
    };
    switch (wallet) {
        case wallet_base_1.Wallet.Metamask:
            return new wallet_evm_1.EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: wallet_base_1.Wallet.Metamask,
            });
        case wallet_base_1.Wallet.Ledger:
            return new wallet_ledger_1.LedgerLiveStrategy(ethWalletArgs);
        case wallet_base_1.Wallet.LedgerLegacy:
            return new wallet_ledger_1.LedgerLegacyStrategy(ethWalletArgs);
        case wallet_base_1.Wallet.TrustWallet:
            return new wallet_evm_1.EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: wallet_base_1.Wallet.TrustWallet,
            });
        case wallet_base_1.Wallet.TrezorBip32:
            return new wallet_trezor_1.TrezorBip32Strategy(ethWalletArgs);
        case wallet_base_1.Wallet.TrezorBip44:
            return new wallet_trezor_1.TrezorBip44Strategy(ethWalletArgs);
        case wallet_base_1.Wallet.Phantom:
            return new wallet_evm_1.EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: wallet_base_1.Wallet.Phantom,
            });
        case wallet_base_1.Wallet.OkxWallet:
            return new wallet_evm_1.EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: wallet_base_1.Wallet.OkxWallet,
            });
        case wallet_base_1.Wallet.BitGet:
            return new wallet_evm_1.EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: wallet_base_1.Wallet.BitGet,
            });
        case wallet_base_1.Wallet.Rainbow:
            return new wallet_evm_1.EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: wallet_base_1.Wallet.Rainbow,
            });
        case wallet_base_1.Wallet.WalletConnect:
            if (!args.metadata?.walletConnect?.projectId) {
                return undefined;
            }
            return new wallet_wallet_connect_1.WalletConnectStrategy(ethWalletArgs);
        case wallet_base_1.Wallet.PrivateKey:
            return new wallet_private_key_1.PrivateKeyWalletStrategy(ethWalletArgs);
        case wallet_base_1.Wallet.Keplr:
            return new wallet_cosmos_1.CosmosWalletStrategy({ ...args, wallet: wallet_base_1.Wallet.Keplr });
        case wallet_base_1.Wallet.Cosmostation:
            return new wallet_cosmostation_1.CosmostationWalletStrategy({ ...args });
        case wallet_base_1.Wallet.Leap:
            return new wallet_cosmos_1.CosmosWalletStrategy({ ...args, wallet: wallet_base_1.Wallet.Leap });
        case wallet_base_1.Wallet.Ninji:
            return new wallet_cosmos_1.CosmosWalletStrategy({ ...args, wallet: wallet_base_1.Wallet.Ninji });
        case wallet_base_1.Wallet.OWallet:
            return new wallet_cosmos_1.CosmosWalletStrategy({ ...args, wallet: wallet_base_1.Wallet.OWallet });
        case wallet_base_1.Wallet.Magic:
            if (!args.metadata?.magic?.apiKey || !args.metadata?.magic?.rpcEndpoint) {
                return undefined;
            }
            return new wallet_magic_1.MagicStrategy(args);
        case wallet_base_1.Wallet.Turnkey:
            if (!args.metadata?.turnkey?.iframeContainerId ||
                !args.metadata?.turnkey?.defaultOrganizationId) {
                return undefined;
            }
            return new wallet_turnkey_1.TurnkeyWalletStrategy(ethWalletArgs);
        default:
            return undefined;
    }
};
const createAllStrategies = (args) => {
    return Object.values(wallet_base_1.Wallet).reduce((strategies, wallet) => {
        if (strategies[wallet]) {
            return strategies;
        }
        strategies[wallet] = createStrategy({ args, wallet: wallet });
        return strategies;
    }, {});
};
class WalletStrategy extends wallet_core_1.BaseWalletStrategy {
    constructor(args) {
        const strategies = createAllStrategies(args);
        super({
            ...args,
            strategies,
        });
    }
    /**
     * This method is used to set the metadata for the wallet strategies.
     * In some cases we are going to set the metadata dynamically on the fly, and in
     * some cases we are recreating the wallet strategies from scratch using the new
     * metadata
     *
     * Case 1: Private Key is set dynamically
     * If we have a dynamically set private key,
     * we are creating a new PrivateKey strategy
     * with the specified private key (passed as metadata)
     *
     * Case 2: Similar to Case 1, but for Wallet Connect Metadata
     *
     */
    setMetadata(metadata) {
        const shouldRecreateStrategyOnMetadataChange = [
            wallet_base_1.Wallet.PrivateKey,
            wallet_base_1.Wallet.WalletConnect,
        ];
        for (const wallet of Object.keys(this.strategies)) {
            const walletEnum = wallet;
            if (shouldRecreateStrategyOnMetadataChange.includes(walletEnum)) {
                this.strategies[walletEnum] = createStrategy({
                    args: {
                        ...this.args,
                        metadata: { ...this.args.metadata, ...metadata },
                    },
                    wallet: walletEnum,
                });
                continue;
            }
            this.strategies[walletEnum]?.setMetadata?.(metadata);
        }
    }
}
exports.WalletStrategy = WalletStrategy;
const createStrategyFactory = (args) => {
    return new WalletStrategy(args);
};
exports.createStrategyFactory = createStrategyFactory;
