import { Wallet, isEvmWallet, } from '@injectivelabs/wallet-base';
import { LedgerLiveStrategy, LedgerLegacyStrategy, } from '@injectivelabs/wallet-ledger';
import { MagicStrategy } from '@injectivelabs/wallet-magic';
import { EvmWalletStrategy } from '@injectivelabs/wallet-evm';
import { BaseWalletStrategy } from '@injectivelabs/wallet-core';
import { CosmosWalletStrategy } from '@injectivelabs/wallet-cosmos';
import { TrezorBip32Strategy, TrezorBip44Strategy, } from '@injectivelabs/wallet-trezor';
import { TurnkeyWalletStrategy } from '@injectivelabs/wallet-turnkey';
import { WalletConnectStrategy } from '@injectivelabs/wallet-wallet-connect';
import { PrivateKeyWalletStrategy } from '@injectivelabs/wallet-private-key';
import { CosmostationWalletStrategy } from '@injectivelabs/wallet-cosmostation';
const ethereumWalletsDisabled = (args) => {
    const { ethereumOptions } = args;
    if (!ethereumOptions) {
        return true;
    }
    const { ethereumChainId } = ethereumOptions;
    if (!ethereumChainId) {
        return true;
    }
    return false;
};
const createStrategy = ({ args, wallet, }) => {
    /**
     * If we only want to use Cosmos Native Wallets
     * We are not creating strategies for Ethereum Native Wallets
     */
    if (isEvmWallet(wallet) && ethereumWalletsDisabled(args)) {
        return undefined;
    }
    const ethWalletArgs = {
        ...args,
        chainId: args.chainId,
        ethereumOptions: args.ethereumOptions,
    };
    switch (wallet) {
        case Wallet.Metamask:
            return new EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: Wallet.Metamask,
            });
        case Wallet.Ledger:
            return new LedgerLiveStrategy(ethWalletArgs);
        case Wallet.LedgerLegacy:
            return new LedgerLegacyStrategy(ethWalletArgs);
        case Wallet.TrustWallet:
            return new EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: Wallet.TrustWallet,
            });
        case Wallet.TrezorBip32:
            return new TrezorBip32Strategy(ethWalletArgs);
        case Wallet.TrezorBip44:
            return new TrezorBip44Strategy(ethWalletArgs);
        case Wallet.Phantom:
            return new EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: Wallet.Phantom,
            });
        case Wallet.OkxWallet:
            return new EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: Wallet.OkxWallet,
            });
        case Wallet.BitGet:
            return new EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: Wallet.BitGet,
            });
        case Wallet.Rainbow:
            return new EvmWalletStrategy({
                ...ethWalletArgs,
                wallet: Wallet.Rainbow,
            });
        case Wallet.WalletConnect:
            if (!args.metadata?.walletConnect?.projectId) {
                return undefined;
            }
            return new WalletConnectStrategy(ethWalletArgs);
        case Wallet.PrivateKey:
            return new PrivateKeyWalletStrategy(ethWalletArgs);
        case Wallet.Keplr:
            return new CosmosWalletStrategy({ ...args, wallet: Wallet.Keplr });
        case Wallet.Cosmostation:
            return new CosmostationWalletStrategy({ ...args });
        case Wallet.Leap:
            return new CosmosWalletStrategy({ ...args, wallet: Wallet.Leap });
        case Wallet.Ninji:
            return new CosmosWalletStrategy({ ...args, wallet: Wallet.Ninji });
        case Wallet.OWallet:
            return new CosmosWalletStrategy({ ...args, wallet: Wallet.OWallet });
        case Wallet.Magic:
            if (!args.metadata?.magic?.apiKey || !args.metadata?.magic?.rpcEndpoint) {
                return undefined;
            }
            return new MagicStrategy(args);
        case Wallet.Turnkey:
            if (!args.metadata?.turnkey?.iframeContainerId ||
                !args.metadata?.turnkey?.defaultOrganizationId) {
                return undefined;
            }
            return new TurnkeyWalletStrategy(ethWalletArgs);
        default:
            return undefined;
    }
};
const createAllStrategies = (args) => {
    return Object.values(Wallet).reduce((strategies, wallet) => {
        if (strategies[wallet]) {
            return strategies;
        }
        strategies[wallet] = createStrategy({ args, wallet: wallet });
        return strategies;
    }, {});
};
export class WalletStrategy extends BaseWalletStrategy {
    constructor(args) {
        const strategies = createAllStrategies(args);
        super({
            ...args,
            strategies,
        });
    }
    /**
     * This method is used to set the metadata for the wallet strategies.
     * In some cases we are going to set the metadata dynamically on the fly, and in
     * some cases we are recreating the wallet strategies from scratch using the new
     * metadata
     *
     * Case 1: Private Key is set dynamically
     * If we have a dynamically set private key,
     * we are creating a new PrivateKey strategy
     * with the specified private key (passed as metadata)
     *
     * Case 2: Similar to Case 1, but for Wallet Connect Metadata
     *
     */
    setMetadata(metadata) {
        const shouldRecreateStrategyOnMetadataChange = [
            Wallet.PrivateKey,
            Wallet.WalletConnect,
        ];
        for (const wallet of Object.keys(this.strategies)) {
            const walletEnum = wallet;
            if (shouldRecreateStrategyOnMetadataChange.includes(walletEnum)) {
                this.strategies[walletEnum] = createStrategy({
                    args: {
                        ...this.args,
                        metadata: { ...this.args.metadata, ...metadata },
                    },
                    wallet: walletEnum,
                });
                continue;
            }
            this.strategies[walletEnum]?.setMetadata?.(metadata);
        }
    }
}
export const createStrategyFactory = (args) => {
    return new WalletStrategy(args);
};
