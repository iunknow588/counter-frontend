"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable class-methods-use-this */
const ts_types_1 = require("@injectivelabs/ts-types");
const ethereumjs_util_1 = require("ethereumjs-util");
const common_1 = require("@ethereumjs/common");
const tx_1 = require("@ethereumjs/tx");
const ledgerhq_hw_app_eth_1 = require("@bangjelkoski/ledgerhq-hw-app-eth");
const exceptions_1 = require("@injectivelabs/exceptions");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const index_js_1 = __importDefault(require("./hw/index.js"));
const utils_js_1 = require("./utils.js");
const alchemy_sdk_1 = require("alchemy-sdk");
const getNetworkFromChainId = (chainId) => {
    if (chainId === ts_types_1.EthereumChainId.Goerli) {
        return common_1.Chain.Goerli;
    }
    if (chainId === ts_types_1.EthereumChainId.Sepolia) {
        return common_1.Chain.Sepolia;
    }
    if (chainId === ts_types_1.EthereumChainId.Kovan) {
        return common_1.Chain.Goerli;
    }
    return common_1.Chain.Mainnet;
};
class LedgerBase extends wallet_base_1.BaseConcreteStrategy {
    baseDerivationPath;
    derivationPathType;
    ledger;
    ethereumOptions;
    alchemy;
    constructor(args) {
        super(args);
        this.baseDerivationPath = wallet_base_1.DEFAULT_BASE_DERIVATION_PATH;
        this.derivationPathType = args.derivationPathType;
        this.ledger = new index_js_1.default();
        this.ethereumOptions = args.ethereumOptions;
    }
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Hardware);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async disconnect() {
        this.ledger = await this.ledger.refresh();
    }
    async getAddresses() {
        const { baseDerivationPath, derivationPathType } = this;
        try {
            const accountManager = await this.ledger.getAccountManager();
            const wallets = await accountManager.getWallets(baseDerivationPath, derivationPathType);
            return wallets.map((k) => k.address);
        }
        catch (e) {
            throw new exceptions_1.LedgerException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(txData, args) {
        const signedTransaction = await this.signEvmTransaction(txData, args);
        try {
            const alchemy = await this.getAlchemy(args.ethereumChainId);
            const txReceipt = await alchemy.core.sendTransaction((0, ethereumjs_util_1.addHexPrefix)(signedTransaction.serialize().toString('hex')));
            return txReceipt.hash;
        }
        catch (e) {
            throw new exceptions_1.LedgerException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SendEvmTransaction,
            });
        }
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints.grpc within the options for using Ethereum native wallets'));
        }
        const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const { derivationPath } = await this.getWalletForAddress(address);
        const object = JSON.parse(eip712json);
        try {
            const ledger = await this.ledger.getInstance();
            const result = await ledger.signEIP712Message(derivationPath, object);
            const combined = `${result.r}${result.s}${result.v.toString(16)}`;
            return combined.startsWith('0x') ? combined : `0x${combined}`;
        }
        catch (e) {
            const errorMessage = e.message;
            const isKnownNanoSError = errorMessage.includes('instruction not supported') ||
                errorMessage.includes('invalid status') ||
                errorMessage.includes('not supported') ||
                errorMessage.includes('INS_NOT_SUPPORTED');
            if (!isKnownNanoSError) {
                throw new exceptions_1.LedgerException(new Error(errorMessage), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletError,
                    contextModule: wallet_base_1.WalletAction.SignTransaction,
                });
            }
            try {
                const ledger = await this.ledger.getInstance();
                const result = await ledger.signEIP712HashedMessage(derivationPath, (0, ethereumjs_util_1.bufferToHex)((0, utils_js_1.domainHash)(object)), (0, ethereumjs_util_1.bufferToHex)((0, utils_js_1.messageHash)(object)));
                const combined = `${result.r}${result.s}${result.v.toString(16)}`;
                return combined.startsWith('0x') ? combined : `0x${combined}`;
            }
            catch (e) {
                throw new exceptions_1.LedgerException(new Error(e.message), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletError,
                    contextModule: wallet_base_1.WalletAction.SignTransaction,
                });
            }
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    async signArbitrary(signer, data) {
        try {
            const { derivationPath } = await this.getWalletForAddress(signer);
            const ledger = await this.ledger.getInstance();
            const result = await ledger.signPersonalMessage(derivationPath, Buffer.from((0, sdk_ts_1.toUtf8)(data), 'utf8').toString('hex'));
            const combined = `${result.r}${result.s}${result.v.toString(16)}`;
            return combined.startsWith('0x') ? combined : `0x${combined}`;
        }
        catch (e) {
            throw new exceptions_1.LedgerException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
    }
    async getEthereumChainId() {
        const alchemy = await this.getAlchemy();
        const alchemyProvider = await alchemy.config.getProvider();
        return alchemyProvider.network.chainId.toString();
    }
    async getEvmTransactionReceipt(txHash) {
        return Promise.resolve(txHash);
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async signEvmTransaction(txData, args) {
        const alchemy = await this.getAlchemy(args.ethereumChainId);
        const chainId = parseInt(args.ethereumChainId.toString(), 10);
        const nonce = await alchemy.core.getTransactionCount(args.address);
        const common = new common_1.Common({
            chain: getNetworkFromChainId(chainId),
            hardfork: common_1.Hardfork.London,
        });
        const eip1559TxData = {
            from: txData.from,
            data: txData.data,
            to: txData.to,
            nonce: (0, ethereumjs_util_1.addHexPrefix)(nonce.toString(16)),
            gas: (0, ethereumjs_util_1.addHexPrefix)(txData.gas),
            gasLimit: (0, ethereumjs_util_1.addHexPrefix)(txData.gas),
            maxFeePerGas: (0, ethereumjs_util_1.addHexPrefix)(txData.gasPrice || txData.maxFeePerGas),
            maxPriorityFeePerGas: (0, ethereumjs_util_1.addHexPrefix)(txData.maxPriorityFeePerGas || wallet_base_1.TIP_IN_GWEI.toString(16)),
        };
        const tx = tx_1.FeeMarketEIP1559Transaction.fromTxData(eip1559TxData, { common });
        const msg = tx.getMessageToSign(false);
        // const encodedMessage = msg
        const encodedMessageHex = msg.toString('hex');
        try {
            const ledger = await this.ledger.getInstance();
            const { derivationPath } = await this.getWalletForAddress(args.address);
            const resolution = await ledgerhq_hw_app_eth_1.ledgerService.resolveTransaction(encodedMessageHex, {}, {});
            const txSig = await ledger.signTransaction(derivationPath, encodedMessageHex, resolution);
            const signedTxData = {
                ...eip1559TxData,
                v: `0x${txSig.v}`,
                r: `0x${txSig.r}`,
                s: `0x${txSig.s}`,
            };
            return tx_1.FeeMarketEIP1559Transaction.fromTxData(signedTxData, {
                common,
            });
        }
        catch (e) {
            throw new exceptions_1.LedgerException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignEvmTransaction,
            });
        }
    }
    async getWalletForAddress(address) {
        try {
            const { baseDerivationPath, derivationPathType } = this;
            const accountManager = await this.ledger.getAccountManager();
            if (!accountManager.hasWalletForAddress(address)) {
                for (let i = 0; i < wallet_base_1.DEFAULT_ADDRESS_SEARCH_LIMIT / wallet_base_1.DEFAULT_NUM_ADDRESSES_TO_FETCH; i += 1) {
                    await accountManager.getWallets(baseDerivationPath, derivationPathType);
                    if (accountManager.hasWalletForAddress(address)) {
                        return (await accountManager.getWalletForAddress(address));
                    }
                }
            }
            return (await accountManager.getWalletForAddress(address));
        }
        catch (e) {
            throw new exceptions_1.LedgerException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getAlchemy(ethereumChainId) {
        if (this.alchemy) {
            return this.alchemy;
        }
        const options = this.ethereumOptions;
        const chainId = ethereumChainId || options.ethereumChainId;
        const url = options.rpcUrl || options.rpcUrls?.[chainId];
        if (!url) {
            throw new exceptions_1.GeneralException(new Error('Please pass rpcUrl within the ethereumOptions'));
        }
        this.alchemy = new alchemy_sdk_1.Alchemy({
            apiKey: (0, wallet_base_1.getKeyFromRpcUrl)(url),
            network: chainId === ts_types_1.EthereumChainId.Mainnet
                ? alchemy_sdk_1.Network.ETH_MAINNET
                : alchemy_sdk_1.Network.ETH_SEPOLIA,
        });
        return this.alchemy;
    }
}
exports.default = LedgerBase;
