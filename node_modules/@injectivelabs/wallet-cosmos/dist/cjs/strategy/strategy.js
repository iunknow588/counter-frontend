"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosWalletStrategy = void 0;
/* eslint-disable class-methods-use-this */
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const exceptions_1 = require("@injectivelabs/exceptions");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const utils_1 = require("@injectivelabs/utils");
const wallet_js_1 = require("./../wallet.js");
const cosmosWallets = [wallet_base_1.Wallet.Leap, wallet_base_1.Wallet.Ninji, wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet];
class CosmosWalletStrategy extends wallet_base_1.BaseConcreteStrategy {
    wallet;
    cosmosWallet;
    constructor(args) {
        super({ ...args, chainId: args.chainId });
        if (!cosmosWallets.includes(args.wallet)) {
            throw new exceptions_1.CosmosWalletException(new Error(`Cosmos Wallet for ${(0, utils_1.capitalize)(args.wallet)} is not supported.`));
        }
        this.wallet = args.wallet;
        this.chainId = args.chainId;
        this.cosmosWallet = new wallet_js_1.CosmosWallet({
            wallet: args.wallet,
            chainId: args.chainId,
        });
    }
    async getWalletDeviceType() {
        const cosmosWallet = this.getCurrentCosmosWallet();
        const key = await cosmosWallet.getKey();
        return key.isNanoLedger
            ? Promise.resolve(wallet_base_1.WalletDeviceType.Hardware)
            : Promise.resolve(wallet_base_1.WalletDeviceType.Browser);
    }
    async enable() {
        const cosmosWallet = this.getCurrentCosmosWallet();
        return await cosmosWallet.checkChainIdSupport();
    }
    async disconnect() {
        const { wallet } = this;
        if (this.listeners[wallet_base_1.WalletEventListener.AccountChange]) {
            if (wallet === wallet_base_1.Wallet.Ninji) {
                window.ninji.off('accountsChanged', this.listeners[wallet_base_1.WalletEventListener.AccountChange]);
            }
            if ([wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(wallet)) {
                window.removeEventListener('keplr_keystorechange', this.listeners[wallet_base_1.WalletEventListener.AccountChange]);
            }
            if (wallet === wallet_base_1.Wallet.Leap) {
                window.removeEventListener('leap_keystorechange', this.listeners[wallet_base_1.WalletEventListener.AccountChange]);
            }
        }
        this.listeners = {};
    }
    async getAddresses() {
        const cosmosWallet = this.getCurrentCosmosWallet();
        try {
            const accounts = await cosmosWallet.getAccounts();
            return accounts.map((account) => account.address);
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    // eslint-disable-next-line class-methods-use-this
    async sendEvmTransaction(_transaction, _options) {
        const { wallet } = this;
        throw new exceptions_1.CosmosWalletException(new Error(`sendEvmTransaction is not supported. ${(0, utils_1.capitalize)(wallet)} only supports sending cosmos transactions`), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, options) {
        const cosmosWallet = this.getCurrentCosmosWallet();
        const txRaw = (0, sdk_ts_1.createTxRawFromSigResponse)(transaction);
        if (!options.endpoints) {
            throw new exceptions_1.CosmosWalletException(new Error('You have to pass endpoints within the options to broadcast transaction'));
        }
        try {
            const txHash = await cosmosWallet.broadcastTx(txRaw);
            return await (0, sdk_ts_1.waitTxBroadcasted)(txHash, options);
        }
        catch (e) {
            if (e instanceof exceptions_1.TransactionException) {
                throw e;
            }
            throw new exceptions_1.TransactionException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SendTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(transaction) {
        const cosmosWallet = this.getCurrentCosmosWallet();
        const signer = await cosmosWallet.getOfflineAminoSigner();
        try {
            return await signer.signAmino(transaction.address, transaction.signDoc);
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SignTransaction,
            });
        }
    }
    async signCosmosTransaction(transaction) {
        const cosmosWallet = this.getCurrentCosmosWallet();
        const signer = await cosmosWallet.getOfflineSigner();
        const signDoc = (0, sdk_ts_1.createSignDocFromTransaction)(transaction);
        try {
            return await signer.signDirect(transaction.address, (0, wallet_base_1.createCosmosSignDocFromSignDoc)(signDoc));
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SendTransaction,
            });
        }
    }
    async signEip712TypedData(_eip712TypedData, _address) {
        throw new exceptions_1.CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.SendTransaction,
        });
    }
    async signArbitrary(signer, data) {
        const cosmosWallet = this.getCurrentCosmosWallet();
        try {
            const signature = await cosmosWallet.signArbitrary({ data, signer });
            return signature;
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: wallet_base_1.WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        const { wallet } = this;
        throw new exceptions_1.CosmosWalletException(new Error(`getEthereumChainId is not supported on ${(0, utils_1.capitalize)(wallet)}`), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.GetChainId,
        });
    }
    async getEvmTransactionReceipt(_txHash) {
        const { wallet } = this;
        throw new exceptions_1.CosmosWalletException(new Error(`getEvmTransactionReceipt is not supported on ${(0, utils_1.capitalize)(wallet)}`), {
            code: exceptions_1.UnspecifiedErrorCode,
            context: wallet_base_1.WalletAction.GetEvmTransactionReceipt,
        });
    }
    async getPubKey() {
        const cosmosWallet = this.getCurrentCosmosWallet();
        const key = await cosmosWallet.getKey();
        return Buffer.from(key.pubKey).toString('base64');
    }
    async onAccountChange(callback) {
        const { wallet } = this;
        const listener = async () => {
            const [account] = await this.getAddresses();
            callback(account);
        };
        this.listeners = {
            [wallet_base_1.WalletEventListener.AccountChange]: listener,
        };
        if (wallet === wallet_base_1.Wallet.Ninji) {
            window.ninji.on('accountsChanged', listener);
        }
        if ([wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(wallet)) {
            window.addEventListener('keplr_keystorechange', listener);
        }
        if (wallet === wallet_base_1.Wallet.Leap) {
            window.addEventListener('leap_keystorechange', listener);
        }
    }
    getCosmosWallet(chainId) {
        const { wallet, cosmosWallet } = this;
        return !cosmosWallet ? new wallet_js_1.CosmosWallet({ chainId, wallet }) : cosmosWallet;
    }
    getCurrentCosmosWallet() {
        const { wallet, cosmosWallet } = this;
        if (!cosmosWallet) {
            throw new exceptions_1.CosmosWalletException(new Error(`Please install the ${(0, utils_1.capitalize)(wallet)} wallet extension`), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletNotInstalledError,
                context: wallet_base_1.WalletAction.SignTransaction,
            });
        }
        return cosmosWallet;
    }
}
exports.CosmosWalletStrategy = CosmosWalletStrategy;
