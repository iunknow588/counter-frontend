"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosWallet = void 0;
const exceptions_1 = require("@injectivelabs/exceptions");
const utils_1 = require("@injectivelabs/utils");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const stargate_1 = require("@cosmjs/stargate");
const $window = (typeof window !== 'undefined' ? window : {});
class CosmosWallet {
    wallet;
    chainId;
    constructor({ wallet, chainId, }) {
        this.wallet = wallet;
        this.chainId = chainId;
    }
    async isChainIdSupported(chainId) {
        const { wallet } = this;
        return new CosmosWallet({ chainId, wallet }).checkChainIdSupport();
    }
    async getCosmosWallet() {
        const { chainId } = this;
        const cosmos = this.getCosmos();
        try {
            await cosmos.enable(chainId);
            return cosmos;
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message));
        }
    }
    async chainNotSupported() {
        const { chainId, wallet } = this;
        const chainName = chainId.split('-');
        const context = wallet === wallet_base_1.Wallet.Keplr
            ? 'https://chains.keplr.app/'
            : wallet === wallet_base_1.Wallet.OWallet
                ? 'https://owallet.io/'
                : undefined;
        throw new exceptions_1.CosmosWalletException(new Error(`${(0, utils_1.capitalize)(wallet)} may not support ${chainName[0] || chainId} network. Please check if the chain can be added.`), context ? { context } : {});
    }
    async getAccounts() {
        const { chainId } = this;
        const cosmos = this.getCosmos();
        try {
            return cosmos.getOfflineSigner(chainId).getAccounts();
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                contextModule: exceptions_1.WalletErrorActionModule.GetAccounts,
            });
        }
    }
    async getKey() {
        const { wallet, chainId } = this;
        const cosmosWallet = await this.getCosmosWallet();
        try {
            return cosmosWallet.getKey(chainId);
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                contextModule: wallet,
            });
        }
    }
    async getOfflineSigner() {
        const { chainId, wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        try {
            return cosmosWallet.getOfflineSigner(chainId);
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                contextModule: wallet,
            });
        }
    }
    async getOfflineAminoSigner() {
        const { chainId, wallet } = this;
        if (![wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(wallet)) {
            throw new exceptions_1.CosmosWalletException(new Error(`getOfflineAminoSigner is not support on ${(0, utils_1.capitalize)(wallet)}`));
        }
        const cosmosWallet = await this.getCosmosWallet();
        try {
            return cosmosWallet.getOfflineSignerOnlyAmino(chainId);
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                context: wallet,
            });
        }
    }
    /**
     * This method is used to broadcast a transaction to the network.
     * Since it uses the `Sync` mode, it will not wait for the transaction to be included in a block,
     * so we have to make sure the transaction is included in a block after its broadcasted
     *
     * @param txRaw - raw transaction to broadcast
     * @returns tx hash
     */
    async broadcastTx(txRaw) {
        const { chainId, wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        try {
            const result = await cosmosWallet.sendTx(chainId, sdk_ts_1.CosmosTxV1Beta1Tx.TxRaw.encode(txRaw).finish(), wallet_base_1.BroadcastMode.Sync);
            if (!result || result.length === 0) {
                throw new exceptions_1.TransactionException(new Error('Transaction failed to be broadcasted'), { contextModule: wallet });
            }
            return Buffer.from(result).toString('hex');
        }
        catch (e) {
            if (e instanceof exceptions_1.TransactionException) {
                throw e;
            }
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                context: 'broadcast-tx',
                contextModule: wallet,
            });
        }
    }
    /**
     * This method is used to broadcast a transaction to the network.
     * Since it uses the `Block` mode, and it will wait for the transaction to be included in a block,
     *
     * @param txRaw - raw transaction to broadcast
     * @returns tx hash
     */
    async broadcastTxBlock(txRaw) {
        const { chainId, wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        try {
            const result = await cosmosWallet.sendTx(chainId, sdk_ts_1.CosmosTxV1Beta1Tx.TxRaw.encode(txRaw).finish(), wallet_base_1.BroadcastMode.Block);
            if (!result || result.length === 0) {
                throw new exceptions_1.TransactionException(new Error('Transaction failed to be broadcasted'), { contextModule: wallet });
            }
            return Buffer.from(result).toString('hex');
        }
        catch (e) {
            if (e instanceof exceptions_1.TransactionException) {
                throw e;
            }
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                context: 'broadcast-tx',
                contextModule: wallet,
            });
        }
    }
    async signAndBroadcastAminoUsingCosmjs(messages, stdFee, endpoints) {
        const { chainId, wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        if (![wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(wallet)) {
            throw new exceptions_1.CosmosWalletException(new Error(`signAndBroadcastAminoUsingCosmjs is not support on ${(0, utils_1.capitalize)(wallet)}`));
        }
        if (!endpoints.rpc) {
            throw new exceptions_1.GeneralException(new Error(`Please provide rpc endpoint`));
        }
        const offlineSigner = cosmosWallet.getOfflineSignerOnlyAmino(chainId);
        const [account] = await offlineSigner.getAccounts();
        const client = await stargate_1.SigningStargateClient.connectWithSigner(endpoints.rpc, offlineSigner);
        const txResponse = await client.signAndBroadcast(account.address, messages, stdFee);
        return txResponse;
    }
    async signArbitrary({ data, signer, }) {
        const { chainId, wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        if (wallet !== wallet_base_1.Wallet.Keplr) {
            throw new exceptions_1.CosmosWalletException(new Error(`signArbitrary is not supported on ${(0, utils_1.capitalize)(wallet)}`));
        }
        try {
            const signature = await cosmosWallet.signArbitrary(chainId, signer, data);
            return signature.signature;
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                context: wallet,
                contextModule: 'sign-arbitrary',
            });
        }
    }
    async signEIP712CosmosTx({ eip712, signDoc, }) {
        const { chainId, wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        const key = await this.getKey();
        try {
            return cosmosWallet.experimentalSignEIP712CosmosTx_v0(chainId, key.bech32Address, eip712, signDoc);
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(e.message), {
                context: wallet,
                contextModule: 'sign-eip712-cosmos-tx',
            });
        }
    }
    async checkChainIdSupport() {
        const { chainId, wallet } = this;
        const cosmos = this.getCosmos();
        const chainName = chainId.split('-');
        try {
            return !!(await cosmos.getKey(chainId));
        }
        catch (e) {
            throw new exceptions_1.CosmosWalletException(new Error(`${(0, utils_1.capitalize)(wallet)} doesn't support ${chainName[0] || chainId} network. Please use another Cosmos wallet`));
        }
    }
    getCosmos() {
        const { wallet } = this;
        if (!$window) {
            throw new exceptions_1.CosmosWalletException(new Error(`Please install ${(0, utils_1.capitalize)(wallet)} extension`), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletNotInstalledError,
                contextModule: wallet,
            });
        }
        let cosmos = undefined;
        if (wallet === wallet_base_1.Wallet.OWallet) {
            cosmos = $window.owallet;
        }
        if (wallet === wallet_base_1.Wallet.Keplr) {
            cosmos = $window.keplr;
        }
        if (wallet === wallet_base_1.Wallet.Ninji) {
            cosmos = $window.ninji;
        }
        if (wallet === wallet_base_1.Wallet.Leap) {
            cosmos = $window.leap;
        }
        if (!cosmos) {
            throw new exceptions_1.CosmosWalletException(new Error(`Please install ${(0, utils_1.capitalize)(wallet)} extension`), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletNotInstalledError,
                contextModule: wallet,
            });
        }
        return cosmos;
    }
    async disableGasCheck() {
        const { wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        if (![wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(wallet)) {
            throw new exceptions_1.CosmosWalletException(new Error(`disableGasCheck is not support on ${(0, utils_1.capitalize)(wallet)}`));
        }
        // Temporary disable tx gas check for fee delegation purposes
        cosmosWallet.defaultOptions = {
            ...cosmosWallet.defaultOptions,
            sign: {
                ...cosmosWallet.defaultOptions.sign,
                disableBalanceCheck: true,
            },
        };
    }
    async enableGasCheck() {
        const { wallet } = this;
        const cosmosWallet = await this.getCosmosWallet();
        if (![wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(wallet)) {
            throw new exceptions_1.CosmosWalletException(new Error(`EnableGasCheck is not support on ${(0, utils_1.capitalize)(wallet)}`));
        }
        // Temporary disable tx gas check for fee delegation purposes
        cosmosWallet.defaultOptions = {
            ...cosmosWallet.defaultOptions,
            sign: {
                ...cosmosWallet.defaultOptions.sign,
                disableBalanceCheck: false,
            },
        };
    }
}
exports.CosmosWallet = CosmosWallet;
