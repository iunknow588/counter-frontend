import { Wallet, isEvmBrowserWallet, } from '@injectivelabs/wallet-base';
import { capitalize } from '@injectivelabs/utils';
import { WalletException } from '@injectivelabs/exceptions';
import { getOkxWalletProvider } from '../strategy/utils/Okx.js';
import { getBitGetProvider } from '../strategy/utils/bitget.js';
import { getPhantomProvider } from '../strategy/utils/phantom.js';
import { getMetamaskProvider } from '../strategy/utils/metamask.js';
import { getTrustWalletProvider } from '../strategy/utils/trustWallet.js';
export const getEvmProvider = async (wallet) => {
    if (!isEvmBrowserWallet(wallet)) {
        throw new WalletException(new Error(`Evm Wallet for ${capitalize(wallet)} is not supported.`));
    }
    try {
        let provider;
        if (wallet === Wallet.Metamask) {
            provider = (await getMetamaskProvider());
        }
        if (wallet === Wallet.BitGet) {
            provider = (await getBitGetProvider());
        }
        if (wallet === Wallet.Phantom) {
            provider = (await getPhantomProvider());
        }
        if (wallet === Wallet.TrustWallet) {
            provider = (await getTrustWalletProvider());
        }
        if (wallet === Wallet.OkxWallet) {
            provider = (await getOkxWalletProvider());
        }
        if (!provider) {
            throw new WalletException(new Error(`Please install ${capitalize(wallet)} Extension`));
        }
        return provider;
    }
    catch (e) {
        throw new WalletException(new Error(`Please install ${capitalize(wallet)} Extension`));
    }
};
export const updateEvmNetwork = async (wallet, chainId) => {
    if (!isEvmBrowserWallet(wallet)) {
        throw new WalletException(new Error(`Evm Wallet for ${capitalize(wallet)} is not supported.`));
    }
    const provider = (await getEvmProvider(wallet));
    if (!provider) {
        throw new WalletException(new Error(`Please install ${capitalize(wallet)} Extension`));
    }
    try {
        const chainIdToHex = chainId.toString(16);
        return await Promise.race([
            provider.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: `0x${chainIdToHex}` }],
            }),
            new Promise((resolve) => provider.on('chainChanged', ({ chain }) => {
                if (chain?.id === chainIdToHex) {
                    resolve();
                }
            })),
        ]);
    }
    catch (e) {
        throw new WalletException(new Error(`Please update your ${capitalize(wallet)} network`));
    }
};
