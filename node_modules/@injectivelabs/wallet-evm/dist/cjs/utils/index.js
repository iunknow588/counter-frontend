"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateEvmNetwork = exports.getEvmProvider = void 0;
const wallet_base_1 = require("@injectivelabs/wallet-base");
const utils_1 = require("@injectivelabs/utils");
const exceptions_1 = require("@injectivelabs/exceptions");
const Okx_js_1 = require("../strategy/utils/Okx.js");
const bitget_js_1 = require("../strategy/utils/bitget.js");
const phantom_js_1 = require("../strategy/utils/phantom.js");
const metamask_js_1 = require("../strategy/utils/metamask.js");
const trustWallet_js_1 = require("../strategy/utils/trustWallet.js");
const getEvmProvider = async (wallet) => {
    if (!(0, wallet_base_1.isEvmBrowserWallet)(wallet)) {
        throw new exceptions_1.WalletException(new Error(`Evm Wallet for ${(0, utils_1.capitalize)(wallet)} is not supported.`));
    }
    try {
        let provider;
        if (wallet === wallet_base_1.Wallet.Metamask) {
            provider = (await (0, metamask_js_1.getMetamaskProvider)());
        }
        if (wallet === wallet_base_1.Wallet.BitGet) {
            provider = (await (0, bitget_js_1.getBitGetProvider)());
        }
        if (wallet === wallet_base_1.Wallet.Phantom) {
            provider = (await (0, phantom_js_1.getPhantomProvider)());
        }
        if (wallet === wallet_base_1.Wallet.TrustWallet) {
            provider = (await (0, trustWallet_js_1.getTrustWalletProvider)());
        }
        if (wallet === wallet_base_1.Wallet.OkxWallet) {
            provider = (await (0, Okx_js_1.getOkxWalletProvider)());
        }
        if (!provider) {
            throw new exceptions_1.WalletException(new Error(`Please install ${(0, utils_1.capitalize)(wallet)} Extension`));
        }
        return provider;
    }
    catch (e) {
        throw new exceptions_1.WalletException(new Error(`Please install ${(0, utils_1.capitalize)(wallet)} Extension`));
    }
};
exports.getEvmProvider = getEvmProvider;
const updateEvmNetwork = async (wallet, chainId) => {
    if (!(0, wallet_base_1.isEvmBrowserWallet)(wallet)) {
        throw new exceptions_1.WalletException(new Error(`Evm Wallet for ${(0, utils_1.capitalize)(wallet)} is not supported.`));
    }
    const provider = (await (0, exports.getEvmProvider)(wallet));
    if (!provider) {
        throw new exceptions_1.WalletException(new Error(`Please install ${(0, utils_1.capitalize)(wallet)} Extension`));
    }
    try {
        const chainIdToHex = chainId.toString(16);
        return await Promise.race([
            provider.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: `0x${chainIdToHex}` }],
            }),
            new Promise((resolve) => provider.on('chainChanged', ({ chain }) => {
                if (chain?.id === chainIdToHex) {
                    resolve();
                }
            })),
        ]);
    }
    catch (e) {
        throw new exceptions_1.WalletException(new Error(`Please update your ${(0, utils_1.capitalize)(wallet)} network`));
    }
};
exports.updateEvmNetwork = updateEvmNetwork;
