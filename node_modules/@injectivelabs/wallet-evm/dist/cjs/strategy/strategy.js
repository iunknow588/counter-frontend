"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmWallet = void 0;
/* eslint-disable class-methods-use-this */
const wallet_base_1 = require("@injectivelabs/wallet-base");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const exceptions_1 = require("@injectivelabs/exceptions");
const wallet_base_2 = require("@injectivelabs/wallet-base");
const utils_1 = require("@injectivelabs/utils");
const index_js_1 = require("./utils/index.js");
class EvmWallet extends wallet_base_2.BaseConcreteStrategy {
    wallet;
    evmProviders = {};
    constructor(args) {
        super(args);
        if (!(0, wallet_base_1.isEvmBrowserWallet)(args.wallet)) {
            throw new exceptions_1.WalletException(new Error(`Evm Wallet for ${(0, utils_1.capitalize)(args.wallet)} is not supported.`));
        }
        if (!(0, sdk_ts_1.isServerSide)()) {
            window.addEventListener('eip6963:announceProvider', (announcement) => {
                const event = announcement;
                const walletName = event.detail.info.name.toLowerCase();
                if (walletName === wallet_base_2.Wallet.Metamask.toLowerCase()) {
                    this.evmProviders[wallet_base_2.Wallet.Metamask] = event.detail.provider;
                }
                if (walletName === wallet_base_2.Wallet.Rainbow.toLowerCase()) {
                    this.evmProviders[wallet_base_2.Wallet.Rainbow] = event.detail.provider;
                }
                if (walletName === wallet_base_2.Wallet.Phantom.toLowerCase()) {
                    this.evmProviders[wallet_base_2.Wallet.Phantom] = event.detail.provider;
                }
                if (walletName === wallet_base_2.Wallet.OkxWallet.toLowerCase()) {
                    this.evmProviders[wallet_base_2.Wallet.OkxWallet] = event.detail.provider;
                }
                if (walletName === wallet_base_2.Wallet.BitGet.toLowerCase()) {
                    this.evmProviders[wallet_base_2.Wallet.BitGet] = event.detail.provider;
                }
                if (walletName === wallet_base_2.Wallet.TrustWallet.toLowerCase()) {
                    this.evmProviders[wallet_base_2.Wallet.TrustWallet] = event.detail.provider;
                }
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }
        this.wallet = args.wallet;
    }
    EvmWalletException(error, context) {
        if (this.wallet === wallet_base_2.Wallet.Metamask) {
            return new exceptions_1.MetamaskException(error, context);
        }
        if (this.wallet === wallet_base_2.Wallet.BitGet) {
            return new exceptions_1.BitGetException(error, context);
        }
        if (this.wallet === wallet_base_2.Wallet.OkxWallet) {
            return new exceptions_1.OkxWalletException(error, context);
        }
        if (this.wallet === wallet_base_2.Wallet.Phantom) {
            return new exceptions_1.MetamaskException(error, context);
        }
        if (this.wallet === wallet_base_2.Wallet.TrustWallet) {
            return new exceptions_1.TrustWalletException(error, context);
        }
        if (this.wallet === wallet_base_2.Wallet.Rainbow) {
            return new exceptions_1.RainbowWalletException(error, context);
        }
        return new exceptions_1.WalletException(error, context);
    }
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_2.WalletDeviceType.Browser);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async disconnect() {
        if (this.listeners[wallet_base_2.WalletEventListener.AccountChange]) {
            const ethereum = await this.getEthereum();
            ethereum.removeListener('accountsChanged', this.listeners[wallet_base_2.WalletEventListener.AccountChange]);
        }
        if (this.listeners[wallet_base_2.WalletEventListener.ChainIdChange]) {
            const ethereum = await this.getEthereum();
            ethereum.removeListener('chainChanged', this.listeners[wallet_base_2.WalletEventListener.ChainIdChange]);
        }
        this.listeners = {};
    }
    async getAddresses() {
        const ethereum = await this.getEthereum();
        try {
            return (await ethereum.request({
                method: 'eth_requestAccounts',
            }));
        }
        catch (e) {
            throw this.EvmWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_2.WalletAction.GetAccounts,
            });
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(transaction, _options) {
        const ethereum = await this.getEthereum();
        try {
            return (await ethereum.request({
                method: 'eth_sendTransaction',
                params: [transaction],
            }));
        }
        catch (e) {
            throw this.EvmWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_2.WalletAction.SendEvmTransaction,
            });
        }
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints within the options for using Ethereum native wallets'));
        }
        const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const ethereum = await this.getEthereum();
        try {
            return (await ethereum.request({
                method: 'eth_signTypedData_v4',
                params: [address, eip712json],
            }));
        }
        catch (e) {
            if (e.message.includes('Ledger: The signature doesnt match the right address')) {
                throw new exceptions_1.MetamaskException(new Error('Please connect directly with Ledger to sign this transaction'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletError,
                    contextModule: wallet_base_2.WalletAction.SignTransaction,
                });
            }
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_2.WalletAction.SignTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_2.WalletAction.SignTransaction,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_2.WalletAction.SignTransaction,
        });
    }
    async signArbitrary(signer, data) {
        const ethereum = await this.getEthereum();
        try {
            const signature = await ethereum.request({
                method: 'personal_sign',
                params: [(0, sdk_ts_1.toUtf8)(data), signer],
            });
            return signature;
        }
        catch (e) {
            throw this.EvmWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_2.WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        const ethereum = await this.getEthereum();
        try {
            return ethereum.request({ method: 'eth_chainId' });
        }
        catch (e) {
            throw this.EvmWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_2.WalletAction.GetChainId,
            });
        }
    }
    async getEvmTransactionReceipt(txHash) {
        const ethereum = await this.getEthereum();
        const interval = 1000;
        const transactionReceiptRetry = async () => {
            const receipt = (await ethereum.request({
                method: 'eth_getTransactionReceipt',
                params: [txHash],
            }));
            if (!receipt) {
                await (0, utils_1.sleep)(interval);
                await transactionReceiptRetry();
            }
            return receipt;
        };
        try {
            return await transactionReceiptRetry();
        }
        catch (e) {
            throw this.EvmWalletException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_2.WalletAction.GetEvmTransactionReceipt,
            });
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
    }
    async onChainIdChanged(callback) {
        const ethereum = await this.getEthereum();
        this.listeners = {
            [wallet_base_2.WalletEventListener.ChainIdChange]: callback,
        };
        ethereum.on('chainChanged', callback);
    }
    async onAccountChange(callback) {
        const ethereum = await this.getEthereum();
        this.listeners = {
            [wallet_base_2.WalletEventListener.AccountChange]: callback,
        };
        ethereum.on('accountsChanged', callback);
    }
    async getEthereum() {
        const evmProvider = this.evmProviders[this.wallet];
        if (evmProvider) {
            return evmProvider;
        }
        const backUpProvider = this.wallet === wallet_base_2.Wallet.Metamask
            ? await (0, index_js_1.getMetamaskProvider)()
            : this.wallet === wallet_base_2.Wallet.Phantom
                ? await (0, index_js_1.getPhantomProvider)()
                : this.wallet === wallet_base_2.Wallet.BitGet
                    ? await (0, index_js_1.getBitGetProvider)()
                    : this.wallet === wallet_base_2.Wallet.OkxWallet
                        ? await (0, index_js_1.getOkxWalletProvider)()
                        : this.wallet === wallet_base_2.Wallet.TrustWallet
                            ? await (0, index_js_1.getTrustWalletProvider)()
                            : this.wallet === wallet_base_2.Wallet.Rainbow
                                ? await (0, index_js_1.getRainbowProvider)()
                                : undefined;
        if (!backUpProvider) {
            throw this.EvmWalletException(new Error(`Please install the ${this.wallet} wallet extension.`), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletNotInstalledError,
                contextModule: wallet_base_2.WalletAction.GetAccounts,
            });
        }
        return backUpProvider;
    }
}
exports.EvmWallet = EvmWallet;
