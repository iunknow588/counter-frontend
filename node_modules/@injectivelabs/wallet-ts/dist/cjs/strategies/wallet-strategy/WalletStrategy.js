"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const exceptions_1 = require("@injectivelabs/exceptions");
const index_js_1 = __importDefault(require("./strategies/Okx/index.js"));
const Leap_js_1 = __importDefault(require("./strategies/Leap.js"));
const Keplr_js_1 = __importDefault(require("./strategies/Keplr.js"));
const Ninji_js_1 = __importDefault(require("./strategies/Ninji.js"));
const Torus_js_1 = __importDefault(require("./strategies/Torus.js"));
const index_js_2 = __importDefault(require("./strategies/Trezor/index.js"));
const index_js_3 = __importDefault(require("./strategies/BitGet/index.js"));
const index_js_4 = __importDefault(require("./strategies/Phantom/index.js"));
const index_js_5 = __importDefault(require("./strategies/Metamask/index.js"));
const PrivateKey_js_1 = __importDefault(require("./strategies/PrivateKey.js"));
const index_js_6 = __importDefault(require("./strategies/TrustWallet/index.js"));
const Cosmostation_js_1 = __importDefault(require("./strategies/Cosmostation.js"));
const index_js_7 = __importDefault(require("./strategies/LedgerCosmos/index.js"));
const WalletConnect_js_1 = __importDefault(require("./strategies/WalletConnect.js"));
const LedgerLive_js_1 = __importDefault(require("./strategies/Ledger/LedgerLive.js"));
const LedgerLegacy_js_1 = __importDefault(require("./strategies/Ledger/LedgerLegacy.js"));
const Magic_js_1 = __importDefault(require("./strategies/Magic.js"));
const utils_js_1 = require("./utils.js");
const enums_js_1 = require("../../types/enums.js");
const getInitialWallet = (args) => {
    if (args.wallet) {
        return args.wallet;
    }
    return args.ethereumOptions ? enums_js_1.Wallet.Metamask : enums_js_1.Wallet.Keplr;
};
const ethereumWalletsDisabled = (args) => {
    const { ethereumOptions } = args;
    if (!ethereumOptions) {
        return true;
    }
    const { ethereumChainId } = ethereumOptions;
    if (!ethereumChainId) {
        return true;
    }
    return false;
};
const createStrategy = ({ args, wallet, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const disabledWallets = args.disabledWallets || [];
    if (disabledWallets.includes(wallet)) {
        return undefined;
    }
    /**
     * If we only want to use Cosmos Native Wallets
     * We are not creating strategies for Ethereum Native Wallets
     */
    if ((0, utils_js_1.isEthWallet)(wallet) && ethereumWalletsDisabled(args)) {
        return undefined;
    }
    const ethWalletArgs = {
        chainId: args.chainId,
        ethereumOptions: args.ethereumOptions,
    };
    switch (wallet) {
        case enums_js_1.Wallet.Metamask:
            return new index_js_5.default(ethWalletArgs);
        case enums_js_1.Wallet.TrustWallet:
            return new index_js_6.default(ethWalletArgs);
        case enums_js_1.Wallet.Ledger:
            return new LedgerLive_js_1.default(ethWalletArgs);
        case enums_js_1.Wallet.LedgerLegacy:
            return new LedgerLegacy_js_1.default(ethWalletArgs);
        case enums_js_1.Wallet.Trezor:
            return new index_js_2.default(ethWalletArgs);
        case enums_js_1.Wallet.Torus:
            return new Torus_js_1.default(ethWalletArgs);
        case enums_js_1.Wallet.Phantom:
            return new index_js_4.default(ethWalletArgs);
        case enums_js_1.Wallet.OkxWallet:
            return new index_js_1.default(ethWalletArgs);
        case enums_js_1.Wallet.BitGet:
            return new index_js_3.default(ethWalletArgs);
        case enums_js_1.Wallet.WalletConnect:
            return new WalletConnect_js_1.default(Object.assign(Object.assign({}, ethWalletArgs), { metadata: (_a = args.options) === null || _a === void 0 ? void 0 : _a.metadata }));
        case enums_js_1.Wallet.PrivateKey:
            return new PrivateKey_js_1.default(Object.assign(Object.assign({}, ethWalletArgs), { privateKey: (_b = args.options) === null || _b === void 0 ? void 0 : _b.privateKey }));
        case enums_js_1.Wallet.Keplr:
            return new Keplr_js_1.default(Object.assign({}, args));
        case enums_js_1.Wallet.Cosmostation:
            return new Cosmostation_js_1.default(Object.assign({}, args));
        case enums_js_1.Wallet.LedgerCosmos:
            return new index_js_7.default(Object.assign({}, args));
        case enums_js_1.Wallet.Leap:
            return new Leap_js_1.default(Object.assign({}, args));
        case enums_js_1.Wallet.Ninji:
            return new Ninji_js_1.default(Object.assign({}, args));
        case enums_js_1.Wallet.Magic:
            if (!((_d = (_c = args.options) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.magic) ||
                !((_f = (_e = args.options) === null || _e === void 0 ? void 0 : _e.metadata.magic) === null || _f === void 0 ? void 0 : _f.apiKey) ||
                !((_h = (_g = args.options) === null || _g === void 0 ? void 0 : _g.metadata.magic) === null || _h === void 0 ? void 0 : _h.rpcEndpoint)) {
                return undefined;
            }
            return new Magic_js_1.default(Object.assign(Object.assign({}, args), { metadata: args.options.metadata.magic }));
        default:
            return undefined;
    }
};
const createStrategies = (args) => {
    return Object.values(enums_js_1.Wallet).reduce((strategies, wallet) => {
        if (strategies[wallet]) {
            return strategies;
        }
        strategies[wallet] = createStrategy({ wallet, args });
        return strategies;
    }, {});
};
class WalletStrategy {
    constructor(args) {
        this.args = args;
        this.strategies = createStrategies(args);
        this.wallet = getInitialWallet(args);
    }
    getWallet() {
        return this.wallet;
    }
    setWallet(wallet) {
        this.wallet = wallet;
    }
    /**
     * Case 1: Private Key is set dynamically
     * If we have a dynamically set private key,
     * we are creating a new PrivateKey strategy
     * with the specified private key
     *
     * Case 2: Wallet Connect Metadata set dynamically
     */
    setOptions(options) {
        if (options === null || options === void 0 ? void 0 : options.privateKey) {
            this.strategies[enums_js_1.Wallet.PrivateKey] = createStrategy({
                args: Object.assign(Object.assign({}, this.args), { options: { privateKey: options.privateKey } }),
                wallet: enums_js_1.Wallet.PrivateKey,
            });
        }
        if (options === null || options === void 0 ? void 0 : options.metadata) {
            this.strategies[enums_js_1.Wallet.WalletConnect] = createStrategy({
                args: Object.assign(Object.assign({}, this.args), { options: { metadata: options.metadata } }),
                wallet: enums_js_1.Wallet.WalletConnect,
            });
        }
    }
    getStrategy() {
        if (!this.strategies[this.wallet]) {
            throw new exceptions_1.GeneralException(new Error(`Wallet ${this.wallet} is not enabled/available!`));
        }
        return this.strategies[this.wallet];
    }
    getAddresses(args) {
        return this.getStrategy().getAddresses(args);
    }
    getWalletDeviceType() {
        return this.getStrategy().getWalletDeviceType();
    }
    getPubKey(address) {
        return this.getStrategy().getPubKey(address);
    }
    enable(args) {
        return this.getStrategy().enable(args);
    }
    enableAndGetAddresses(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getStrategy().enable(args);
            return this.getStrategy().getAddresses(args);
        });
    }
    getEthereumChainId() {
        return this.getStrategy().getEthereumChainId();
    }
    getEthereumTransactionReceipt(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStrategy().getEthereumTransactionReceipt(txHash);
        });
    }
    getSessionOrConfirm(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStrategy().getSessionOrConfirm(address);
        });
    }
    sendTransaction(tx, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStrategy().sendTransaction(tx, options);
        });
    }
    sendEthereumTransaction(tx /* TODO */, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStrategy().sendEthereumTransaction(tx, options);
        });
    }
    /** @deprecated * */
    signTransaction(data, address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStrategy().signTransaction(data, address);
        });
    }
    signEip712TypedData(eip712TypedData, address) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, utils_js_1.isCosmosWallet)(this.wallet)) {
                throw new exceptions_1.WalletException(new Error(`You can't sign Ethereum Transaction using ${this.wallet}`));
            }
            /** Phantom wallet needs enabling before signing */
            if (this.wallet === enums_js_1.Wallet.Phantom) {
                yield this.enable();
            }
            return this.getStrategy().signEip712TypedData(eip712TypedData, address);
        });
    }
    signAminoCosmosTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, utils_js_1.isEthWallet)(this.wallet)) {
                throw new exceptions_1.WalletException(new Error(`You can't sign Cosmos Transaction using ${this.wallet}`));
            }
            return this.getStrategy().signAminoCosmosTransaction(transaction);
        });
    }
    signCosmosTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, utils_js_1.isEthWallet)(this.wallet)) {
                throw new exceptions_1.WalletException(new Error(`You can't sign Cosmos Transaction using ${this.wallet}`));
            }
            return this.getStrategy().signCosmosTransaction(transaction);
        });
    }
    signArbitrary(signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.getStrategy().signArbitrary) {
                return this.getStrategy().signArbitrary(signer, data);
            }
        });
    }
    onAccountChange(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.getStrategy().onAccountChange) {
                return this.getStrategy().onAccountChange(callback);
            }
        });
    }
    onChainIdChange(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.getStrategy().onChainIdChange) {
                return this.getStrategy().onChainIdChange(callback);
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.getStrategy().disconnect) {
                yield this.getStrategy().disconnect();
            }
        });
    }
}
exports.default = WalletStrategy;
//# sourceMappingURL=WalletStrategy.js.map