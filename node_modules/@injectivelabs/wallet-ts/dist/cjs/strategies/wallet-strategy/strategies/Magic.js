"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable class-methods-use-this */
const exceptions_1 = require("@injectivelabs/exceptions");
const magic_sdk_1 = require("magic-sdk");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const oauth2_1 = require("@magic-ext/oauth2");
const cosmos_1 = require("@magic-ext/cosmos");
const Base_js_1 = __importDefault(require("./Base.js"));
const enums_js_1 = require("../../../types/enums.js");
class Magic extends Base_js_1.default {
    constructor(args) {
        var _a;
        if (!((_a = args.metadata) === null || _a === void 0 ? void 0 : _a.apiKey)) {
            throw new exceptions_1.WalletException(new Error('You have to pass the apiKey within metadata to use Magic wallet'));
        }
        if (!args.metadata.rpcEndpoint) {
            throw new exceptions_1.WalletException(new Error('You have to pass the rpc url endpoint within metadata to use Magic wallet'));
        }
        super(args);
        this.metadata = args.metadata;
        this.magicWallet = new magic_sdk_1.Magic(args.metadata.apiKey, {
            extensions: [
                new oauth2_1.OAuthExtension(),
                new cosmos_1.CosmosExtension({
                    rpcUrl: args.metadata.rpcEndpoint,
                    chain: 'inj',
                }),
            ],
        });
    }
    getWalletDeviceType() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(enums_js_1.WalletDeviceType.Browser);
        });
    }
    enable(_a) {
        return __awaiter(this, arguments, void 0, function* ({ email, provider, }) {
            if (!provider) {
                return Promise.resolve(true);
            }
            try {
                if (provider === enums_js_1.MagicProvider.Email) {
                    yield this.connectViaEmail(email);
                }
                else {
                    yield this.connectViaOauth(provider);
                }
                yield this.pollUserLoggedInState();
                return Promise.resolve(true);
            }
            catch (e) {
                throw new exceptions_1.WalletException(new Error(e.message), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletError,
                    contextModule: enums_js_1.WalletAction.GetAccounts,
                });
            }
        });
    }
    connectViaEmail(email) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!email) {
                throw new exceptions_1.WalletException(new Error('You have to pass the email for using Magic wallet'));
            }
            return this.magicWallet.auth.loginWithMagicLink({ email });
        });
    }
    connectViaOauth(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.magicWallet.oauth2.loginWithRedirect({
                provider: provider,
                redirectURI: window.location.origin,
            });
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            const isUserLoggedIn = yield this.magicWallet.user.isLoggedIn();
            if (!isUserLoggedIn) {
                return;
            }
            yield this.magicWallet.user.logout();
        });
    }
    getAddresses(_a) {
        return __awaiter(this, arguments, void 0, function* ({ provider, }) {
            if (!provider) {
                try {
                    yield this.magicWallet.oauth2.getRedirectResult();
                }
                catch (_b) {
                    // fail silently
                }
            }
            try {
                const { publicAddress } = yield this.magicWallet.user.getInfo();
                if (!(publicAddress === null || publicAddress === void 0 ? void 0 : publicAddress.startsWith('inj'))) {
                    const address = yield this.magicWallet.cosmos.changeAddress('inj');
                    return [address || ''];
                }
                return [publicAddress || ''];
            }
            catch (e) {
                throw new exceptions_1.WalletException(new Error(e.message), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletError,
                    contextModule: enums_js_1.WalletAction.GetAccounts,
                });
            }
        });
    }
    // eslint-disable-next-line class-methods-use-this
    getSessionOrConfirm(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
        });
    }
    sendEthereumTransaction(_transaction, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.CosmosWalletException(new Error('sendEthereumTransaction is not supported. Leap only supports sending cosmos transactions'), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: enums_js_1.WalletAction.SendEthereumTransaction,
            });
        });
    }
    sendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { endpoints, txTimeout } = options;
            if (!endpoints) {
                throw new exceptions_1.WalletException(new Error('You have to pass endpoints.grpc within the options for using Magic wallet'));
            }
            const txApi = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
            const response = yield txApi.broadcast(transaction, { txTimeout });
            if (response.code !== 0) {
                throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    contextCode: response.code,
                    contextModule: response.codespace,
                });
            }
            return response;
        });
    }
    /** @deprecated */
    signTransaction(_eip712json, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.WalletException(new Error('This wallet does not support signTransaction'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: enums_js_1.WalletAction.SignTransaction,
            });
        });
    }
    signEip712TypedData(eip712json, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            const signature = yield this.magicWallet.cosmos.signTypedData(eip712json);
            return `0x${signature}`;
        });
    }
    // eslint-disable-next-line class-methods-use-this
    signCosmosTransaction(_transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: enums_js_1.WalletAction.SignTransaction,
            });
        });
    }
    signAminoCosmosTransaction(_transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.WalletException(new Error('This wallet does not support signAminoCosmosTransaction'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: enums_js_1.WalletAction.SignTransaction,
            });
        });
    }
    signArbitrary(_signer, _data) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.WalletException(new Error('This wallet does not support signArbitrary'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: enums_js_1.WalletAction.SignTransaction,
            });
        });
    }
    getEthereumChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.CosmosWalletException(new Error('getEthereumChainId is not supported on Magic wallet'), {
                code: exceptions_1.UnspecifiedErrorCode,
                context: enums_js_1.WalletAction.GetChainId,
            });
        });
    }
    getEthereumTransactionReceipt(_txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.CosmosWalletException(new Error('getEthereumTransactionReceipt is not supported on Cosmostation'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                context: enums_js_1.WalletAction.GetEthereumTransactionReceipt,
            });
        });
    }
    // eslint-disable-next-line class-methods-use-this
    getPubKey() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new exceptions_1.WalletException(new Error('You can only fetch PubKey from Cosmos native wallets'));
        });
    }
    pollUserLoggedInState() {
        return __awaiter(this, arguments, void 0, function* (timeout = 60 * 1000) {
            const POLL_INTERVAL = 3 * 1000;
            for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
                try {
                    const result = yield this.magicWallet.user.isLoggedIn();
                    if (result) {
                        return result;
                    }
                }
                catch (e) {
                    // We throw only if the transaction failed on chain
                    if (e instanceof exceptions_1.TransactionException) {
                        throw e;
                    }
                }
                yield new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
            }
            // Transaction was not included in the block in the desired timeout
            throw new exceptions_1.WalletException(new Error(`User did not verify sign in - timeout of ${timeout}ms`), {
                context: 'Wallet',
                contextModule: 'Magic-Wallet-pollUserLoggedInState',
            });
        });
    }
}
exports.default = Magic;
//# sourceMappingURL=Magic.js.map