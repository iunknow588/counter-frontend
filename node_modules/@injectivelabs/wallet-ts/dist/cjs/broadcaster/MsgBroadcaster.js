"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgBroadcaster = void 0;
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const utils_1 = require("@injectivelabs/utils");
const exceptions_1 = require("@injectivelabs/exceptions");
const networks_1 = require("@injectivelabs/networks");
const utils_js_1 = require("../utils/utils.js");
const utils_js_2 = require("../strategies/wallet-strategy/utils.js");
const index_js_1 = require("../types/index.js");
const index_js_2 = require("../utils/wallets/keplr/index.js");
const index_js_3 = require("../utils/index.js");
const index_js_4 = require("../utils/wallets/index.js");
const helper_js_1 = require("./helper.js");
const getEthereumWalletPubKey = ({ pubKey, eip712TypedData, signature, }) => {
    if (pubKey) {
        return pubKey;
    }
    return (0, sdk_ts_1.hexToBase64)((0, sdk_ts_1.recoverTypedSignaturePubKey)(eip712TypedData, signature));
};
const defaultRetriesConfig = () => ({
    [`${exceptions_1.TransactionChainErrorModule.CosmosSdk}-${exceptions_1.ChainCosmosErrorCode.ErrMempoolIsFull}`]: {
        retries: 0,
        maxRetries: 10,
        timeout: 1000,
    },
});
/**
 * This class is used to broadcast transactions
 * using the WalletStrategy as a handler
 * for the sign/broadcast flow of the transactions
 *
 * Mainly used for building UI products
 */
class MsgBroadcaster {
    constructor(options) {
        this.txTimeout = utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT;
        this.simulateTx = true;
        this.txTimeoutOnFeeDelegation = false;
        this.gasBufferCoefficient = 1.2;
        this.retriesOnError = defaultRetriesConfig();
        const networkInfo = (0, networks_1.getNetworkInfo)(options.network);
        this.options = options;
        this.simulateTx =
            options.simulateTx !== undefined ? options.simulateTx : true;
        this.txTimeout = options.txTimeout || utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT;
        this.txTimeoutOnFeeDelegation =
            options.txTimeoutOnFeeDelegation !== undefined
                ? options.txTimeoutOnFeeDelegation
                : true;
        this.gasBufferCoefficient = options.gasBufferCoefficient || 1.2;
        this.chainId = options.chainId || networkInfo.chainId;
        this.ethereumChainId =
            options.ethereumChainId || networkInfo.ethereumChainId;
        this.endpoints = options.endpoints || (0, networks_1.getNetworkEndpoints)(options.network);
    }
    setOptions(options) {
        this.simulateTx = options.simulateTx || this.simulateTx;
        this.txTimeout = options.txTimeout || this.txTimeout;
        this.txTimeoutOnFeeDelegation =
            options.txTimeoutOnFeeDelegation || this.txTimeoutOnFeeDelegation;
    }
    /**
     * Broadcasting the transaction using the client
     * side approach for both cosmos and ethereum native wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    broadcast(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { options } = this;
            const { walletStrategy } = options;
            const txWithAddresses = Object.assign(Object.assign({}, tx), { ethereumAddress: (0, utils_js_1.getEthereumSignerAddress)(tx.injectiveAddress || tx.address), injectiveAddress: (0, utils_js_1.getInjectiveSignerAddress)(tx.injectiveAddress || tx.address) });
            if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
                throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
            }
            try {
                return (0, utils_js_2.isCosmosWallet)(walletStrategy.wallet)
                    ? yield this.broadcastCosmos(txWithAddresses)
                    : (0, utils_js_2.isEip712V2OnlyWallet)(walletStrategy.wallet)
                        ? yield this.broadcastWeb3V2(txWithAddresses)
                        : yield this.broadcastWeb3(txWithAddresses);
            }
            catch (e) {
                const error = e;
                if ((0, exceptions_1.isThrownException)(error)) {
                    throw error;
                }
                throw new exceptions_1.TransactionException(new Error(error));
            }
        });
    }
    /**
     * Broadcasting the transaction using the client
     * side approach for both cosmos and ethereum native wallets
     * Note: using EIP712_V2 for Ethereum wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    broadcastV2(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { options } = this;
            const { walletStrategy } = options;
            const txWithAddresses = Object.assign(Object.assign({}, tx), { ethereumAddress: (0, utils_js_1.getEthereumSignerAddress)(tx.injectiveAddress || tx.address), injectiveAddress: (0, utils_js_1.getInjectiveSignerAddress)(tx.injectiveAddress || tx.address) });
            if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
                throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
            }
            try {
                return (0, utils_js_2.isCosmosWallet)(walletStrategy.wallet)
                    ? yield this.broadcastCosmos(txWithAddresses)
                    : yield this.broadcastWeb3V2(txWithAddresses);
            }
            catch (e) {
                const error = e;
                if ((0, exceptions_1.isThrownException)(error)) {
                    throw error;
                }
                throw new exceptions_1.TransactionException(new Error(error));
            }
        });
    }
    /**
     * Broadcasting the transaction using the client
     * side approach for cosmos native wallets
     * and feeDelegation support approach for ethereum native
     * wallets (default one)
     *
     * @param tx
     * @returns {string} transaction hash
     * @deprecated
     */
    broadcastOld(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { options } = this;
            const { walletStrategy } = options;
            const txWithAddresses = Object.assign(Object.assign({}, tx), { ethereumAddress: (0, utils_js_1.getEthereumSignerAddress)(tx.injectiveAddress || tx.address), injectiveAddress: (0, utils_js_1.getInjectiveSignerAddress)(tx.injectiveAddress || tx.address) });
            if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
                throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
            }
            return (0, utils_js_2.isCosmosWallet)(walletStrategy.wallet)
                ? yield this.broadcastCosmos(txWithAddresses)
                : yield this.broadcastWeb3WithFeeDelegation(txWithAddresses);
        });
    }
    /**
     * Broadcasting the transaction using the feeDelegation
     * support approach for both cosmos and ethereum native wallets
     *
     * @param tx
     * @returns {TxResponse}
     */
    broadcastWithFeeDelegation(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { options } = this;
            const { walletStrategy } = options;
            const txWithAddresses = Object.assign(Object.assign({}, tx), { ethereumAddress: (0, utils_js_1.getEthereumSignerAddress)(tx.injectiveAddress || tx.address), injectiveAddress: (0, utils_js_1.getInjectiveSignerAddress)(tx.injectiveAddress || tx.address) });
            if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
                throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
            }
            try {
                return (0, utils_js_2.isCosmosWallet)(walletStrategy.wallet)
                    ? yield this.broadcastCosmosWithFeeDelegation(txWithAddresses)
                    : yield this.broadcastWeb3WithFeeDelegation(txWithAddresses);
            }
            catch (e) {
                const error = e;
                if ((0, exceptions_1.isThrownException)(error)) {
                    throw error;
                }
                throw new exceptions_1.TransactionException(new Error(error));
            }
        });
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets on the client side.
     *
     * Note: Gas estimation not available
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    broadcastWeb3(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const { options, chainId, txTimeout, endpoints, ethereumChainId } = this;
            const { walletStrategy } = options;
            const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
            if (!ethereumChainId) {
                throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
            }
            /** Account Details * */
            const accountDetails = yield new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(tx.injectiveAddress);
            const { baseAccount } = accountDetails;
            /** Block Details */
            const latestBlock = yield new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
            const latestHeight = latestBlock.header.height;
            const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
            const gas = (((_a = tx.gas) === null || _a === void 0 ? void 0 : _a.gas) || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
            let stdFee = (0, utils_1.getStdFee)(Object.assign(Object.assign({}, tx.gas), { gas }));
            /**
             * Account has been created on chain
             * and we can simulate the transaction
             * to estimate the gas
             **/
            if (baseAccount.pubKey) {
                const { stdFee: simulatedStdFee } = yield this.getTxWithSignersAndStdFee({
                    chainId,
                    signMode: sdk_ts_1.SIGN_EIP712,
                    memo: tx.memo,
                    message: msgs,
                    timeoutHeight: timeoutHeight.toNumber(),
                    signers: {
                        pubKey: baseAccount.pubKey.key,
                        accountNumber: baseAccount.accountNumber,
                        sequence: baseAccount.sequence,
                    },
                    fee: stdFee,
                });
                stdFee = simulatedStdFee;
            }
            /** EIP712 for signing on Ethereum wallets */
            const eip712TypedData = (0, sdk_ts_1.getEip712TypedData)({
                msgs,
                fee: stdFee,
                tx: {
                    memo: tx.memo,
                    accountNumber: baseAccount.accountNumber.toString(),
                    sequence: baseAccount.sequence.toString(),
                    timeoutHeight: timeoutHeight.toFixed(),
                    chainId,
                },
                ethereumChainId,
            });
            /** Signing on Ethereum */
            const signature = yield walletStrategy.signEip712TypedData(JSON.stringify(eip712TypedData), tx.ethereumAddress);
            const pubKeyOrSignatureDerivedPubKey = getEthereumWalletPubKey({
                pubKey: (_b = baseAccount.pubKey) === null || _b === void 0 ? void 0 : _b.key,
                eip712TypedData,
                signature,
            });
            /** Preparing the transaction for client broadcasting */
            const { txRaw } = (0, sdk_ts_1.createTransaction)({
                message: msgs,
                memo: tx.memo,
                signMode: sdk_ts_1.SIGN_EIP712,
                fee: stdFee,
                pubKey: pubKeyOrSignatureDerivedPubKey,
                sequence: baseAccount.sequence,
                timeoutHeight: timeoutHeight.toNumber(),
                accountNumber: baseAccount.accountNumber,
                chainId,
            });
            const web3Extension = (0, sdk_ts_1.createWeb3Extension)({
                ethereumChainId,
            });
            const txRawEip712 = (0, sdk_ts_1.createTxRawEIP712)(txRaw, web3Extension);
            /** Append Signatures */
            txRawEip712.signatures = [(0, sdk_ts_1.hexToBuff)(signature)];
            return walletStrategy.sendTransaction(txRawEip712, {
                chainId,
                endpoints,
                txTimeout,
                address: tx.injectiveAddress,
            });
        });
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets on the client side.
     *
     * Note: Gas estimation not available
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    broadcastWeb3V2(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const { options, chainId, txTimeout, endpoints, ethereumChainId } = this;
            const { walletStrategy } = options;
            const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
            if (!ethereumChainId) {
                throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
            }
            /** Account Details * */
            const accountDetails = yield new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(tx.injectiveAddress);
            const { baseAccount } = accountDetails;
            /** Block Details */
            const latestBlock = yield new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
            const latestHeight = latestBlock.header.height;
            const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
            const gas = (((_a = tx.gas) === null || _a === void 0 ? void 0 : _a.gas) || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
            let stdFee = (0, utils_1.getStdFee)(Object.assign(Object.assign({}, tx.gas), { gas }));
            /**
             * Account has been created on chain
             * and we can simulate the transaction
             * to estimate the gas
             **/
            if (baseAccount.pubKey) {
                const { stdFee: simulatedStdFee } = yield this.getTxWithSignersAndStdFee({
                    chainId,
                    signMode: sdk_ts_1.SIGN_EIP712_V2,
                    memo: tx.memo,
                    message: msgs,
                    timeoutHeight: timeoutHeight.toNumber(),
                    signers: {
                        pubKey: baseAccount.pubKey.key,
                        accountNumber: baseAccount.accountNumber,
                        sequence: baseAccount.sequence,
                    },
                    fee: stdFee,
                });
                stdFee = simulatedStdFee;
            }
            /** EIP712 for signing on Ethereum wallets */
            const eip712TypedData = (0, sdk_ts_1.getEip712TypedDataV2)({
                msgs,
                fee: stdFee,
                tx: {
                    memo: tx.memo,
                    accountNumber: baseAccount.accountNumber.toString(),
                    sequence: baseAccount.sequence.toString(),
                    timeoutHeight: timeoutHeight.toFixed(),
                    chainId,
                },
                ethereumChainId,
            });
            /** Signing on Ethereum */
            const signature = yield walletStrategy.signEip712TypedData(JSON.stringify(eip712TypedData), tx.ethereumAddress);
            const pubKeyOrSignatureDerivedPubKey = getEthereumWalletPubKey({
                pubKey: (_b = baseAccount.pubKey) === null || _b === void 0 ? void 0 : _b.key,
                eip712TypedData,
                signature,
            });
            const { txRaw } = (0, sdk_ts_1.createTransaction)({
                message: msgs,
                memo: tx.memo,
                signMode: sdk_ts_1.SIGN_EIP712_V2,
                fee: stdFee,
                pubKey: pubKeyOrSignatureDerivedPubKey,
                sequence: baseAccount.sequence,
                timeoutHeight: timeoutHeight.toNumber(),
                accountNumber: baseAccount.accountNumber,
                chainId,
            });
            const web3Extension = (0, sdk_ts_1.createWeb3Extension)({
                ethereumChainId,
            });
            const txRawEip712 = (0, sdk_ts_1.createTxRawEIP712)(txRaw, web3Extension);
            /** Append Signatures */
            txRawEip712.signatures = [(0, sdk_ts_1.hexToBuff)(signature)];
            return walletStrategy.sendTransaction(txRawEip712, {
                chainId,
                endpoints,
                txTimeout,
                address: tx.injectiveAddress,
            });
        });
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets using the Web3Gateway.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    broadcastWeb3WithFeeDelegation(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { options, txTimeout, endpoints, simulateTx, ethereumChainId, txTimeoutOnFeeDelegation, } = this;
            const { walletStrategy } = options;
            const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
            const web3Msgs = msgs.map((msg) => msg.toWeb3());
            if (!ethereumChainId) {
                throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
            }
            const transactionApi = new sdk_ts_1.IndexerGrpcTransactionApi(endpoints.web3gw || endpoints.indexer);
            let timeoutHeight = undefined;
            if (txTimeoutOnFeeDelegation) {
                const latestBlock = yield new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
                const latestHeight = latestBlock.header.height;
                timeoutHeight = new utils_1.BigNumberInBase(latestHeight)
                    .plus(txTimeout)
                    .toNumber();
            }
            const prepareTxResponse = yield transactionApi.prepareTxRequest({
                timeoutHeight,
                memo: tx.memo,
                message: web3Msgs,
                address: tx.ethereumAddress,
                chainId: ethereumChainId,
                gasLimit: (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs),
                estimateGas: simulateTx,
            });
            const signature = yield walletStrategy.signEip712TypedData(prepareTxResponse.data, tx.ethereumAddress);
            const broadcast = () => __awaiter(this, void 0, void 0, function* () {
                return yield transactionApi.broadcastTxRequest({
                    signature,
                    message: web3Msgs,
                    txResponse: prepareTxResponse,
                    chainId: ethereumChainId,
                });
            });
            try {
                const response = yield broadcast();
                return yield new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
            }
            catch (e) {
                const error = e;
                if ((0, exceptions_1.isThrownException)(error)) {
                    const exception = error;
                    /**
                     * First MsgExec transaction with a PrivateKey wallet
                     * always runs out of gas for some reason, temporary solution
                     * to just broadcast the transaction twice
                     **/
                    if (walletStrategy.wallet === index_js_1.Wallet.PrivateKey &&
                        (0, helper_js_1.checkIfTxRunOutOfGas)(exception)) {
                        /** Account Details * */
                        const accountDetails = yield new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(tx.injectiveAddress);
                        const { baseAccount } = accountDetails;
                        /** We only do it on the first account tx fail */
                        if (baseAccount.sequence > 1) {
                            throw e;
                        }
                        return yield this.broadcastWeb3WithFeeDelegation(tx);
                    }
                    return yield this.retryOnException(exception, broadcast);
                }
                throw e;
            }
        });
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Cosmos native wallets on the client side.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    broadcastCosmos(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const { options, txTimeout, endpoints, chainId } = this;
            const { walletStrategy } = options;
            const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
            /**
             * When using Ledger with Keplr/Leap we have
             * to send EIP712 to sign on Keplr/Leap
             */
            if ([index_js_1.Wallet.Keplr, index_js_1.Wallet.Leap].includes(walletStrategy.getWallet())) {
                const walletDeviceType = yield walletStrategy.getWalletDeviceType();
                const isLedgerConnected = walletDeviceType === index_js_1.WalletDeviceType.Hardware;
                if (isLedgerConnected) {
                    return this.experimentalBroadcastWalletThroughLedger(tx);
                }
            }
            /** Account Details * */
            const accountDetails = yield new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(tx.injectiveAddress);
            const { baseAccount } = accountDetails;
            /** Block Details */
            const latestBlock = yield new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
            const latestHeight = latestBlock.header.height;
            const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
            const signMode = (0, index_js_3.isCosmosAminoOnlyWallet)(walletStrategy.wallet)
                ? sdk_ts_1.SIGN_EIP712
                : sdk_ts_1.SIGN_DIRECT;
            const pubKey = yield walletStrategy.getPubKey(tx.injectiveAddress);
            const gas = (((_a = tx.gas) === null || _a === void 0 ? void 0 : _a.gas) || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
            /** Prepare the Transaction * */
            const { txRaw } = yield this.getTxWithSignersAndStdFee({
                chainId,
                signMode,
                memo: tx.memo,
                message: msgs,
                timeoutHeight: timeoutHeight.toNumber(),
                signers: {
                    pubKey,
                    accountNumber: baseAccount.accountNumber,
                    sequence: baseAccount.sequence,
                },
                fee: (0, utils_1.getStdFee)(Object.assign(Object.assign({}, tx.gas), { gas })),
            });
            /** Ledger using Cosmos app only allows signing amino docs */
            if ((0, index_js_3.isCosmosAminoOnlyWallet)(walletStrategy.wallet)) {
                const aminoSignDoc = (0, sdk_ts_1.getAminoStdSignDoc)(Object.assign(Object.assign(Object.assign({}, tx), baseAccount), { msgs,
                    chainId, gas: gas || ((_c = (_b = tx.gas) === null || _b === void 0 ? void 0 : _b.gas) === null || _c === void 0 ? void 0 : _c.toString()), timeoutHeight: timeoutHeight.toFixed() }));
                const signature = (yield walletStrategy.signAminoCosmosTransaction({
                    signDoc: aminoSignDoc,
                    chainId,
                    address: tx.injectiveAddress,
                    accountNumber: baseAccount.accountNumber,
                }));
                txRaw.signatures = [Buffer.from(signature, 'base64')];
                return walletStrategy.sendTransaction(txRaw, {
                    chainId,
                    endpoints,
                    txTimeout,
                    address: tx.injectiveAddress,
                });
            }
            const directSignResponse = (yield walletStrategy.signCosmosTransaction({
                txRaw,
                chainId,
                address: tx.injectiveAddress,
                accountNumber: baseAccount.accountNumber,
            }));
            return walletStrategy.sendTransaction(directSignResponse, {
                chainId,
                endpoints,
                txTimeout,
                address: tx.injectiveAddress,
            });
        });
    }
    /**
     * We use this method only when we want to broadcast a transaction using Ledger on Keplr/Leap for Injective
     *
     * Note: Gas estimation not available
     * @param tx the transaction that needs to be broadcasted
     */
    experimentalBroadcastWalletThroughLedger(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const { options, chainId, txTimeout, endpoints, simulateTx, ethereumChainId, } = this;
            const { walletStrategy } = options;
            const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
            /**
             * We can NOT use this method
             * when Ledger is connected through Keplr
             */
            if ([index_js_1.Wallet.Keplr, index_js_1.Wallet.Leap].includes(walletStrategy.getWallet())) {
                const walletDeviceType = yield walletStrategy.getWalletDeviceType();
                const isLedgerConnected = walletDeviceType === index_js_1.WalletDeviceType.Hardware;
                if (!isLedgerConnected) {
                    throw new exceptions_1.GeneralException(new Error(`This method can only be used when Ledger is connected through ${walletStrategy.getWallet()}`));
                }
            }
            if (!ethereumChainId) {
                throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
            }
            const wallet = walletStrategy.getWallet() === index_js_1.Wallet.Keplr
                ? new index_js_2.KeplrWallet(chainId)
                : new index_js_4.LeapWallet(chainId);
            /** Account Details * */
            const accountDetails = yield new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(tx.injectiveAddress);
            const { baseAccount } = accountDetails;
            /** Block Details */
            const latestBlock = yield new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
            const latestHeight = latestBlock.header.height;
            const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
            const pubKey = yield walletStrategy.getPubKey();
            const gas = (((_a = tx.gas) === null || _a === void 0 ? void 0 : _a.gas) || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
            /** EIP712 for signing on Ethereum wallets */
            const eip712TypedData = (0, sdk_ts_1.getEip712TypedData)({
                msgs,
                fee: (0, utils_1.getStdFee)(Object.assign(Object.assign({}, tx.gas), { gas })),
                tx: {
                    memo: tx.memo,
                    accountNumber: baseAccount.accountNumber.toString(),
                    sequence: baseAccount.sequence.toString(),
                    timeoutHeight: timeoutHeight.toFixed(),
                    chainId,
                },
                ethereumChainId,
            });
            const aminoSignResponse = yield wallet.signEIP712CosmosTx({
                eip712: eip712TypedData,
                signDoc: (0, index_js_2.createEip712StdSignDoc)(Object.assign(Object.assign(Object.assign({}, tx), baseAccount), { msgs,
                    chainId, gas: gas || ((_c = (_b = tx.gas) === null || _b === void 0 ? void 0 : _b.gas) === null || _c === void 0 ? void 0 : _c.toString()), timeoutHeight: timeoutHeight.toFixed() })),
            });
            /**
             * Create TxRaw from the signed tx that we
             * get as a response in case the user changed the fee/memo
             * on the Keplr popup
             */
            const { txRaw } = (0, sdk_ts_1.createTransaction)({
                pubKey,
                message: msgs,
                memo: aminoSignResponse.signed.memo,
                signMode: sdk_ts_1.SIGN_EIP712,
                fee: aminoSignResponse.signed.fee,
                sequence: parseInt(aminoSignResponse.signed.sequence, 10),
                timeoutHeight: parseInt(aminoSignResponse.signed.timeout_height, 10),
                accountNumber: parseInt(aminoSignResponse.signed.account_number, 10),
                chainId,
            });
            /** Preparing the transaction for client broadcasting */
            const web3Extension = (0, sdk_ts_1.createWeb3Extension)({
                ethereumChainId,
            });
            const txRawEip712 = (0, sdk_ts_1.createTxRawEIP712)(txRaw, web3Extension);
            if (simulateTx) {
                yield this.simulateTxRaw(txRawEip712);
            }
            /** Append Signatures */
            const signatureBuff = Buffer.from(aminoSignResponse.signature.signature, 'base64');
            txRawEip712.signatures = [signatureBuff];
            /** Broadcast the transaction */
            const response = yield new sdk_ts_1.TxGrpcApi(endpoints.grpc).broadcast(txRawEip712, { txTimeout });
            if (response.code !== 0) {
                throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    contextCode: response.code,
                    contextModule: response.codespace,
                });
            }
            return response;
        });
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Cosmos native wallets using the Web3Gateway.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    broadcastCosmosWithFeeDelegation(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { options, chainId, txTimeout, endpoints, txTimeoutOnFeeDelegation } = this;
            const { walletStrategy } = options;
            const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
            /**
             * We can only use this method when Keplr is connected
             * with ledger
             */
            if (walletStrategy.getWallet() === index_js_1.Wallet.Keplr) {
                const walletDeviceType = yield walletStrategy.getWalletDeviceType();
                const isLedgerConnectedOnKeplr = walletDeviceType === index_js_1.WalletDeviceType.Hardware;
                if (isLedgerConnectedOnKeplr) {
                    throw new exceptions_1.GeneralException(new Error('Keplr + Ledger is not available with fee delegation. Connect with Ledger directly.'));
                }
            }
            const feePayerPubKey = yield this.fetchFeePayerPubKey(options.feePayerPubKey);
            const feePayerPublicKey = sdk_ts_1.PublicKey.fromBase64(feePayerPubKey);
            const feePayer = feePayerPublicKey.toAddress().address;
            /** Account Details * */
            const chainGrpcAuthApi = new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc);
            const accountDetails = yield chainGrpcAuthApi.fetchAccount(tx.injectiveAddress);
            const feePayerAccountDetails = yield chainGrpcAuthApi.fetchAccount(feePayer);
            const { baseAccount } = accountDetails;
            const { baseAccount: feePayerBaseAccount } = feePayerAccountDetails;
            /** Block Details */
            const latestBlock = yield new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
            const latestHeight = latestBlock.header.height;
            const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeoutOnFeeDelegation ? txTimeout : utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT);
            const pubKey = yield walletStrategy.getPubKey();
            const gas = (((_a = tx.gas) === null || _a === void 0 ? void 0 : _a.gas) || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
            /** Prepare the Transaction * */
            const { txRaw } = yield this.getTxWithSignersAndStdFee({
                chainId,
                memo: tx.memo,
                message: msgs,
                timeoutHeight: timeoutHeight.toNumber(),
                signers: [
                    {
                        pubKey,
                        accountNumber: baseAccount.accountNumber,
                        sequence: baseAccount.sequence,
                    },
                    {
                        pubKey: feePayerPublicKey.toBase64(),
                        accountNumber: feePayerBaseAccount.accountNumber,
                        sequence: feePayerBaseAccount.sequence,
                    },
                ],
                fee: (0, utils_1.getStdFee)(Object.assign(Object.assign({}, tx.gas), { gas, payer: feePayer })),
            });
            // Temporary remove tx gas check because Keplr doesn't recognize feePayer
            if (walletStrategy.wallet === index_js_1.Wallet.Keplr) {
                new index_js_2.KeplrWallet(chainId).disableGasCheck();
            }
            const directSignResponse = (yield walletStrategy.signCosmosTransaction({
                txRaw,
                chainId,
                address: tx.injectiveAddress,
                accountNumber: baseAccount.accountNumber,
            }));
            const transactionApi = new sdk_ts_1.IndexerGrpcTransactionApi(endpoints.web3gw || endpoints.indexer);
            const broadcast = () => __awaiter(this, void 0, void 0, function* () {
                return yield transactionApi.broadcastCosmosTxRequest({
                    address: tx.injectiveAddress,
                    txRaw: (0, sdk_ts_1.createTxRawFromSigResponse)(directSignResponse),
                    signature: directSignResponse.signature.signature,
                    pubKey: directSignResponse.signature.pub_key || {
                        value: pubKey,
                        type: '/injective.crypto.v1beta1.ethsecp256k1.PubKey',
                    },
                });
            });
            try {
                const response = yield broadcast();
                // Re-enable tx gas check removed above
                if (walletStrategy.wallet === index_js_1.Wallet.Keplr) {
                    new index_js_2.KeplrWallet(chainId).enableGasCheck();
                }
                return yield new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
            }
            catch (e) {
                const error = e;
                if ((0, exceptions_1.isThrownException)(error)) {
                    const exception = error;
                    return yield this.retryOnException(exception, broadcast);
                }
                throw e;
            }
        });
    }
    /**
     * Fetch the fee payer's pub key from the web3 gateway
     *
     * Returns a base64 version of it
     */
    fetchFeePayerPubKey(existingFeePayerPubKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (existingFeePayerPubKey) {
                return existingFeePayerPubKey;
            }
            const { endpoints } = this;
            const transactionApi = new sdk_ts_1.IndexerGrpcTransactionApi(endpoints.web3gw || endpoints.indexer);
            const response = yield transactionApi.fetchFeePayer();
            if (!response.feePayerPubKey) {
                throw new exceptions_1.GeneralException(new Error('Please provide a feePayerPubKey'));
            }
            if (response.feePayerPubKey.key.startsWith('0x') ||
                response.feePayerPubKey.key.length === 66) {
                return Buffer.from(response.feePayerPubKey.key, 'hex').toString('base64');
            }
            return response.feePayerPubKey.key;
        });
    }
    /**
     * In case we don't want to simulate the transaction
     * we get the gas limit based on the message type.
     *
     * If we want to simulate the transaction we set the
     * gas limit based on the simulation and add a small multiplier
     * to be safe (factor of 1.2 as default)
     */
    getTxWithSignersAndStdFee(args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { simulateTx } = this;
            if (!simulateTx) {
                return Object.assign(Object.assign({}, (0, sdk_ts_1.createTransactionWithSigners)(args)), { stdFee: (0, utils_1.getStdFee)(args.fee) });
            }
            const result = yield this.simulateTxWithSigners(args);
            if (!((_a = result.gasInfo) === null || _a === void 0 ? void 0 : _a.gasUsed)) {
                return Object.assign(Object.assign({}, (0, sdk_ts_1.createTransactionWithSigners)(args)), { stdFee: (0, utils_1.getStdFee)(args.fee) });
            }
            const stdGasFee = Object.assign({}, (0, utils_1.getStdFee)(Object.assign(Object.assign({}, (0, utils_1.getStdFee)(args.fee)), { gas: new utils_1.BigNumberInBase(result.gasInfo.gasUsed)
                    .times(this.gasBufferCoefficient)
                    .toFixed() })));
            return Object.assign(Object.assign({}, (0, sdk_ts_1.createTransactionWithSigners)(Object.assign(Object.assign({}, args), { fee: stdGasFee }))), { stdFee: stdGasFee });
        });
    }
    /**
     * Create TxRaw and simulate it
     */
    simulateTxRaw(txRaw) {
        return __awaiter(this, void 0, void 0, function* () {
            const { endpoints } = this;
            txRaw.signatures = [new Uint8Array(0)];
            const simulationResponse = yield new sdk_ts_1.TxGrpcApi(endpoints.grpc).simulate(txRaw);
            return simulationResponse;
        });
    }
    /**
     * Create TxRaw and simulate it
     */
    simulateTxWithSigners(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { endpoints } = this;
            const { txRaw } = (0, sdk_ts_1.createTransactionWithSigners)(args);
            txRaw.signatures = Array(Array.isArray(args.signers) ? args.signers.length : 1).fill(new Uint8Array(0));
            const simulationResponse = yield new sdk_ts_1.TxGrpcApi(endpoints.grpc).simulate(txRaw);
            return simulationResponse;
        });
    }
    retryOnException(exception, retryLogic) {
        return __awaiter(this, void 0, void 0, function* () {
            const errorsToRetry = Object.keys(this.retriesOnError);
            const errorKey = `${exception.contextModule}-${exception.contextCode}`;
            if (!errorsToRetry.includes(errorKey)) {
                throw exception;
            }
            const retryConfig = this.retriesOnError[errorKey];
            if (retryConfig.retries >= retryConfig.maxRetries) {
                this.retriesOnError = defaultRetriesConfig();
                throw exception;
            }
            yield (0, utils_1.sleep)(retryConfig.timeout);
            try {
                retryConfig.retries += 1;
                return yield retryLogic();
            }
            catch (e) {
                const error = e;
                if ((0, exceptions_1.isThrownException)(error)) {
                    return this.retryOnException(error, retryLogic);
                }
                throw e;
            }
        });
    }
}
exports.MsgBroadcaster = MsgBroadcaster;
//# sourceMappingURL=MsgBroadcaster.js.map