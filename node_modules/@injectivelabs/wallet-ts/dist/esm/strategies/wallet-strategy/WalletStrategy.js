import { GeneralException, WalletException } from '@injectivelabs/exceptions';
import Okx from './strategies/Okx/index.js';
import Leap from './strategies/Leap.js';
import Keplr from './strategies/Keplr.js';
import Ninji from './strategies/Ninji.js';
import Torus from './strategies/Torus.js';
import Trezor from './strategies/Trezor/index.js';
import BitGet from './strategies/BitGet/index.js';
import Phantom from './strategies/Phantom/index.js';
import Metamask from './strategies/Metamask/index.js';
import PrivateKey from './strategies/PrivateKey.js';
import TrustWallet from './strategies/TrustWallet/index.js';
import Cosmostation from './strategies/Cosmostation.js';
import LedgerCosmos from './strategies/LedgerCosmos/index.js';
import WalletConnect from './strategies/WalletConnect.js';
import LedgerLive from './strategies/Ledger/LedgerLive.js';
import LedgerLegacy from './strategies/Ledger/LedgerLegacy.js';
import Magic from './strategies/Magic.js';
import { isEthWallet, isCosmosWallet } from './utils.js';
import { Wallet } from '../../types/enums.js';
const getInitialWallet = (args) => {
    if (args.wallet) {
        return args.wallet;
    }
    return args.ethereumOptions ? Wallet.Metamask : Wallet.Keplr;
};
const ethereumWalletsDisabled = (args) => {
    const { ethereumOptions } = args;
    if (!ethereumOptions) {
        return true;
    }
    const { ethereumChainId } = ethereumOptions;
    if (!ethereumChainId) {
        return true;
    }
    return false;
};
const createStrategy = ({ args, wallet, }) => {
    const disabledWallets = args.disabledWallets || [];
    if (disabledWallets.includes(wallet)) {
        return undefined;
    }
    /**
     * If we only want to use Cosmos Native Wallets
     * We are not creating strategies for Ethereum Native Wallets
     */
    if (isEthWallet(wallet) && ethereumWalletsDisabled(args)) {
        return undefined;
    }
    const ethWalletArgs = {
        chainId: args.chainId,
        ethereumOptions: args.ethereumOptions,
    };
    switch (wallet) {
        case Wallet.Metamask:
            return new Metamask(ethWalletArgs);
        case Wallet.TrustWallet:
            return new TrustWallet(ethWalletArgs);
        case Wallet.Ledger:
            return new LedgerLive(ethWalletArgs);
        case Wallet.LedgerLegacy:
            return new LedgerLegacy(ethWalletArgs);
        case Wallet.Trezor:
            return new Trezor(ethWalletArgs);
        case Wallet.Torus:
            return new Torus(ethWalletArgs);
        case Wallet.Phantom:
            return new Phantom(ethWalletArgs);
        case Wallet.OkxWallet:
            return new Okx(ethWalletArgs);
        case Wallet.BitGet:
            return new BitGet(ethWalletArgs);
        case Wallet.WalletConnect:
            return new WalletConnect({
                ...ethWalletArgs,
                metadata: args.options?.metadata,
            });
        case Wallet.PrivateKey:
            return new PrivateKey({
                ...ethWalletArgs,
                privateKey: args.options?.privateKey,
            });
        case Wallet.Keplr:
            return new Keplr({ ...args });
        case Wallet.Cosmostation:
            return new Cosmostation({ ...args });
        case Wallet.LedgerCosmos:
            return new LedgerCosmos({ ...args });
        case Wallet.Leap:
            return new Leap({ ...args });
        case Wallet.Ninji:
            return new Ninji({ ...args });
        case Wallet.Magic:
            if (!args.options?.metadata?.magic ||
                !args.options?.metadata.magic?.apiKey ||
                !args.options?.metadata.magic?.rpcEndpoint) {
                return undefined;
            }
            return new Magic({
                ...args,
                metadata: args.options.metadata.magic,
            });
        default:
            return undefined;
    }
};
const createStrategies = (args) => {
    return Object.values(Wallet).reduce((strategies, wallet) => {
        if (strategies[wallet]) {
            return strategies;
        }
        strategies[wallet] = createStrategy({ wallet, args });
        return strategies;
    }, {});
};
export default class WalletStrategy {
    strategies;
    wallet;
    args;
    constructor(args) {
        this.args = args;
        this.strategies = createStrategies(args);
        this.wallet = getInitialWallet(args);
    }
    getWallet() {
        return this.wallet;
    }
    setWallet(wallet) {
        this.wallet = wallet;
    }
    /**
     * Case 1: Private Key is set dynamically
     * If we have a dynamically set private key,
     * we are creating a new PrivateKey strategy
     * with the specified private key
     *
     * Case 2: Wallet Connect Metadata set dynamically
     */
    setOptions(options) {
        if (options?.privateKey) {
            this.strategies[Wallet.PrivateKey] = createStrategy({
                args: { ...this.args, options: { privateKey: options.privateKey } },
                wallet: Wallet.PrivateKey,
            });
        }
        if (options?.metadata) {
            this.strategies[Wallet.WalletConnect] = createStrategy({
                args: { ...this.args, options: { metadata: options.metadata } },
                wallet: Wallet.WalletConnect,
            });
        }
    }
    getStrategy() {
        if (!this.strategies[this.wallet]) {
            throw new GeneralException(new Error(`Wallet ${this.wallet} is not enabled/available!`));
        }
        return this.strategies[this.wallet];
    }
    getAddresses(args) {
        return this.getStrategy().getAddresses(args);
    }
    getWalletDeviceType() {
        return this.getStrategy().getWalletDeviceType();
    }
    getPubKey(address) {
        return this.getStrategy().getPubKey(address);
    }
    enable(args) {
        return this.getStrategy().enable(args);
    }
    async enableAndGetAddresses(args) {
        await this.getStrategy().enable(args);
        return this.getStrategy().getAddresses(args);
    }
    getEthereumChainId() {
        return this.getStrategy().getEthereumChainId();
    }
    async getEthereumTransactionReceipt(txHash) {
        return this.getStrategy().getEthereumTransactionReceipt(txHash);
    }
    async getSessionOrConfirm(address) {
        return this.getStrategy().getSessionOrConfirm(address);
    }
    async sendTransaction(tx, options) {
        return this.getStrategy().sendTransaction(tx, options);
    }
    async sendEthereumTransaction(tx /* TODO */, options) {
        return this.getStrategy().sendEthereumTransaction(tx, options);
    }
    /** @deprecated * */
    async signTransaction(data, address) {
        return this.getStrategy().signTransaction(data, address);
    }
    async signEip712TypedData(eip712TypedData, address) {
        if (isCosmosWallet(this.wallet)) {
            throw new WalletException(new Error(`You can't sign Ethereum Transaction using ${this.wallet}`));
        }
        /** Phantom wallet needs enabling before signing */
        if (this.wallet === Wallet.Phantom) {
            await this.enable();
        }
        return this.getStrategy().signEip712TypedData(eip712TypedData, address);
    }
    async signAminoCosmosTransaction(transaction) {
        if (isEthWallet(this.wallet)) {
            throw new WalletException(new Error(`You can't sign Cosmos Transaction using ${this.wallet}`));
        }
        return this.getStrategy().signAminoCosmosTransaction(transaction);
    }
    async signCosmosTransaction(transaction) {
        if (isEthWallet(this.wallet)) {
            throw new WalletException(new Error(`You can't sign Cosmos Transaction using ${this.wallet}`));
        }
        return this.getStrategy().signCosmosTransaction(transaction);
    }
    async signArbitrary(signer, data) {
        if (this.getStrategy().signArbitrary) {
            return this.getStrategy().signArbitrary(signer, data);
        }
    }
    async onAccountChange(callback) {
        if (this.getStrategy().onAccountChange) {
            return this.getStrategy().onAccountChange(callback);
        }
    }
    async onChainIdChange(callback) {
        if (this.getStrategy().onChainIdChange) {
            return this.getStrategy().onChainIdChange(callback);
        }
    }
    async disconnect() {
        if (this.getStrategy().disconnect) {
            await this.getStrategy().disconnect();
        }
    }
}
//# sourceMappingURL=WalletStrategy.js.map