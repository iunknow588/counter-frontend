/* eslint-disable class-methods-use-this */
import { CosmosChainId, } from '@injectivelabs/ts-types';
import { waitTxBroadcasted, createTxRawFromSigResponse, createSignDocFromTransaction, } from '@injectivelabs/sdk-ts';
import { ErrorType, TransactionException, UnspecifiedErrorCode, CosmosWalletException, } from '@injectivelabs/exceptions';
import { KeplrWallet } from '../../../utils/wallets/keplr/index.js';
import BaseConcreteStrategy from './Base.js';
import { WalletAction, WalletDeviceType, WalletEventListener, } from '../../../types/enums.js';
import { createCosmosSignDocFromSignDoc } from '../../../utils/cosmos.js';
export default class Keplr extends BaseConcreteStrategy {
    keplrWallet;
    constructor(args) {
        super(args);
        this.chainId = args.chainId || CosmosChainId.Injective;
        this.keplrWallet = new KeplrWallet(args.chainId);
    }
    async getWalletDeviceType() {
        const keplrWallet = this.getKeplrWallet();
        const key = await keplrWallet.getKey();
        return key.isNanoLedger
            ? Promise.resolve(WalletDeviceType.Hardware)
            : Promise.resolve(WalletDeviceType.Browser);
    }
    async enable() {
        const keplrWallet = this.getKeplrWallet();
        return await keplrWallet.checkChainIdSupport();
    }
    async disconnect() {
        if (this.listeners[WalletEventListener.AccountChange]) {
            window.removeEventListener('keplr_keystorechange', this.listeners[WalletEventListener.AccountChange]);
        }
        this.listeners = {};
    }
    async getAddresses() {
        const keplrWallet = this.getKeplrWallet();
        try {
            const accounts = await keplrWallet.getAccounts();
            return accounts.map((account) => account.address);
        }
        catch (e) {
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.GetAccounts,
            });
        }
    }
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    // eslint-disable-next-line class-methods-use-this
    async sendEthereumTransaction(_transaction, _options) {
        throw new CosmosWalletException(new Error('sendEthereumTransaction is not supported. Keplr only supports sending cosmos transactions'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendEthereumTransaction,
        });
    }
    async sendTransaction(transaction, options) {
        const { keplrWallet } = this;
        const txRaw = createTxRawFromSigResponse(transaction);
        if (!options.endpoints) {
            throw new CosmosWalletException(new Error('You have to pass endpoints within the options to broadcast transaction'));
        }
        try {
            const txHash = await keplrWallet.broadcastTx(txRaw);
            return await waitTxBroadcasted(txHash, options);
        }
        catch (e) {
            if (e instanceof TransactionException) {
                throw e;
            }
            throw new TransactionException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.SendTransaction,
            });
        }
    }
    /** @deprecated */
    async signTransaction(transaction, injectiveAddress) {
        return this.signCosmosTransaction({
            ...transaction,
            address: injectiveAddress,
        });
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new CosmosWalletException(new Error('This wallet does not support signing using amino'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendTransaction,
        });
    }
    async signCosmosTransaction(transaction) {
        const keplrWallet = this.getKeplrWallet();
        const signer = await keplrWallet.getOfflineSigner();
        const signDoc = createSignDocFromTransaction(transaction);
        try {
            return await signer.signDirect(transaction.address, createCosmosSignDocFromSignDoc(signDoc));
        }
        catch (e) {
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.SendTransaction,
            });
        }
    }
    async signEip712TypedData(_transaction, _address) {
        throw new CosmosWalletException(new Error('This wallet does not support signing Ethereum transactions'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.SendTransaction,
        });
    }
    async signArbitrary(signer, data) {
        const keplrWallet = this.getKeplrWallet();
        const keplr = await keplrWallet.getKeplrWallet();
        try {
            const signature = await keplr.signArbitrary(this.chainId, signer, data);
            return signature.signature;
        }
        catch (e) {
            throw new CosmosWalletException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                context: WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        throw new CosmosWalletException(new Error('getEthereumChainId is not supported on Keplr'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.GetChainId,
        });
    }
    async getEthereumTransactionReceipt(_txHash) {
        throw new CosmosWalletException(new Error('getEthereumTransactionReceipt is not supported on Keplr'), {
            code: UnspecifiedErrorCode,
            context: WalletAction.GetEthereumTransactionReceipt,
        });
    }
    async getPubKey() {
        const keplrWallet = this.getKeplrWallet();
        const key = await keplrWallet.getKey();
        return Buffer.from(key.pubKey).toString('base64');
    }
    async onAccountChange(callback) {
        const listener = async () => {
            const [account] = await this.getAddresses();
            callback(account);
        };
        this.listeners = {
            [WalletEventListener.AccountChange]: listener,
        };
        window.addEventListener('keplr_keystorechange', listener);
    }
    getKeplrWallet() {
        const { keplrWallet } = this;
        if (!keplrWallet) {
            throw new CosmosWalletException(new Error('Please install the Keplr wallet extension'), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletNotInstalledError,
                context: WalletAction.SignTransaction,
            });
        }
        return keplrWallet;
    }
}
//# sourceMappingURL=Keplr.js.map