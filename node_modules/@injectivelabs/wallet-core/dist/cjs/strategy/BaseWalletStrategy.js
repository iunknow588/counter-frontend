"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const eventemitter3_1 = require("eventemitter3");
const exceptions_1 = require("@injectivelabs/exceptions");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const types_js_1 = require("../broadcaster/types.js");
const getInitialWallet = (args) => {
    if (args.wallet) {
        return args.wallet;
    }
    const keys = Object.keys(args.strategies || {});
    if (keys.length === 0) {
        throw new exceptions_1.GeneralException(new Error('No strategies provided to BaseWalletStrategy'));
    }
    if (keys.includes(wallet_base_1.Wallet.Metamask) && args.ethereumOptions) {
        return wallet_base_1.Wallet.Metamask;
    }
    if (keys.includes(wallet_base_1.Wallet.Keplr) && !args.ethereumOptions) {
        return wallet_base_1.Wallet.Keplr;
    }
    return keys[0];
};
class BaseWalletStrategy {
    strategies;
    wallet;
    args;
    metadata;
    wallets;
    emitter;
    on;
    off;
    emit;
    constructor(args) {
        this.args = args;
        this.strategies = args.strategies;
        this.wallet = getInitialWallet(args);
        this.metadata = args.metadata;
        this.emitter = new eventemitter3_1.EventEmitter();
        this.on = this.emitter.on.bind(this.emitter);
        this.off = this.emitter.off.bind(this.emitter);
        this.emit = this.emitter.emit.bind(this.emitter);
    }
    getWallet() {
        return this.wallet;
    }
    setWallet(wallet) {
        this.wallet = wallet;
    }
    setMetadata(metadata) {
        this.metadata = metadata;
        this.getStrategy().setMetadata?.(metadata);
    }
    getStrategy() {
        if (!this.strategies[this.wallet]) {
            throw new exceptions_1.GeneralException(new Error(`Wallet ${this.wallet} is not enabled/available!`));
        }
        return this.strategies[this.wallet];
    }
    getAddresses(args) {
        return this.getStrategy().getAddresses(args);
    }
    getWalletDeviceType() {
        return this.getStrategy().getWalletDeviceType();
    }
    getPubKey(address) {
        return this.getStrategy().getPubKey(address);
    }
    enable(args) {
        return this.getStrategy().enable(args);
    }
    async enableAndGetAddresses(args) {
        await this.getStrategy().enable(args);
        return this.getStrategy().getAddresses(args);
    }
    getEthereumChainId() {
        return this.getStrategy().getEthereumChainId();
    }
    async getEvmTransactionReceipt(txHash, ethereumChainId) {
        return this.getStrategy().getEvmTransactionReceipt(txHash, ethereumChainId);
    }
    async getSessionOrConfirm(address) {
        return this.getStrategy().getSessionOrConfirm(address);
    }
    async getWalletClient() {
        if (this.getStrategy()?.getWalletClient) {
            const result = (this.getStrategy()?.getWalletClient)?.();
            if (result) {
                return result;
            }
        }
        throw new exceptions_1.WalletException(new Error('Wallet client not found. Please check your wallet strategy.'));
    }
    async sendTransaction(tx, options) {
        return this.getStrategy().sendTransaction(tx, options);
    }
    async sendEvmTransaction(tx /* TODO */, options) {
        return this.getStrategy().sendEvmTransaction(tx, options);
    }
    async signEip712TypedData(eip712TypedData, address) {
        if ((0, wallet_base_1.isCosmosWallet)(this.wallet)) {
            throw new exceptions_1.WalletException(new Error(`You can't sign Ethereum Transaction using ${this.wallet}`));
        }
        /** Phantom wallet needs enabling before signing */
        if (this.wallet === wallet_base_1.Wallet.Phantom) {
            await this.enable();
        }
        this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSignStart);
        const response = await this.getStrategy().signEip712TypedData(eip712TypedData, address);
        this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSigned);
        return response;
    }
    async signAminoCosmosTransaction(transaction) {
        if ((0, wallet_base_1.isEvmWallet)(this.wallet)) {
            throw new exceptions_1.WalletException(new Error(`You can't sign Cosmos Transaction using ${this.wallet}`));
        }
        this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSignStart);
        const response = await this.getStrategy().signAminoCosmosTransaction(transaction);
        this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSigned);
        return response;
    }
    async signCosmosTransaction(transaction) {
        if ((0, wallet_base_1.isEvmWallet)(this.wallet)) {
            throw new exceptions_1.WalletException(new Error(`You can't sign Cosmos Transaction using ${this.wallet}`));
        }
        this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSignStart);
        const response = await this.getStrategy().signCosmosTransaction(transaction);
        this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSigned);
        return response;
    }
    async signArbitrary(signer, data) {
        if (this.getStrategy().signArbitrary) {
            this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSignStart);
            const response = await this.getStrategy().signArbitrary(signer, data);
            this.emit(types_js_1.WalletStrategyEmitterEventType.TransactionSigned);
            return response;
        }
    }
    async onAccountChange(callback) {
        if (this.getStrategy().onAccountChange) {
            return this.getStrategy().onAccountChange(callback);
        }
    }
    async onChainIdChange(callback) {
        if (this.getStrategy().onChainIdChange) {
            return this.getStrategy().onChainIdChange(callback);
        }
    }
    async disconnect() {
        if (this.getStrategy().disconnect) {
            await this.getStrategy().disconnect();
            this.emit(types_js_1.WalletStrategyEmitterEventType.WalletStrategyDisconnect);
        }
    }
    getCosmosWallet(chainId) {
        const strategy = this.getStrategy();
        if (strategy.getCosmosWallet == undefined) {
            throw new exceptions_1.WalletException(new Error(`This method is not available for ${this.getWallet()} wallet`));
        }
        return strategy.getCosmosWallet(chainId);
    }
}
exports.default = BaseWalletStrategy;
