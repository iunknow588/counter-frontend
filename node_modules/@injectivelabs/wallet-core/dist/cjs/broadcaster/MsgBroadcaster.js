"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgBroadcaster = void 0;
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const utils_1 = require("@injectivelabs/utils");
const exceptions_1 = require("@injectivelabs/exceptions");
const networks_1 = require("@injectivelabs/networks");
const types_js_1 = require("./types.js");
const index_js_1 = require("../utils/index.js");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const getEthereumWalletPubKey = ({ pubKey, eip712TypedData, signature, }) => {
    if (pubKey) {
        return pubKey;
    }
    return (0, sdk_ts_1.hexToBase64)((0, sdk_ts_1.recoverTypedSignaturePubKey)(eip712TypedData, signature));
};
const defaultRetriesConfig = () => ({
    [`${exceptions_1.TransactionChainErrorModule.CosmosSdk}-${exceptions_1.ChainCosmosErrorCode.ErrMempoolIsFull}`]: {
        retries: 0,
        maxRetries: 10,
        timeout: 1000,
    },
});
/**
 * This class is used to broadcast transactions
 * using the WalletStrategy as a handler
 * for the sign/broadcast flow of the transactions
 *
 * Mainly used for building UI products
 */
class MsgBroadcaster {
    options;
    walletStrategy;
    endpoints;
    chainId;
    txTimeout = utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT;
    simulateTx = true;
    txTimeoutOnFeeDelegation = false;
    ethereumChainId;
    gasBufferCoefficient = 1.2;
    retriesOnError = defaultRetriesConfig();
    httpHeaders;
    constructor(options) {
        const networkInfo = (0, networks_1.getNetworkInfo)(options.network);
        this.options = options;
        this.simulateTx =
            options.simulateTx !== undefined ? options.simulateTx : true;
        this.txTimeout = options.txTimeout || utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT;
        this.txTimeoutOnFeeDelegation =
            options.txTimeoutOnFeeDelegation !== undefined
                ? options.txTimeoutOnFeeDelegation
                : true;
        this.gasBufferCoefficient = options.gasBufferCoefficient || 1.2;
        this.chainId = options.chainId || networkInfo.chainId;
        this.ethereumChainId =
            options.ethereumChainId || networkInfo.ethereumChainId;
        this.endpoints = options.endpoints || (0, networks_1.getNetworkEndpoints)(options.network);
        this.walletStrategy = options.walletStrategy;
        this.httpHeaders = options.httpHeaders;
    }
    setOptions(options) {
        this.simulateTx = options.simulateTx || this.simulateTx;
        this.txTimeout = options.txTimeout || this.txTimeout;
        this.txTimeoutOnFeeDelegation =
            options.txTimeoutOnFeeDelegation || this.txTimeoutOnFeeDelegation;
    }
    /**
     * Broadcasting the transaction using the client
     * side approach for both cosmos and ethereum native wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    async broadcast(tx) {
        const { walletStrategy } = this;
        const txWithAddresses = {
            ...tx,
            ethereumAddress: (0, wallet_base_1.getEthereumSignerAddress)(tx.injectiveAddress),
            injectiveAddress: (0, wallet_base_1.getInjectiveSignerAddress)(tx.injectiveAddress),
        };
        if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
            throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
        }
        try {
            return (0, wallet_base_1.isCosmosWallet)(walletStrategy.wallet)
                ? await this.broadcastDirectSign(txWithAddresses)
                : (0, wallet_base_1.isEip712V2OnlyWallet)(walletStrategy.wallet)
                    ? await this.broadcastEip712V2(txWithAddresses)
                    : await this.broadcastEip712(txWithAddresses);
        }
        catch (e) {
            const error = e;
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionFail);
            if ((0, exceptions_1.isThrownException)(error)) {
                throw error;
            }
            throw new exceptions_1.TransactionException(new Error(error));
        }
    }
    /**
     * Broadcasting the transaction using the client
     * side approach for both cosmos and ethereum native wallets
     * Note: using EIP712_V2 for Ethereum wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    async broadcastV2(tx) {
        const { walletStrategy } = this;
        const txWithAddresses = {
            ...tx,
            ethereumAddress: (0, wallet_base_1.getEthereumSignerAddress)(tx.injectiveAddress),
            injectiveAddress: (0, wallet_base_1.getInjectiveSignerAddress)(tx.injectiveAddress),
        };
        if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
            throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
        }
        try {
            return (0, wallet_base_1.isCosmosWallet)(walletStrategy.wallet)
                ? await this.broadcastDirectSign(txWithAddresses)
                : await this.broadcastEip712V2(txWithAddresses);
        }
        catch (e) {
            const error = e;
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionFail);
            if ((0, exceptions_1.isThrownException)(error)) {
                throw error;
            }
            throw new exceptions_1.TransactionException(new Error(error));
        }
    }
    /**
     * Broadcasting the transaction using the feeDelegation
     * support approach for both cosmos and ethereum native wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    async broadcastWithFeeDelegation(tx) {
        const { walletStrategy } = this;
        const txWithAddresses = {
            ...tx,
            ethereumAddress: (0, wallet_base_1.getEthereumSignerAddress)(tx.injectiveAddress),
            injectiveAddress: (0, wallet_base_1.getInjectiveSignerAddress)(tx.injectiveAddress),
        };
        if (sdk_ts_1.ofacWallets.includes(txWithAddresses.ethereumAddress)) {
            throw new exceptions_1.GeneralException(new Error('You cannot execute this transaction'));
        }
        try {
            return (0, wallet_base_1.isCosmosWallet)(walletStrategy.wallet)
                ? await this.broadcastDirectSignWithFeeDelegation(txWithAddresses)
                : await this.broadcastEip712WithFeeDelegation(txWithAddresses);
        }
        catch (e) {
            const error = e;
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionFail);
            if ((0, exceptions_1.isThrownException)(error)) {
                throw error;
            }
            throw new exceptions_1.TransactionException(new Error(error));
        }
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets on the client side.
     *
     * Note: Gas estimation not available
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    async broadcastEip712(tx) {
        const { chainId, txTimeout, endpoints, ethereumChainId, walletStrategy } = this;
        const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
        if (!ethereumChainId) {
            throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
        }
        /** Account Details * */
        const { baseAccount, latestHeight } = await this.fetchAccountAndBlockDetails(tx.injectiveAddress);
        const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
        const gas = (tx.gas?.gas || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
        let stdFee = (0, utils_1.getStdFee)({ ...tx.gas, gas });
        /**
         * Account has not been created on chain
         * and we cannot simulate the transaction
         * to estimate the gas
         **/
        if (!baseAccount.pubKey) {
            stdFee = await this.getStdFeeWithDynamicBaseFee(stdFee);
        }
        else {
            const { stdFee: simulatedStdFee } = await this.getTxWithSignersAndStdFee({
                chainId,
                signMode: sdk_ts_1.SIGN_EIP712,
                memo: tx.memo,
                message: msgs,
                timeoutHeight: timeoutHeight.toNumber(),
                signers: {
                    pubKey: baseAccount.pubKey.key,
                    accountNumber: baseAccount.accountNumber,
                    sequence: baseAccount.sequence,
                },
                fee: stdFee,
            });
            stdFee = simulatedStdFee;
        }
        /** EIP712 for signing on Ethereum wallets */
        const eip712TypedData = (0, sdk_ts_1.getEip712TypedData)({
            msgs,
            fee: stdFee,
            tx: {
                memo: tx.memo,
                accountNumber: baseAccount.accountNumber.toString(),
                sequence: baseAccount.sequence.toString(),
                timeoutHeight: timeoutHeight.toFixed(),
                chainId,
            },
            ethereumChainId,
        });
        /** Signing on Ethereum */
        const signature = await walletStrategy.signEip712TypedData(JSON.stringify(eip712TypedData), tx.ethereumAddress);
        const pubKeyOrSignatureDerivedPubKey = getEthereumWalletPubKey({
            pubKey: baseAccount.pubKey?.key,
            eip712TypedData,
            signature,
        });
        /** Preparing the transaction for client broadcasting */
        const { txRaw } = (0, sdk_ts_1.createTransaction)({
            message: msgs,
            memo: tx.memo,
            signMode: sdk_ts_1.SIGN_EIP712,
            fee: stdFee,
            pubKey: pubKeyOrSignatureDerivedPubKey,
            sequence: baseAccount.sequence,
            timeoutHeight: timeoutHeight.toNumber(),
            accountNumber: baseAccount.accountNumber,
            chainId,
        });
        const web3Extension = (0, sdk_ts_1.createWeb3Extension)({
            ethereumChainId,
        });
        const txRawEip712 = (0, sdk_ts_1.createTxRawEIP712)(txRaw, web3Extension);
        /** Append Signatures */
        txRawEip712.signatures = [(0, sdk_ts_1.hexToBuff)(signature)];
        const response = await walletStrategy.sendTransaction(txRawEip712, {
            chainId,
            endpoints,
            txTimeout,
            address: tx.injectiveAddress,
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastEnd);
        return await new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets on the client side.
     *
     * Note: Gas estimation not available
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    async broadcastEip712V2(tx) {
        const { chainId, endpoints, txTimeout, walletStrategy, ethereumChainId } = this;
        const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
        if (!ethereumChainId) {
            throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
        }
        /** Account Details * */
        const { baseAccount, latestHeight } = await this.fetchAccountAndBlockDetails(tx.injectiveAddress);
        const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
        const gas = (tx.gas?.gas || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
        let stdFee = (0, utils_1.getStdFee)({ ...tx.gas, gas });
        /**
         * Account has not been created on chain
         * and we cannot simulate the transaction
         * to estimate the gas
         **/
        if (!baseAccount.pubKey) {
            stdFee = await this.getStdFeeWithDynamicBaseFee(stdFee);
        }
        else {
            const { stdFee: simulatedStdFee } = await this.getTxWithSignersAndStdFee({
                chainId,
                signMode: sdk_ts_1.SIGN_EIP712_V2,
                memo: tx.memo,
                message: msgs,
                timeoutHeight: timeoutHeight.toNumber(),
                signers: {
                    pubKey: baseAccount.pubKey.key,
                    sequence: baseAccount.sequence,
                    accountNumber: baseAccount.accountNumber,
                },
                fee: stdFee,
            });
            stdFee = simulatedStdFee;
        }
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationStart);
        /** EIP712 for signing on Ethereum wallets */
        const eip712TypedData = (0, sdk_ts_1.getEip712TypedDataV2)({
            msgs,
            fee: stdFee,
            tx: {
                memo: tx.memo,
                accountNumber: baseAccount.accountNumber.toString(),
                sequence: baseAccount.sequence.toString(),
                timeoutHeight: timeoutHeight.toFixed(),
                chainId,
            },
            ethereumChainId,
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationEnd);
        /** Signing on Ethereum */
        const signature = await walletStrategy.signEip712TypedData(JSON.stringify(eip712TypedData), tx.ethereumAddress);
        const pubKeyOrSignatureDerivedPubKey = getEthereumWalletPubKey({
            pubKey: baseAccount.pubKey?.key,
            eip712TypedData,
            signature,
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastStart);
        const { txRaw } = (0, sdk_ts_1.createTransaction)({
            message: msgs,
            memo: tx.memo,
            signMode: sdk_ts_1.SIGN_EIP712_V2,
            fee: stdFee,
            pubKey: pubKeyOrSignatureDerivedPubKey,
            sequence: baseAccount.sequence,
            timeoutHeight: timeoutHeight.toNumber(),
            accountNumber: baseAccount.accountNumber,
            chainId,
        });
        const web3Extension = (0, sdk_ts_1.createWeb3Extension)({
            ethereumChainId,
        });
        const txRawEip712 = (0, sdk_ts_1.createTxRawEIP712)(txRaw, web3Extension);
        /** Append Signatures */
        txRawEip712.signatures = [(0, sdk_ts_1.hexToBuff)(signature)];
        const response = await walletStrategy.sendTransaction(txRawEip712, {
            chainId,
            endpoints,
            txTimeout,
            address: tx.injectiveAddress,
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastEnd);
        return await new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets using the Web3Gateway.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    async broadcastEip712WithFeeDelegation(tx) {
        const { txTimeout, endpoints, simulateTx, httpHeaders, walletStrategy, ethereumChainId, txTimeoutOnFeeDelegation, } = this;
        const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
        const web3Msgs = msgs.map((msg) => msg.toWeb3());
        if (!ethereumChainId) {
            throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
        }
        const transactionApi = new sdk_ts_1.IndexerGrpcWeb3GwApi(endpoints.web3gw || endpoints.indexer);
        if (httpHeaders) {
            transactionApi.setMetadata(httpHeaders);
        }
        let timeoutHeight = undefined;
        if (txTimeoutOnFeeDelegation) {
            const latestBlock = await new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc).fetchLatestBlock();
            const latestHeight = latestBlock.header.height;
            timeoutHeight = new utils_1.BigNumberInBase(latestHeight)
                .plus(txTimeout)
                .toNumber();
        }
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationStart);
        const prepareTxResponse = await transactionApi.prepareTxRequest({
            timeoutHeight,
            memo: tx.memo,
            message: web3Msgs,
            address: tx.ethereumAddress,
            chainId: ethereumChainId,
            gasLimit: (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs),
            estimateGas: simulateTx,
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationEnd);
        const signature = await walletStrategy.signEip712TypedData(prepareTxResponse.data, tx.ethereumAddress);
        const broadcast = async () => await transactionApi.broadcastTxRequest({
            signature,
            message: web3Msgs,
            txResponse: prepareTxResponse,
            chainId: ethereumChainId,
        });
        try {
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastStart);
            const response = await broadcast();
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastEnd);
            return await new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
        }
        catch (e) {
            const error = e;
            if ((0, exceptions_1.isThrownException)(error)) {
                const exception = error;
                /**
                 * First MsgExec transaction with a PrivateKey wallet
                 * always runs out of gas for some reason, temporary solution
                 * to just broadcast the transaction twice
                 **/
                if (walletStrategy.wallet === wallet_base_1.Wallet.PrivateKey &&
                    (0, index_js_1.checkIfTxRunOutOfGas)(exception)) {
                    /** Account Details * */
                    const accountDetails = await new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc).fetchAccount(tx.injectiveAddress);
                    const { baseAccount } = accountDetails;
                    /** We only do it on the first account tx fail */
                    if (baseAccount.sequence > 1) {
                        throw e;
                    }
                    return await this.broadcastEip712WithFeeDelegation(tx);
                }
                return await this.retryOnException(exception, broadcast);
            }
            throw e;
        }
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Cosmos native wallets on the client side.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    async broadcastDirectSign(tx) {
        const { walletStrategy, txTimeout, endpoints, chainId } = this;
        const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
        /**
         * When using Ledger with Keplr/Leap we have
         * to send EIP712 to sign on Keplr/Leap
         */
        if ([wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.Leap].includes(walletStrategy.getWallet())) {
            const walletDeviceType = await walletStrategy.getWalletDeviceType();
            const isLedgerConnected = walletDeviceType === wallet_base_1.WalletDeviceType.Hardware;
            if (isLedgerConnected) {
                return this.experimentalBroadcastWalletThroughLedger(tx);
            }
        }
        const { baseAccount, latestHeight } = await this.fetchAccountAndBlockDetails(tx.injectiveAddress);
        const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
        const signMode = (0, wallet_base_1.isCosmosAminoOnlyWallet)(walletStrategy.wallet)
            ? sdk_ts_1.SIGN_EIP712
            : sdk_ts_1.SIGN_DIRECT;
        const pubKey = await walletStrategy.getPubKey(tx.injectiveAddress);
        const gas = (tx.gas?.gas || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationStart);
        /** Prepare the Transaction * */
        const { txRaw } = await this.getTxWithSignersAndStdFee({
            chainId,
            signMode,
            memo: tx.memo,
            message: msgs,
            timeoutHeight: timeoutHeight.toNumber(),
            signers: {
                pubKey,
                accountNumber: baseAccount.accountNumber,
                sequence: baseAccount.sequence,
            },
            fee: (0, utils_1.getStdFee)({ ...tx.gas, gas }),
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationEnd);
        /** Ledger using Cosmos app only allows signing amino docs */
        if ((0, wallet_base_1.isCosmosAminoOnlyWallet)(walletStrategy.wallet)) {
            const aminoSignDoc = (0, sdk_ts_1.getAminoStdSignDoc)({
                ...tx,
                ...baseAccount,
                msgs,
                chainId,
                gas: gas || tx.gas?.gas?.toString(),
                timeoutHeight: timeoutHeight.toFixed(),
            });
            const signResponse = await walletStrategy.signAminoCosmosTransaction({
                signDoc: aminoSignDoc,
                address: tx.injectiveAddress,
            });
            txRaw.signatures = [
                Buffer.from(signResponse.signature.signature, 'base64'),
            ];
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastStart);
            const response = await walletStrategy.sendTransaction(txRaw, {
                chainId,
                endpoints,
                txTimeout,
                address: tx.injectiveAddress,
            });
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastEnd);
            return await new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
        }
        const directSignResponse = (await walletStrategy.signCosmosTransaction({
            txRaw,
            chainId,
            address: tx.injectiveAddress,
            accountNumber: baseAccount.accountNumber,
        }));
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastStart);
        const response = await walletStrategy.sendTransaction(directSignResponse, {
            chainId,
            endpoints,
            txTimeout,
            address: tx.injectiveAddress,
        });
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastEnd);
        return await new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
    }
    /**
     * We use this method only when we want to broadcast a transaction using Ledger on Keplr/Leap for Injective
     *
     * Note: Gas estimation not available
     * @param tx the transaction that needs to be broadcasted
     */
    async experimentalBroadcastWalletThroughLedger(tx) {
        const { chainId, txTimeout, endpoints, simulateTx, walletStrategy, ethereumChainId, } = this;
        const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
        /**
         * We can only use this method
         * when Ledger is connected through Keplr
         */
        if ([wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.Leap].includes(walletStrategy.getWallet())) {
            const walletDeviceType = await walletStrategy.getWalletDeviceType();
            const isLedgerConnected = walletDeviceType === wallet_base_1.WalletDeviceType.Hardware;
            if (!isLedgerConnected) {
                throw new exceptions_1.GeneralException(new Error(`This method can only be used when Ledger is connected through ${walletStrategy.getWallet()}`));
            }
        }
        if (!ethereumChainId) {
            throw new exceptions_1.GeneralException(new Error('Please provide ethereumChainId'));
        }
        const cosmosWallet = walletStrategy.getCosmosWallet(chainId);
        const { baseAccount, latestHeight } = await this.fetchAccountAndBlockDetails(tx.injectiveAddress);
        const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeout);
        const pubKey = await walletStrategy.getPubKey();
        const gas = (tx.gas?.gas || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
        /** EIP712 for signing on Ethereum wallets */
        const eip712TypedData = (0, sdk_ts_1.getEip712TypedData)({
            msgs,
            fee: await this.getStdFeeWithDynamicBaseFee({ ...tx.gas, gas }),
            tx: {
                chainId,
                memo: tx.memo,
                timeoutHeight: timeoutHeight.toFixed(),
                sequence: baseAccount.sequence.toString(),
                accountNumber: baseAccount.accountNumber.toString(),
            },
            ethereumChainId,
        });
        const aminoSignResponse = await cosmosWallet.signEIP712CosmosTx({
            eip712: eip712TypedData,
            signDoc: (0, wallet_base_1.createEip712StdSignDoc)({
                ...tx,
                ...baseAccount,
                msgs,
                chainId,
                gas: gas || tx.gas?.gas?.toString(),
                timeoutHeight: timeoutHeight.toFixed(),
            }),
        });
        /**
         * Create TxRaw from the signed tx that we
         * get as a response in case the user changed the fee/memo
         * on the Keplr popup
         */
        const { txRaw } = (0, sdk_ts_1.createTransaction)({
            pubKey,
            message: msgs,
            memo: aminoSignResponse.signed.memo,
            signMode: sdk_ts_1.SIGN_EIP712,
            fee: aminoSignResponse.signed.fee,
            sequence: parseInt(aminoSignResponse.signed.sequence, 10),
            timeoutHeight: parseInt(aminoSignResponse.signed.timeout_height, 10),
            accountNumber: parseInt(aminoSignResponse.signed.account_number, 10),
            chainId,
        });
        /** Preparing the transaction for client broadcasting */
        const web3Extension = (0, sdk_ts_1.createWeb3Extension)({
            ethereumChainId,
        });
        const txRawEip712 = (0, sdk_ts_1.createTxRawEIP712)(txRaw, web3Extension);
        if (simulateTx) {
            await this.simulateTxRaw(txRawEip712);
        }
        /** Append Signatures */
        const signatureBuff = Buffer.from(aminoSignResponse.signature.signature, 'base64');
        txRawEip712.signatures = [signatureBuff];
        /** Broadcast the transaction */
        const response = await new sdk_ts_1.TxGrpcApi(endpoints.grpc).broadcast(txRawEip712, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    /**
     * Prepare/sign/broadcast transaction using
     * Cosmos native wallets using the Web3Gateway.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    async broadcastDirectSignWithFeeDelegation(tx) {
        const { options, chainId, txTimeout, endpoints, httpHeaders, walletStrategy, txTimeoutOnFeeDelegation, } = this;
        const msgs = Array.isArray(tx.msgs) ? tx.msgs : [tx.msgs];
        /**
         * We can only use this method when Keplr is connected
         * with ledger
         */
        if (walletStrategy.getWallet() === wallet_base_1.Wallet.Keplr) {
            const walletDeviceType = await walletStrategy.getWalletDeviceType();
            const isLedgerConnectedOnKeplr = walletDeviceType === wallet_base_1.WalletDeviceType.Hardware;
            if (isLedgerConnectedOnKeplr) {
                throw new exceptions_1.GeneralException(new Error('Keplr + Ledger is not available with fee delegation. Connect with Ledger directly.'));
            }
        }
        const cosmosWallet = walletStrategy.getCosmosWallet(chainId);
        const canDisableCosmosGasCheck = [wallet_base_1.Wallet.Keplr, wallet_base_1.Wallet.OWallet].includes(walletStrategy.wallet);
        const feePayerPubKey = await this.fetchFeePayerPubKey(options.feePayerPubKey);
        const feePayerPublicKey = sdk_ts_1.PublicKey.fromBase64(feePayerPubKey);
        const feePayer = feePayerPublicKey.toAddress().address;
        /** Account Details * */
        const { baseAccount, latestHeight } = await this.fetchAccountAndBlockDetails(tx.injectiveAddress);
        const chainGrpcAuthApi = new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc);
        if (httpHeaders) {
            chainGrpcAuthApi.setMetadata(httpHeaders);
        }
        const feePayerAccountDetails = await chainGrpcAuthApi.fetchAccount(feePayer);
        const { baseAccount: feePayerBaseAccount } = feePayerAccountDetails;
        const timeoutHeight = new utils_1.BigNumberInBase(latestHeight).plus(txTimeoutOnFeeDelegation ? txTimeout : utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT);
        const pubKey = await walletStrategy.getPubKey();
        const gas = (tx.gas?.gas || (0, sdk_ts_1.getGasPriceBasedOnMessage)(msgs)).toString();
        /** Prepare the Transaction * */
        const { txRaw } = await this.getTxWithSignersAndStdFee({
            chainId,
            memo: tx.memo,
            message: msgs,
            timeoutHeight: timeoutHeight.toNumber(),
            signers: [
                {
                    pubKey,
                    accountNumber: baseAccount.accountNumber,
                    sequence: baseAccount.sequence,
                },
                {
                    pubKey: feePayerPublicKey.toBase64(),
                    accountNumber: feePayerBaseAccount.accountNumber,
                    sequence: feePayerBaseAccount.sequence,
                },
            ],
            fee: (0, utils_1.getStdFee)({ ...tx.gas, gas, payer: feePayer }),
        });
        // Temporary remove tx gas check because Keplr doesn't recognize feePayer
        if (canDisableCosmosGasCheck && cosmosWallet.disableGasCheck) {
            cosmosWallet.disableGasCheck(chainId);
        }
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationStart);
        const directSignResponse = (await walletStrategy.signCosmosTransaction({
            txRaw,
            chainId,
            address: tx.injectiveAddress,
            accountNumber: baseAccount.accountNumber,
        }));
        walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionPreparationEnd);
        const transactionApi = new sdk_ts_1.IndexerGrpcWeb3GwApi(endpoints.web3gw || endpoints.indexer);
        if (httpHeaders) {
            transactionApi.setMetadata(httpHeaders);
        }
        const broadcast = async () => await transactionApi.broadcastCosmosTxRequest({
            address: tx.injectiveAddress,
            txRaw: (0, sdk_ts_1.createTxRawFromSigResponse)(directSignResponse),
            signature: directSignResponse.signature.signature,
            pubKey: directSignResponse.signature.pub_key || {
                value: pubKey,
                type: '/injective.crypto.v1beta1.ethsecp256k1.PubKey',
            },
        });
        try {
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastStart);
            const response = await broadcast();
            walletStrategy.emit(types_js_1.WalletStrategyEmitterEventType.TransactionBroadcastEnd);
            // Re-enable tx gas check removed above
            if (canDisableCosmosGasCheck && cosmosWallet.enableGasCheck) {
                cosmosWallet.enableGasCheck(chainId);
            }
            return await new sdk_ts_1.TxGrpcApi(endpoints.grpc).fetchTxPoll(response.txHash);
        }
        catch (e) {
            const error = e;
            if ((0, exceptions_1.isThrownException)(error)) {
                const exception = error;
                return await this.retryOnException(exception, broadcast);
            }
            throw e;
        }
    }
    /**
     * Fetch the fee payer's pub key from the web3 gateway
     *
     * Returns a base64 version of it
     */
    async fetchFeePayerPubKey(existingFeePayerPubKey) {
        if (existingFeePayerPubKey) {
            return existingFeePayerPubKey;
        }
        const { endpoints, httpHeaders } = this;
        const transactionApi = new sdk_ts_1.IndexerGrpcWeb3GwApi(endpoints.web3gw || endpoints.indexer);
        if (httpHeaders) {
            transactionApi.setMetadata(httpHeaders);
        }
        const response = await transactionApi.fetchFeePayer();
        if (!response.feePayerPubKey) {
            throw new exceptions_1.GeneralException(new Error('Please provide a feePayerPubKey'));
        }
        if (response.feePayerPubKey.key.startsWith('0x') ||
            response.feePayerPubKey.key.length === 66) {
            return Buffer.from(response.feePayerPubKey.key, 'hex').toString('base64');
        }
        return response.feePayerPubKey.key;
    }
    async getStdFeeWithDynamicBaseFee(args) {
        const client = new sdk_ts_1.ChainGrpcTxFeesApi(this.endpoints.grpc);
        let baseFee = utils_1.DEFAULT_GAS_PRICE;
        try {
            const response = await client.fetchEipBaseFee();
            baseFee = Number(response?.baseFee || utils_1.DEFAULT_GAS_PRICE);
        }
        catch { }
        if (!args) {
            return (0, utils_1.getStdFee)(baseFee ? { gasPrice: baseFee } : {});
        }
        if (typeof args === 'string') {
            return (0, utils_1.getStdFee)({
                ...(baseFee && {
                    gasPrice: new utils_1.BigNumberInBase(baseFee).toFixed(),
                }),
                gas: args,
            });
        }
        return (0, utils_1.getStdFee)({
            ...args,
            ...(baseFee && {
                gasPrice: new utils_1.BigNumberInBase(baseFee).toFixed(),
            }),
        });
    }
    /**
     * In case we don't want to simulate the transaction
     * we get the gas limit based on the message type.
     *
     * If we want to simulate the transaction we set the
     * gas limit based on the simulation and add a small multiplier
     * to be safe (factor of 1.2 as default)
     */
    async getTxWithSignersAndStdFee(args) {
        const { simulateTx } = this;
        if (!simulateTx) {
            return {
                ...(0, sdk_ts_1.createTransactionWithSigners)(args),
                stdFee: await this.getStdFeeWithDynamicBaseFee(args.fee),
            };
        }
        const result = await this.simulateTxWithSigners(args);
        if (!result.gasInfo?.gasUsed) {
            return {
                ...(0, sdk_ts_1.createTransactionWithSigners)(args),
                stdFee: await this.getStdFeeWithDynamicBaseFee(args.fee),
            };
        }
        const stdGasFee = {
            ...(await this.getStdFeeWithDynamicBaseFee({
                ...(0, utils_1.getStdFee)(args.fee),
                gas: new utils_1.BigNumberInBase(result.gasInfo.gasUsed)
                    .times(this.gasBufferCoefficient)
                    .toFixed(),
            })),
        };
        return {
            ...(0, sdk_ts_1.createTransactionWithSigners)({
                ...args,
                fee: stdGasFee,
            }),
            stdFee: stdGasFee,
        };
    }
    /**
     * Create TxRaw and simulate it
     */
    async simulateTxRaw(txRaw) {
        const { endpoints, httpHeaders } = this;
        txRaw.signatures = [new Uint8Array(0)];
        const client = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        if (httpHeaders) {
            client.setMetadata(httpHeaders);
        }
        const simulationResponse = await client.simulate(txRaw);
        return simulationResponse;
    }
    /**
     * Create TxRaw and simulate it
     */
    async simulateTxWithSigners(args) {
        const { endpoints, httpHeaders } = this;
        const { txRaw } = (0, sdk_ts_1.createTransactionWithSigners)(args);
        txRaw.signatures = Array(Array.isArray(args.signers) ? args.signers.length : 1).fill(new Uint8Array(0));
        const client = new sdk_ts_1.TxGrpcApi(endpoints.grpc);
        if (httpHeaders) {
            client.setMetadata(httpHeaders);
        }
        const simulationResponse = await client.simulate(txRaw);
        return simulationResponse;
    }
    async retryOnException(exception, retryLogic) {
        const errorsToRetry = Object.keys(this.retriesOnError);
        const errorKey = `${exception.contextModule}-${exception.contextCode}`;
        if (!errorsToRetry.includes(errorKey)) {
            throw exception;
        }
        const retryConfig = this.retriesOnError[errorKey];
        if (retryConfig.retries >= retryConfig.maxRetries) {
            this.retriesOnError = defaultRetriesConfig();
            throw exception;
        }
        await (0, utils_1.sleep)(retryConfig.timeout);
        try {
            retryConfig.retries += 1;
            return await retryLogic();
        }
        catch (e) {
            const error = e;
            if ((0, exceptions_1.isThrownException)(error)) {
                return this.retryOnException(error, retryLogic);
            }
            throw e;
        }
    }
    async fetchAccountAndBlockDetails(address) {
        const { endpoints, httpHeaders } = this;
        const chainClient = new sdk_ts_1.ChainGrpcAuthApi(endpoints.grpc);
        const tendermintClient = new sdk_ts_1.ChainGrpcTendermintApi(endpoints.grpc);
        if (httpHeaders) {
            chainClient.setMetadata(httpHeaders);
            tendermintClient.setMetadata(httpHeaders);
        }
        const accountDetails = await chainClient.fetchAccount(address);
        const { baseAccount } = accountDetails;
        const latestBlock = await tendermintClient.fetchLatestBlock();
        const latestHeight = latestBlock.header.height;
        return {
            baseAccount,
            latestHeight,
            accountDetails,
        };
    }
}
exports.MsgBroadcaster = MsgBroadcaster;
