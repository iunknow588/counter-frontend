import { TxResponse } from '@injectivelabs/sdk-ts';
import { NetworkEndpoints } from '@injectivelabs/networks';
import { ChainId, EthereumChainId } from '@injectivelabs/ts-types';
import { MsgBroadcasterOptions, MsgBroadcasterTxOptions } from './types.js';
import BaseWalletStrategy from '../strategy/BaseWalletStrategy.js';
/**
 * This class is used to broadcast transactions
 * using the WalletStrategy as a handler
 * for the sign/broadcast flow of the transactions
 *
 * Mainly used for building UI products
 */
export declare class MsgBroadcaster {
    options: MsgBroadcasterOptions;
    walletStrategy: BaseWalletStrategy;
    endpoints: NetworkEndpoints;
    chainId: ChainId;
    txTimeout: number;
    simulateTx: boolean;
    txTimeoutOnFeeDelegation: boolean;
    ethereumChainId?: EthereumChainId;
    gasBufferCoefficient: number;
    retriesOnError: {
        "sdk-20": {
            retries: number;
            maxRetries: number;
            timeout: number;
        };
    };
    httpHeaders?: Record<string, string>;
    constructor(options: MsgBroadcasterOptions);
    setOptions(options: Partial<MsgBroadcasterOptions>): void;
    /**
     * Broadcasting the transaction using the client
     * side approach for both cosmos and ethereum native wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    broadcast(tx: MsgBroadcasterTxOptions): Promise<TxResponse>;
    /**
     * Broadcasting the transaction using the client
     * side approach for both cosmos and ethereum native wallets
     * Note: using EIP712_V2 for Ethereum wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    broadcastV2(tx: MsgBroadcasterTxOptions): Promise<TxResponse>;
    /**
     * Broadcasting the transaction using the feeDelegation
     * support approach for both cosmos and ethereum native wallets
     *
     * @param tx
     * @returns {string} transaction hash
     */
    broadcastWithFeeDelegation(tx: MsgBroadcasterTxOptions): Promise<TxResponse>;
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets on the client side.
     *
     * Note: Gas estimation not available
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    private broadcastEip712;
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets on the client side.
     *
     * Note: Gas estimation not available
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    private broadcastEip712V2;
    /**
     * Prepare/sign/broadcast transaction using
     * Ethereum native wallets using the Web3Gateway.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    private broadcastEip712WithFeeDelegation;
    /**
     * Prepare/sign/broadcast transaction using
     * Cosmos native wallets on the client side.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    private broadcastDirectSign;
    /**
     * We use this method only when we want to broadcast a transaction using Ledger on Keplr/Leap for Injective
     *
     * Note: Gas estimation not available
     * @param tx the transaction that needs to be broadcasted
     */
    private experimentalBroadcastWalletThroughLedger;
    /**
     * Prepare/sign/broadcast transaction using
     * Cosmos native wallets using the Web3Gateway.
     *
     * @param tx The transaction that needs to be broadcasted
     * @returns transaction hash
     */
    private broadcastDirectSignWithFeeDelegation;
    /**
     * Fetch the fee payer's pub key from the web3 gateway
     *
     * Returns a base64 version of it
     */
    private fetchFeePayerPubKey;
    private getStdFeeWithDynamicBaseFee;
    /**
     * In case we don't want to simulate the transaction
     * we get the gas limit based on the message type.
     *
     * If we want to simulate the transaction we set the
     * gas limit based on the simulation and add a small multiplier
     * to be safe (factor of 1.2 as default)
     */
    private getTxWithSignersAndStdFee;
    /**
     * Create TxRaw and simulate it
     */
    private simulateTxRaw;
    /**
     * Create TxRaw and simulate it
     */
    private simulateTxWithSigners;
    private retryOnException;
    private fetchAccountAndBlockDetails;
}
