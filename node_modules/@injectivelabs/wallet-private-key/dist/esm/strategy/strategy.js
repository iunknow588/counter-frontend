/* eslint-disable class-methods-use-this */
import { ChainId, EthereumChainId, } from '@injectivelabs/ts-types';
import { PrivateKey as PrivateKeySigner, getInjectiveSignerAddress, } from '@injectivelabs/sdk-ts';
import { ErrorType, WalletException, MetamaskException, UnspecifiedErrorCode, TransactionException, } from '@injectivelabs/exceptions';
import { WalletAction, WalletDeviceType, BaseConcreteStrategy, } from '@injectivelabs/wallet-base';
import { toUtf8, TxGrpcApi } from '@injectivelabs/sdk-ts';
export class PrivateKeyWallet extends BaseConcreteStrategy {
    privateKey;
    async getWalletDeviceType() {
        return Promise.resolve(WalletDeviceType.Other);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async disconnect() {
        this.listeners = {};
    }
    async getAddresses() {
        const pk = this.getPrivateKey();
        try {
            return Promise.resolve([pk.toAddress().toHex()]);
        }
        catch (e) {
            throw new MetamaskException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.GetAccounts,
            });
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(_transaction, _options) {
        throw new WalletException(new Error('This wallet does not support sending Ethereum transactions'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            contextModule: WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new WalletException(new Error('You have to pass endpoints within the options for using Ethereum native wallets'));
        }
        const txApi = new TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new TransactionException(new Error(response.rawLog), {
                code: UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const pk = this.getPrivateKey();
        if (getInjectiveSignerAddress(address) !== pk.toAddress().toBech32()) {
            throw new WalletException(new Error('Signer address does not match the private key address'), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.SignTransaction,
            });
        }
        try {
            const signature = await pk.signTypedData(JSON.parse(eip712json));
            return `0x${Buffer.from(signature).toString('hex')}`;
        }
        catch (e) {
            throw new MetamaskException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.SignTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            contextModule: WalletAction.SignTransaction,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: UnspecifiedErrorCode,
            type: ErrorType.WalletError,
            contextModule: WalletAction.SignTransaction,
        });
    }
    async signArbitrary(signer, data) {
        const pk = this.getPrivateKey();
        if (getInjectiveSignerAddress(signer) !== pk.toAddress().toBech32()) {
            throw new WalletException(new Error('Signer address does not match the private key address'), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.SignArbitrary,
            });
        }
        try {
            const signature = await pk.signHashed(Buffer.from(toUtf8(data), 'utf-8'));
            return `0x${Buffer.from(signature).toString('base64')}`;
        }
        catch (e) {
            throw new MetamaskException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        try {
            return Promise.resolve((this.chainId === ChainId.Mainnet
                ? EthereumChainId.Mainnet
                : EthereumChainId.Sepolia).toString(16));
        }
        catch (e) {
            throw new MetamaskException(new Error(e.message), {
                code: UnspecifiedErrorCode,
                type: ErrorType.WalletError,
                contextModule: WalletAction.GetChainId,
            });
        }
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new WalletException(new Error('Not supported'));
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        const pk = this.getPrivateKey();
        return pk.toPublicKey().toBase64();
    }
    async onChainIdChanged(_callback) {
        //
    }
    async onAccountChange(_callback) {
        //
    }
    getPrivateKey() {
        if (!this.privateKey) {
            if (!this.metadata?.privateKey?.privateKey) {
                throw new WalletException(new Error('Please provide private key in the constructor'), {
                    code: UnspecifiedErrorCode,
                    type: ErrorType.WalletNotInstalledError,
                    contextModule: WalletAction.GetAccounts,
                });
            }
            this.privateKey = PrivateKeySigner.fromHex(this.metadata.privateKey.privateKey);
        }
        return this.privateKey;
    }
}
