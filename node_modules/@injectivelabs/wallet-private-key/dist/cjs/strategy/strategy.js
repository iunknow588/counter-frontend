"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKeyWallet = void 0;
/* eslint-disable class-methods-use-this */
const ts_types_1 = require("@injectivelabs/ts-types");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const exceptions_1 = require("@injectivelabs/exceptions");
const wallet_base_1 = require("@injectivelabs/wallet-base");
const sdk_ts_2 = require("@injectivelabs/sdk-ts");
class PrivateKeyWallet extends wallet_base_1.BaseConcreteStrategy {
    privateKey;
    async getWalletDeviceType() {
        return Promise.resolve(wallet_base_1.WalletDeviceType.Other);
    }
    async enable() {
        return Promise.resolve(true);
    }
    async disconnect() {
        this.listeners = {};
    }
    async getAddresses() {
        const pk = this.getPrivateKey();
        try {
            return Promise.resolve([pk.toAddress().toHex()]);
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetAccounts,
            });
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getSessionOrConfirm(address) {
        return Promise.resolve(`0x${Buffer.from(`Confirmation for ${address} at time: ${Date.now()}`).toString('hex')}`);
    }
    async sendEvmTransaction(_transaction, _options) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support sending Ethereum transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SendEvmTransaction,
        });
    }
    async sendTransaction(transaction, options) {
        const { endpoints, txTimeout } = options;
        if (!endpoints) {
            throw new exceptions_1.WalletException(new Error('You have to pass endpoints within the options for using Ethereum native wallets'));
        }
        const txApi = new sdk_ts_2.TxGrpcApi(endpoints.grpc);
        const response = await txApi.broadcast(transaction, { txTimeout });
        if (response.code !== 0) {
            throw new exceptions_1.TransactionException(new Error(response.rawLog), {
                code: exceptions_1.UnspecifiedErrorCode,
                contextCode: response.code,
                contextModule: response.codespace,
            });
        }
        return response;
    }
    async signEip712TypedData(eip712json, address) {
        const pk = this.getPrivateKey();
        if ((0, sdk_ts_1.getInjectiveSignerAddress)(address) !== pk.toAddress().toBech32()) {
            throw new exceptions_1.WalletException(new Error('Signer address does not match the private key address'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
        try {
            const signature = await pk.signTypedData(JSON.parse(eip712json));
            return `0x${Buffer.from(signature).toString('hex')}`;
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignTransaction,
            });
        }
    }
    async signAminoCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async signCosmosTransaction(_transaction) {
        throw new exceptions_1.WalletException(new Error('This wallet does not support signing Cosmos transactions'), {
            code: exceptions_1.UnspecifiedErrorCode,
            type: exceptions_1.ErrorType.WalletError,
            contextModule: wallet_base_1.WalletAction.SignTransaction,
        });
    }
    async signArbitrary(signer, data) {
        const pk = this.getPrivateKey();
        if ((0, sdk_ts_1.getInjectiveSignerAddress)(signer) !== pk.toAddress().toBech32()) {
            throw new exceptions_1.WalletException(new Error('Signer address does not match the private key address'), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignArbitrary,
            });
        }
        try {
            const signature = await pk.signHashed(Buffer.from((0, sdk_ts_2.toUtf8)(data), 'utf-8'));
            return `0x${Buffer.from(signature).toString('base64')}`;
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.SignArbitrary,
            });
        }
    }
    async getEthereumChainId() {
        try {
            return Promise.resolve((this.chainId === ts_types_1.ChainId.Mainnet
                ? ts_types_1.EthereumChainId.Mainnet
                : ts_types_1.EthereumChainId.Sepolia).toString(16));
        }
        catch (e) {
            throw new exceptions_1.MetamaskException(new Error(e.message), {
                code: exceptions_1.UnspecifiedErrorCode,
                type: exceptions_1.ErrorType.WalletError,
                contextModule: wallet_base_1.WalletAction.GetChainId,
            });
        }
    }
    async getEvmTransactionReceipt(_txHash) {
        throw new exceptions_1.WalletException(new Error('Not supported'));
    }
    // eslint-disable-next-line class-methods-use-this
    async getPubKey() {
        const pk = this.getPrivateKey();
        return pk.toPublicKey().toBase64();
    }
    async onChainIdChanged(_callback) {
        //
    }
    async onAccountChange(_callback) {
        //
    }
    getPrivateKey() {
        if (!this.privateKey) {
            if (!this.metadata?.privateKey?.privateKey) {
                throw new exceptions_1.WalletException(new Error('Please provide private key in the constructor'), {
                    code: exceptions_1.UnspecifiedErrorCode,
                    type: exceptions_1.ErrorType.WalletNotInstalledError,
                    contextModule: wallet_base_1.WalletAction.GetAccounts,
                });
            }
            this.privateKey = sdk_ts_1.PrivateKey.fromHex(this.metadata.privateKey.privateKey);
        }
        return this.privateKey;
    }
}
exports.PrivateKeyWallet = PrivateKeyWallet;
