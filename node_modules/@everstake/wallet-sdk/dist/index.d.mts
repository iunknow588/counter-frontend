import BigNumber from 'bignumber.js';
import { Contract } from 'web3';
import { PublicKey, AccountInfo, ParsedAccountData, VersionedTransaction, Lockup, TransactionInstruction, Signer, EpochInfo } from '@solana/web3.js';
import * as superstruct from 'superstruct';
import { Infer } from 'superstruct';

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */
declare const ABI_CONTRACT_ACCOUNTING: readonly [{
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "InvalidParam";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "InvalidValue";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "ZeroValue";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "round";
        readonly type: "uint256";
    }];
    readonly name: "ActivateRound";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "AddWithdrawRequest";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "Autocompound";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "int256";
        readonly name: "";
        readonly type: "int256";
    }];
    readonly name: "ChangeExpectValidatorsToStop";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "ClaimPoolFee";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "ClaimWithdrawRequest";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "DepositPending";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "newFee";
        readonly type: "uint256";
    }];
    readonly name: "FeeUpdated";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "oldGovernor";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "newGovernor";
        readonly type: "address";
    }];
    readonly name: "GovernorChanged";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint8";
        readonly name: "version";
        readonly type: "uint8";
    }];
    readonly name: "Initialized";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "InterchangeDeposit";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "InterchangeWithdraw";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "previousOwner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "OwnershipTransferred";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "superAdmin";
        readonly type: "address";
    }];
    readonly name: "SetSuperAdmin";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "rewarderBalance";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "reward";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "fee";
        readonly type: "uint256";
    }];
    readonly name: "Update";
    readonly type: "event";
}, {
    readonly inputs: readonly [];
    readonly name: "BEACON_AMOUNT";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "FEE_DENOMINATOR";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "governor";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "owner";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "renounceOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "value";
        readonly type: "address";
    }];
    readonly name: "setSuperAdmin";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "superAdmin";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "transferOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "poolFee";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "rewardsTreasury";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "withdrawTreasury";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "accountingGovernor";
        readonly type: "address";
    }];
    readonly name: "initialize";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "depositToPendingValue";
        readonly type: "uint256";
    }];
    readonly name: "deposit";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "interchangedAmount";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "activatedSlots";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "balance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "pendingDepositedBalance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "pendingBalance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "autocompoundBalanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "autocompoundBalance";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "depositedBalanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "pendingDepositedBalanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "pendingBalanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly name: "withdrawPending";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "withdraw";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "withdrawFromPendingAmount";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "claimPoolFee";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "getPoolFee";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "feeBalance";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "update";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "feeValue";
        readonly type: "uint256";
    }];
    readonly name: "setFee";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "autocompound";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "pendingRestakedRewards";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "pendingRestakedRewardOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "restakedRewardOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "withdrawRequestQueueParams";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }];
    readonly name: "withdrawRequest";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "claimWithdrawRequest";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "readyforAutocompoundRewardsAmount";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "unclaimedReward";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "closeValidatorsStat";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "stakeAmount";
        readonly type: "uint256";
    }];
    readonly name: "setMinRestakeAmount";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "activatedValidatorNum";
        readonly type: "uint256";
    }];
    readonly name: "activateValidators";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];
declare const ABI_CONTRACT_POOL: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "InvalidAmount";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "InvalidParam";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "InvalidValue";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "Paused";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "string";
        readonly name: "field";
        readonly type: "string";
    }];
    readonly name: "ZeroValue";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "oldGovernor";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "newGovernor";
        readonly type: "address";
    }];
    readonly name: "GovernorChanged";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint8";
        readonly name: "version";
        readonly type: "uint8";
    }];
    readonly name: "Initialized";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "previousOwner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "OwnershipTransferStarted";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "previousOwner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "OwnershipTransferred";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly name: "PauseStaking";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly name: "PauseWithdraw";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bytes";
        readonly name: "oldPendingValidatorPubKey";
        readonly type: "bytes";
    }, {
        readonly indexed: false;
        readonly internalType: "bytes";
        readonly name: "newPendingValidatorPubKey";
        readonly type: "bytes";
    }];
    readonly name: "PendingValidatorReplaced";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly name: "Restake";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "SetMinStakeAmount";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "superAdmin";
        readonly type: "address";
    }];
    readonly name: "SetSuperAdmin";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "StakeActivated";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint64";
        readonly name: "source";
        readonly type: "uint64";
    }];
    readonly name: "StakeAdded";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }];
    readonly name: "StakeCanceled";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bytes";
        readonly name: "validator";
        readonly type: "bytes";
    }];
    readonly name: "StakeDeposited";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "staker";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly indexed: false;
        readonly internalType: "uint64";
        readonly name: "source";
        readonly type: "uint64";
    }];
    readonly name: "Unstake";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: false;
        readonly internalType: "bytes";
        readonly name: "validator";
        readonly type: "bytes";
    }];
    readonly name: "ValidatorMarkedAsExited";
    readonly type: "event";
}, {
    readonly inputs: readonly [];
    readonly name: "BEACON_AMOUNT";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "acceptOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "governor";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "owner";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "pendingOwner";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "renounceOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "value";
        readonly type: "address";
    }];
    readonly name: "setSuperAdmin";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "superAdmin";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "newOwner";
        readonly type: "address";
    }];
    readonly name: "transferOwnership";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "depositContract";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "accountingContract";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "withdrawTreasury";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "rewardsTreasury";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "poolGovernor";
        readonly type: "address";
    }];
    readonly name: "initialize";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint64";
        readonly name: "source";
        readonly type: "uint64";
    }];
    readonly name: "stake";
    readonly outputs: readonly [];
    readonly stateMutability: "payable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly name: "unstakePending";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly internalType: "uint16";
        readonly name: "allowedInterchangeNum";
        readonly type: "uint16";
    }, {
        readonly internalType: "uint64";
        readonly name: "source";
        readonly type: "uint64";
    }];
    readonly name: "unstake";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "unstakeFromPendingValue";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "activateStake";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "activatedSlots";
        readonly type: "uint256";
    }];
    readonly name: "restake";
    readonly outputs: readonly [];
    readonly stateMutability: "payable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly components: readonly [{
            readonly internalType: "bytes";
            readonly name: "pubkey";
            readonly type: "bytes";
        }, {
            readonly internalType: "bytes";
            readonly name: "signature";
            readonly type: "bytes";
        }, {
            readonly internalType: "bytes32";
            readonly name: "deposit_data_root";
            readonly type: "bytes32";
        }];
        readonly internalType: "struct ValidatorList.DepositData[]";
        readonly name: "pendingValidators";
        readonly type: "tuple[]";
    }];
    readonly name: "setPendingValidators";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "getPendingValidatorCount";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "index";
        readonly type: "uint256";
    }];
    readonly name: "getPendingValidator";
    readonly outputs: readonly [{
        readonly internalType: "bytes";
        readonly name: "";
        readonly type: "bytes";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "getValidatorCount";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "index";
        readonly type: "uint256";
    }];
    readonly name: "getValidator";
    readonly outputs: readonly [{
        readonly internalType: "bytes";
        readonly name: "";
        readonly type: "bytes";
    }, {
        readonly internalType: "enum ValidatorList.ValidatorStatus";
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "index";
        readonly type: "uint256";
    }, {
        readonly components: readonly [{
            readonly internalType: "bytes";
            readonly name: "pubkey";
            readonly type: "bytes";
        }, {
            readonly internalType: "bytes";
            readonly name: "signature";
            readonly type: "bytes";
        }, {
            readonly internalType: "bytes32";
            readonly name: "deposit_data_root";
            readonly type: "bytes32";
        }];
        readonly internalType: "struct ValidatorList.DepositData";
        readonly name: "pendingValidator";
        readonly type: "tuple";
    }];
    readonly name: "replacePendingValidator";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "num";
        readonly type: "uint256";
    }];
    readonly name: "markValidatorsAsExited";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "index";
        readonly type: "uint256";
    }];
    readonly name: "markValidatorAsExited";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "reorderPending";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bool";
        readonly name: "pause";
        readonly type: "bool";
    }];
    readonly name: "pauseStaking";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bool";
        readonly name: "pause";
        readonly type: "bool";
    }];
    readonly name: "pauseWithdraw";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "newGovernor";
        readonly type: "address";
    }];
    readonly name: "setGovernor";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "minStakeAmount";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "stakeAmount";
        readonly type: "uint256";
    }];
    readonly name: "setMinStakeAmount";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */
type EthNetworkType = 'mainnet' | 'holesky';
interface EthNetworkAddresses {
    addressContractAccounting: string;
    addressContractPool: string;
    addressContractWithdrawTreasury: string;
    rpcUrl: string;
}
type EthNetworkAddressesMap = {
    [K in EthNetworkType]: EthNetworkAddresses;
};
type EthTransaction = {
    from: string;
    to: string;
    value: number;
    gasLimit: number;
    data: string;
};
declare enum ValidatorStatus {
    Unknown = 0,
    Pending = 1,
    Deposited = 2
}
interface AggregatedBalances {
    [key: string]: string;
}

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */
/**
 * `WalletSDKError` is a custom error class that extends the built-in `Error` class.
 * It provides additional properties for error handling within the Wallet SDK.
 *
 * @remarks
 * This class is needed to provide additional context for errors, such as a code
 * and the original error, if any.
 *
 * @public
 *
 * @param message - The error message.
 * @param code - A string representing the error code.
 * @param originalError - The original error that caused this error, if any.
 */
declare class WalletSDKError extends Error {
    code: string;
    originalError?: Error | undefined;
    constructor(message: string, code: string, originalError?: Error | undefined);
}
/**
 * `Blockchain` is an abstract class that provides a structure for blockchain-specific classes.
 * It includes methods for error handling and throwing errors.
 *
 * @remarks
 * This class should be extended by classes that implement blockchain-specific functionality.
 * The extending classes should provide their own `ERROR_MESSAGES` and `ORIGINAL_ERROR_MESSAGES`.
 *
 * @property ERROR_MESSAGES - An object that maps error codes to error messages.
 * @property ORIGINAL_ERROR_MESSAGES - An object that maps original error messages to user-friendly error messages.
 *
 *
 * **/
declare abstract class Blockchain {
    protected abstract ERROR_MESSAGES: {
        [key: string]: string;
    };
    protected abstract ORIGINAL_ERROR_MESSAGES: {
        [key: string]: string;
    };
    /**
     * Handles errors that occur within the Ethereum class.
     *
     * @param {keyof typeof ERROR_MESSAGES} code - The error code associated with the error.
     * @param {Error | WalletSDKError | unknown} originalError - The original error that was thrown.
     *
     * If the original error is an instance of WalletSDKError, it is thrown as is.
     * If the original error is an instance of the built-in Error class, a new WalletSDKError is thrown with the original error as the cause.
     * If the original error is not an instance of WalletSDKError or Error, a new WalletSDKError is thrown with a generic message and code.
     */
    handleError(code: keyof typeof this.ERROR_MESSAGES, originalError: Error | WalletSDKError | unknown): void;
    /**
     * Throws a WalletSDKError with a specified error code and message.
     *
     * @param {keyof typeof ERROR_MESSAGES} code - The error code associated with the error.
     * @param {...string[]} values - The values to be inserted into the error message.
     *
     * The method retrieves the error message template associated with the provided code from the ERROR_MESSAGES object.
     * It then replaces placeholders in the message template with provided values and throws a WalletSDKError with the final message and the provided code.
     */
    throwError(code: keyof typeof this.ERROR_MESSAGES, ...values: string[]): void;
    /**
     * Check if the URL is valid
     *
     * @param {string} url - URL
     * @returns a bool type result.
     *
     */
    isValidURL(url: string): boolean;
}

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */

/**
 * The `Ethereum` class extends the `Blockchain` class and provides methods for interacting with the Ethereum network.
 *
 * It allows you to select a network, initialize it, and retrieve the balance of the contract.
 *
 * @property {provider} rpcUrl - The RPC URL of the Ethereum network.
 * @property {Web3} web3 - The Web3 instance used for interacting with the Ethereum network.
 * @property {string} addressContractAccounting - The address of the accounting contract.
 * @property {string} addressContractPool - The address of the pool contract.
 * @property {string} addressContractWithdrawTreasury - The address of the withdraw treasury contract.
 * @property {Contract} contractAccounting - The accounting contract instance.
 * @property {Contract} contractPool - The pool contract instance.
 * @property ERROR_MESSAGES - The error messages for the Ethereum class.
 * @property ORIGINAL_ERROR_MESSAGES - The original error messages for the Ethereum class.
 *
 */
declare class Ethereum extends Blockchain {
    addressContractAccounting: string;
    addressContractPool: string;
    addressContractWithdrawTreasury: string;
    contractAccounting: Contract<typeof ABI_CONTRACT_ACCOUNTING>;
    contractPool: Contract<typeof ABI_CONTRACT_POOL>;
    private rpcUrl;
    private web3;
    private minAmount;
    protected ERROR_MESSAGES: {
        BALANCE_ERROR: string;
        PENDING_BALANCE_ERROR: string;
        PENDING_DEPOSITED_BALANCE_ERROR: string;
        PENDING_RESTAKED_REWARDS_ERROR: string;
        READY_FOR_AUTOCOMPOUND_REWARDS_AMOUNT_ERROR: string;
        PENDING_BALANCE_OF_ERROR: string;
        PENDING_DEPOSITED_BALANCE_OF_ERROR: string;
        DEPOSITED_BALANCE_OF_ERROR: string;
        PENDING_RESTAKED_REWARD_OF_ERROR: string;
        RESTAKED_REWARD_OF_ERROR: string;
        GET_POOL_FEE_ERROR: string;
        MIN_STAKE_AMOUNT_ERROR: string;
        GET_VALIDATOR_ERROR: string;
        GET_VALIDATOR_COUNT_ERROR: string;
        GET_PENDING_VALIDATOR_ERROR: string;
        GET_PENDING_VALIDATOR_COUNT_ERROR: string;
        ACTIVATE_STAKE_ERROR: string;
        MIN_AMOUNT_ERROR: string;
        UNSTAKE_PENDING_ERROR: string;
        INSUFFICIENT_PENDING_BALANCE_ERROR: string;
        ZERO_UNSTAKE_MESSAGE: string;
        AMOUNT_GREATER_THAN_PENDING_BALANCE_ERROR: string;
        NETWORK_NOT_SUPPORTED: string;
        NO_REWARDS_MESSAGE: string;
        AUTOCOMPOUND_ERROR: string;
        AUTOCOMPOUND_BALANCE_OF_ERROR: string;
        WITHDRAW_REQUEST_QUEUE_PARAMS_ERROR: string;
        WITHDRAW_REQUEST_ERROR: string;
        ZERO_UNSTAKE_ERROR: string;
        NOT_FILLED_UNSTAKE_MESSAGE: string;
        WRONG_TYPE_MESSAGE: string;
        CLAIM_WITHDRAW_REQUEST_ERROR: string;
        CLOSE_VALIDATORS_STAT_ERROR: string;
        STAKE_ERROR: string;
        UNSTAKE_ERROR: string;
        SIMULATE_UNSTAKE_ERROR: string;
        MAX_AMOUNT_FOR_UNSTAKE_ERROR: string;
        ADDRESS_FORMAT_ERROR: string;
        USER_BALANCES_ERROR: string;
        POOL_BALANCES_ERROR: string;
    };
    protected ORIGINAL_ERROR_MESSAGES: {
        'InvalidValue: remainder': string;
        'InvalidValue: amount': string;
        'InvalidValue: pending balance': string;
        'ZeroValue: pending': string;
        'ZeroValue: claim': string;
        'InvalidParam: index': string;
        'InvalidParam: caller': string;
        'InvalidValue: zero amount': string;
        'InvalidValue: share': string;
        'InvalidValue: withdrawable balance': string;
        'Paused: withdraw claim': string;
        'Paused: staking': string;
        'Paused: withdraw': string;
        'InvalidAmount: small stake': string;
        'Pending validator': string;
        'Returned error: execution reverted': string;
    };
    constructor(network?: EthNetworkType, url?: string);
    /**
     * Retrieves the balance of the contract.
     *
     * This method calls the `balance` method on the `contractAccounting` contract,
     * converts the result from Wei to Ether, and returns the result as a `BigNumber`.
     *
     * @returns A promise that resolves to the balance of the contract as a `BigNumber`.
     *
     * @throws Will throw an error if the contract call fails.
     */
    balance(): Promise<BigNumber>;
    /**
     * Fetches the pool pending balance. This balance is always less than 32 ETH.
     *
     * @returns A Promise that resolves to the pending balance in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    pendingBalance(): Promise<BigNumber>;
    /**
     * Fetches the pool pending deposited balance. This is the balance deposited into the Beacon deposit contract but validators are still not active.
     *
     * @returns A Promise that resolves to the pending deposited balance in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    pendingDepositedBalance(): Promise<BigNumber>;
    /**
     * Fetches the pool restaked rewards which are in pending status.
     *
     * @returns A Promise that resolves to the pending restaked rewards amount in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    pendingRestakedRewards(): Promise<BigNumber>;
    /**
     * Fetches the pool unclaimed rewards amount which can be restaked.
     *
     * @returns A Promise that resolves to the unclaimed rewards amount in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    readyforAutocompoundRewardsAmount(): Promise<BigNumber>;
    /**
     * Fetches the pending balance of a given address.
     *
     * @param address - The address to fetch the pending balance for.
     *
     * @returns A Promise that resolves to the pending balance in ether.
     *
     * @throws Will throw an Error if the contract call fails or address is not valid.
     */
    pendingBalanceOf(address: string): Promise<BigNumber>;
    /**
     * Fetches the user's pending deposited balance. This is the balance deposited into the validator but not active yet.
     * Pending deposited balance can't be unstaked till validator activation.
     *
     * @param address - The address to fetch the pending deposited balance for.
     *
     * @returns A Promise that resolves to the pending deposited balance in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    pendingDepositedBalanceOf(address: string): Promise<BigNumber>;
    /**
     * Fetches the user's active origin deposited balance.
     *
     * @param address - The address to fetch the deposited balance for.
     *
     * @returns A Promise that resolves to the deposited balance in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    depositedBalanceOf(address: string): Promise<BigNumber>;
    /**
     * Fetches the user's restaked rewards in pending state.
     *
     * @param address - The address to fetch the pending restaked rewards for.
     *
     * @returns A Promise that resolves to the pending restaked rewards in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    pendingRestakedRewardOf(address: string): Promise<BigNumber>;
    /**
     * Returns total user restaked rewards. Includes rewards in pending state.
     *
     * @param address - The address to fetch the restaked rewards for.
     *
     * @returns A Promise that resolves to the restaked rewards in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    restakedRewardOf(address: string): Promise<BigNumber>;
    /**
     * Fetches the pool fee in bips (1/10000).
     *
     * @returns A Promise that resolves to the pool fee.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    getPoolFee(): Promise<BigNumber>;
    /**
     * Claims all pool rewards and restakes it into the pool.
     *
     * @param address - The address to perform the autocompound operation for.
     *
     * @returns A Promise that resolves to a transaction object.
     *
     * @throws Will throw an Error if the contract call fails or there are no rewards.
     */
    autocompound(address: string): Promise<EthTransaction>;
    /**
     * Returns total user autocompound balance. Part of this balance could be in pending state after rewards autocompound.
     *
     * @param address - The address to fetch the autocompound balance for.
     *
     * @returns A Promise that resolves to the autocompound balance in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    autocompoundBalanceOf(address: string): Promise<BigNumber>;
    /**
     * Returns info about withdraw requests queue.
     * Includes totally all-time requested withdraw amount,
     * actual allowed for interchange with deposits amount,
     * all-time withdraw treasury filled amount,
     * and all-time claimed by users amount.
     *
     * @returns A Promise that resolves to an object containing the withdraw request queue parameters.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    withdrawRequestQueueParams(): Promise<{
        withdrawRequested: BigNumber;
        interchangeAllowed: BigNumber;
        filled: BigNumber;
        claimed: BigNumber;
    }>;
    /**
     * Returns user withdraw request info. Includes the actual requested amount and the amount ready for claim.
     *
     * @param address - The address to fetch the withdraw request info for.
     *
     * @returns A Promise that resolves to an object containing the requested amount and the amount ready for claim in ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    withdrawRequest(address: string): Promise<{
        requested: BigNumber;
        readyForClaim: BigNumber;
    }>;
    /**
     * Returns aggregated pool balances using multicall contract.
     *
     * @returns A Promise that resolves to a AggregatedBalances object.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    poolBalances(): Promise<AggregatedBalances>;
    /**
     * Returns aggregated user balances using multicall contract.
     *
     * @param address - The user address.
     *
     * @returns A Promise that resolves to a AggregatedBalances object.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    userBalances(address: string): Promise<AggregatedBalances>;
    /**
     * Claims funds requested by withdraw.
     *
     * @param address - The address to perform the claim operation for.
     *
     * @returns A Promise that resolves to a transaction object.
     *
     * @throws Will throw an Error if the contract call fails, there are no funds to claim, or the claim is not yet filled.
     */
    claimWithdrawRequest(address: string): Promise<EthTransaction>;
    /**
     * Returns the number of validators expected to stop.
     *
     * @returns A Promise that resolves to the number of validators expected to stop.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    closeValidatorsStat(): Promise<number>;
    /**
     * Stakes funds into pool.
     *
     * @param address - Sender address.
     * @param amount - Stake amount in ETH
     * @param source - Stake source. Default is '0'.
     *
     * @returns A Promise that resolves to the unsigned ETH transaction object.
     *
     * @throws Will throw an Error if the amount is not a valid, the amount is less than the minimum, or the contract call fails.
     */
    stake(address: string, amount: string, source?: string): Promise<EthTransaction>;
    /**
     * Unstake value from active autocompound balance.
     * AllowedInterchangeNum is max allowed number interchanges with pending stakers.
     * Unstaked immediately if value <= pool pending balance or create withdraw request.
     * Interchange disallowed as default.
     *
     * @param address - Sender address.
     * @param amount - Unstake amount in ETH.
     * @param allowedInterchangeNum - Max allowed number of interchanges. Default is 0.
     * @param source - Unstake source. Default is '0'.
     *
     * @returns A Promise that resolves to the unsigned ETH transaction object.
     *
     * @throws Will throw an Error if the amount is not a string, the balance is less than the amount, or the contract call fails.
     */
    unstake(address: string, amount: string, allowedInterchangeNum?: number, source?: string): Promise<EthTransaction>;
    /**
     * Simulate unstake transaction and return amount of instant unstake.
     * Required to compare evaluation of allowedInterchangeNum parameter.
     *
     * @param address - Sender address.
     * @param amount - Unstake amount in ETH.
     * @param allowedInterchangeNum - Max allowed number of interchanges. Default is 1.
     * @param source - Unstake source. Default is '0'.
     *
     * @returns A Promise that resolves to a BigNumber representing the instant unstake amount in ETH.
     *
     * @throws Will throw an Error if the balance is less than the amount or the contract call fails.
     */
    simulateUnstake(address: string, amount: string, allowedInterchangeNum?: number, source?: string): Promise<BigNumber>;
    /**
     * Unstakes the pending amount from Autocompound.
     *
     * @param address - The address from which the amount will be unstaked.
     * @param amount - The amount to unstake.
     *
     * @returns A Promise that resolves to a transaction object.
     *
     * @throws Will throw an Error if the pending balance is zero, the amount is greater than the pending balance,
     * or the pending balance is less than the minimum stake amount.
     */
    unstakePending(address: string, amount: number): Promise<EthTransaction>;
    /**
     * Activates pending stake by interchange with withdraw request.
     *
     * @param address - The address from which the stake will be activated.
     *
     * @returns A Promise that resolves to a transaction object.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    activateStake(address: string): Promise<EthTransaction>;
    /**
     * Fetches the number of validators prepared for deposit from the contract pool.
     *
     * @returns A Promise that resolves to the number of validators prepared for deposit.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    getPendingValidatorCount(): Promise<number>;
    /**
     * Fetches a pending validator's public key by index from the contract pool.
     * Note: The list of pending validators is dynamic so ordering is unstable.
     *
     * @param index - The index of the pending validator to fetch.
     *
     * @returns A Promise that resolves to the public key of the pending validator.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    getPendingValidator(index: number): Promise<string>;
    /**
     * Fetches the total number of known validators from the contract pool.
     * A validator can be in one of the following statuses: pending, deposited, exited.
     * Exited validators will be overwritten by new pending validators to optimize memory usage.
     *
     * @returns A Promise that resolves to the total number of known validators.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    getValidatorCount(): Promise<number>;
    /**
     * Fetches a validator from the contract pool by its index.
     * The result is an object containing the validator's public key and status.
     *
     * @param index - The index of the validator to fetch.
     *
     * @returns A Promise that resolves to an object with the validator's public key and status.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    getValidator(index: number): Promise<{
        pubkey: string;
        status: string;
    }>;
    /**
     * Fetches the minimum stake amount from the contract pool.
     * The result is converted from Wei to Ether using Web3 utilities.
     *
     * @returns A Promise that resolves to a BigNumber representing the minimum stake amount in Ether.
     *
     * @throws Will throw an Error if the contract call fails.
     */
    minStakeAmount(): Promise<BigNumber>;
    /**
     * Selects and initializes a new network.
     *
     * This method calls `initializeNetwork` with the provided parameters and returns the current instance,
     * allowing for method chaining.
     *
     * @param network - The network type. This should be one of the keys in `NETWORK_ADDRESSES`.
     * @param url - The RPC URL of the network. If not provided, the method will use the URL from `NETWORK_ADDRESSES`.
     *
     * @returns The current instance of the `Ethereum` class.
     */
    selectNetwork(network: EthNetworkType, url?: string): Ethereum;
    /**
     * Initializes the network.
     *
     * This method sets the RPC URL, contract addresses, and initializes the Web3 instance and contracts.
     *
     * @param network - The network type. This should be one of the keys in `NETWORK_ADDRESSES`.
     * @param url - The RPC URL of the network. If not provided, the method will use the URL from `NETWORK_ADDRESSES`.
     *
     * @throws Will throw an error if the provided network is not supported (i.e., not a key in `NETWORK_ADDRESSES`).
     */
    private initializeNetwork;
    /**
     * Converts a status code into a human-readable status.
     *
     * @param code - The status code to convert. '0' means 'unknown', '1' means 'pending', any other value means 'deposited'.
     *
     * @returns The human-readable status corresponding to the given code.
     */
    getStatusFromCode(code: ValidatorStatus): string;
    /**
     * Converts the given amount from Wei to Ether.
     *
     * @param amount - The amount in Wei to convert to Ether.
     *
     * @returns The converted amount in Ether as a BigNumber.
     */
    private fromWeiToEther;
    /**
     * Calculates the gas limit by adding a predefined GAS_RESERVE to the given gas consumption.
     *
     * @param gasConsumption - The amount of gas consumed.
     *
     * @returns The calculated gas limit as a number.
     */
    private calculateGasLimit;
    /**
     * Checks if a given address has the basic requirements of an Ethereum address format.
     *
     * @param address - The Ethereum address to validate.
     *
     * @returns `true` if the address meets basic requirements, otherwise `false`.
     */
    private isAddress;
}

declare const SOL_CHAIN = "solana";
declare const SOL_MIN_AMOUNT = 10000000;
declare const SOL_MAINNET_VALIDATOR_ADDRESS: PublicKey;
declare const SOL_DEVNET_VALIDATOR_ADDRESS: PublicKey;
declare const FILTER_DATA_SIZE = 200;
declare const FILTER_OFFSET = 44;
declare enum SolNetwork {
    Mainnet = "mainnet-beta",
    Devnet = "devnet"
}
declare const StakeState: {
    inactive: string;
    activating: string;
    active: string;
    deactivating: string;
    deactivated: string;
};
declare const StakeAccountType: superstruct.Struct<"uninitialized" | "initialized" | "delegated" | "rewardsPool", {
    uninitialized: "uninitialized";
    initialized: "initialized";
    delegated: "delegated";
    rewardsPool: "rewardsPool";
}>;

type StakeAccount$1 = Infer<typeof StakeAccount$1>;
declare const StakeAccount$1: superstruct.Struct<{
    type: "uninitialized" | "initialized" | "delegated" | "rewardsPool";
    info: {
        stake: {
            delegation: {
                stake: BigNumber;
                voter: PublicKey;
                activationEpoch: BigNumber;
                deactivationEpoch: BigNumber;
                warmupCooldownRate: number;
            };
            creditsObserved: number;
        } | null;
        meta: {
            rentExemptReserve: BigNumber;
            authorized: {
                staker: PublicKey;
                withdrawer: PublicKey;
            };
            lockup: {
                unixTimestamp: number;
                epoch: number;
                custodian: PublicKey;
            };
        };
    };
}, {
    type: superstruct.Struct<"uninitialized" | "initialized" | "delegated" | "rewardsPool", {
        uninitialized: "uninitialized";
        initialized: "initialized";
        delegated: "delegated";
        rewardsPool: "rewardsPool";
    }>;
    info: superstruct.Struct<{
        stake: {
            delegation: {
                stake: BigNumber;
                voter: PublicKey;
                activationEpoch: BigNumber;
                deactivationEpoch: BigNumber;
                warmupCooldownRate: number;
            };
            creditsObserved: number;
        } | null;
        meta: {
            rentExemptReserve: BigNumber;
            authorized: {
                staker: PublicKey;
                withdrawer: PublicKey;
            };
            lockup: {
                unixTimestamp: number;
                epoch: number;
                custodian: PublicKey;
            };
        };
    }, {
        meta: superstruct.Struct<{
            rentExemptReserve: BigNumber;
            authorized: {
                staker: PublicKey;
                withdrawer: PublicKey;
            };
            lockup: {
                unixTimestamp: number;
                epoch: number;
                custodian: PublicKey;
            };
        }, {
            rentExemptReserve: superstruct.Struct<BigNumber, null>;
            authorized: superstruct.Struct<{
                staker: PublicKey;
                withdrawer: PublicKey;
            }, {
                staker: superstruct.Struct<PublicKey, null>;
                withdrawer: superstruct.Struct<PublicKey, null>;
            }>;
            lockup: superstruct.Struct<{
                unixTimestamp: number;
                epoch: number;
                custodian: PublicKey;
            }, {
                unixTimestamp: superstruct.Struct<number, null>;
                epoch: superstruct.Struct<number, null>;
                custodian: superstruct.Struct<PublicKey, null>;
            }>;
        }>;
        stake: superstruct.Struct<{
            delegation: {
                stake: BigNumber;
                voter: PublicKey;
                activationEpoch: BigNumber;
                deactivationEpoch: BigNumber;
                warmupCooldownRate: number;
            };
            creditsObserved: number;
        } | null, {
            delegation: superstruct.Struct<{
                stake: BigNumber;
                voter: PublicKey;
                activationEpoch: BigNumber;
                deactivationEpoch: BigNumber;
                warmupCooldownRate: number;
            }, {
                voter: superstruct.Struct<PublicKey, null>;
                stake: superstruct.Struct<BigNumber, null>;
                activationEpoch: superstruct.Struct<BigNumber, null>;
                deactivationEpoch: superstruct.Struct<BigNumber, null>;
                warmupCooldownRate: superstruct.Struct<number, null>;
            }>;
            creditsObserved: superstruct.Struct<number, null>;
        }>;
    }>;
}>;

declare class ParseStakeAccountError extends Error {
}
/**
 * The `StakeAccount` provides methods for interacting with the parsed Solana stake account.
 *
 * @property account - Parser account infop AccountInfo<Account>.
 * @throws ParseStakeAccountError if `account` is AccountInfo<Buffer> or if unable to parse account data
 */
declare class StakeAccount {
    account: AccountInfo<StakeAccount$1>;
    constructor({ executable, owner, lamports, data, rentEpoch, }: AccountInfo<Buffer | ParsedAccountData>);
    /**
     * Check if lockup is in force
     * @param currEpoch current epoch.
     * @param currUnixTimestamp current unix timetamp.
     * @returns a bool type result.
     */
    isLockupInForce(currEpoch: number, currUnixTimestamp: number): boolean;
    /**
     * Determins the current state of a stake account given the current epoch
     * @param currentEpoch
     * @returns `stakeAccount`'s stake state`string`
     */
    stakeAccountState(currentEpoch: number): string;
}

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */

interface ApiResponse<T> {
    result: T;
}
type SolDelegation = {
    pubkey: PublicKey;
    account: AccountInfo<Buffer | ParsedAccountData>;
};
type SolCreateAccountResponse = {
    createStakeAccountVerTx: VersionedTransaction;
    stakeAccount: PublicKey;
};
type SolAccount = {
    pubkey: PublicKey;
    account: StakeAccount;
};
type SolAccountToSplit = {
    account: SolAccount;
    lamports: number;
};

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */

/**
 * The `Solana` class extends the `Blockchain` class and provides methods for interacting with the Solana blockchain.
 *
 * @property connection - The connection to the Solana blockchain.
 * @property ERROR_MESSAGES - The error messages for the Solana class.
 * @property ORIGINAL_ERROR_MESSAGES - The original error messages for the Solana class.

 * @throws Throws an error if there's an issue establishing the connection.
 */
declare class Solana extends Blockchain {
    private connection;
    private validator;
    protected ERROR_MESSAGES: {
        CONNECTION_ERROR: string;
        MIN_AMOUNT_ERROR: string;
        CREATE_ACCOUNT_ERROR: string;
        DELEGATE_ERROR: string;
        DEACTIVATE_ERROR: string;
        WITHDRAW_ERROR: string;
        GET_DELEGATIONS_ERROR: string;
        STAKE_ERROR: string;
        INVALID_RPC_ERROR: string;
        UNSUPPORTED_NETWORK_ERROR: string;
        CLAIM_ERROR: string;
        UNSTAKE_ERROR: string;
        NOTHING_TO_CLAIM_ERROR: string;
        NOT_ENOUGH_ACTIVE_STAKE_ERROR: string;
        GET_EPOCH_INFO_ERROR: string;
    };
    protected ORIGINAL_ERROR_MESSAGES: {};
    constructor(network?: SolNetwork, rpc?: string | null);
    /**
     * Creates a new stake account.
     *
     * @param address - The public key of the account as PublicKey.
     * @param lamports  - The amount to stake in lamports.
     * @param source  - stake source
     * @param lockup - stake account lockup
     *
     * @throws  Throws an error if the lamports is less than the minimum amount.
     * @throws  Throws an error if there's an issue creating the stake account.
     *
     * @returns Returns a promise that resolves with the versioned transaction of the stake account creation and the public key of the stake account.
     *
     */
    createAccount(address: PublicKey, lamports: number, source: string | null, lockup?: Lockup | null): Promise<ApiResponse<SolCreateAccountResponse>>;
    /**
     * Prepares a transaction with the given instructions and payer.
     *
     * @param instructions - An array of TransactionInstruction objects.
     * @param payer - The public key of the payer.
     * @param externalSigners - an array of external signers.
     * @returns A promise that resolves to a VersionedTransaction object.
     */
    prepareTransaction(instructions: TransactionInstruction[], payer: PublicKey, externalSigners: Signer[]): Promise<VersionedTransaction>;
    /**
     * Retrieves the latest blockhash.
     *
     * @returns A promise that resolves to a string representing the blockhash.
     */
    getBlockhash(): Promise<string>;
    /**
     * Delegates a specified amount from a stake account to a validator.
     *
     * @param address - The public key of the account.
     * @param lamports - The amount in lamports to be delegated.
     * @param stakeAccount - The public key of the stake account.
     *
     * @throws Throws an error if the amount is less than the minimum amount, or if there's an issue during the delegation process.
     *
     * @returns Returns a promise that resolves with the delegation transaction.
     *
     */
    delegate(address: string, lamports: number, stakeAccount: string): Promise<ApiResponse<VersionedTransaction>>;
    /**
     * Deactivates a stake account.
     *
     * @param address - The public key of the account.
     * @param stakeAccountPublicKey - The public key of the stake account.
     * @throws Throws an error if there's an issue during the deactivation process.
     * @returns Returns a promise that resolves with the deactivation transaction.
     *
     */
    deactivate(address: string, stakeAccountPublicKey: string): Promise<ApiResponse<VersionedTransaction>>;
    /**
     * Withdraws a specified amount from a stake account.
     *
     * @param address - The public key of the account.
     * @param stakeAccountPublicKey - The public key of the stake account.
     * @param stakeBalance - The amount in lamports to be withdrawn from the stake account.
     *
     * @throws Throws an error if there's an issue during the withdrawal process.
     *
     * @returns Returns a promise that resolves with the withdrawal transaction.
     *
     */
    withdraw(address: string, stakeAccountPublicKey: PublicKey, stakeBalance: number): Promise<ApiResponse<VersionedTransaction>>;
    /**
     * Fetches the delegations of a given account.
     *
     * @param address - The public key of the account.
     *
     * @throws Throws an error if there's an issue fetching the delegations.
     *
     * @returns Returns a promise that resolves with the delegations of the account.
     *
     */
    getDelegations(address: string): Promise<ApiResponse<Array<SolDelegation>>>;
    /**
     * Stakes a certain amount of lamports.
     *
     * @param sender - The public key of the sender.
     * @param lamports - The number of lamports to stake.
     * @param source  - stake source
     * @param lockup - stake account lockup
     * @returns A promise that resolves to a VersionedTransaction object.
     */
    stake(sender: string, lamports: number, source: string | null, lockup?: Lockup | null): Promise<ApiResponse<VersionedTransaction>>;
    /**
     * Create account Tx, public key and array of keypair.
     *
     * @param address - The public key of the account.
     * @param lamports - The number of lamports to stake.
     * @param lockup - The stake account lockup
     *
     * @throws Throws an error if there's an issue creating an account.
     *
     * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
     *
     */
    private createAccountTx;
    /**
     * Create account Tx, public key and array of keypair using seed.
     *
     * @param authorityPublicKey - The public key of the account.
     * @param lamports - The number of lamports to stake.
     * @param source - The stake source
     * @param lockup - The stake account lockup
     *
     * @throws Throws an error if there's an issue creating an account.
     *
     * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
     *
     */
    private createAccountWithSeedTx;
    /** unstake - unstake
     * @param {string} sender - account blockchain address (staker)
     * @param {number} lamports - lamport amount
     * @param {string} source - stake source
     * @returns {Promise<object>} Promise object with Versioned Tx
     */
    unstake(sender: string, lamports: number, source: string): Promise<ApiResponse<VersionedTransaction>>;
    /**
     * Split existing account to create a new one
     *
     * @param authorityPublicKey - The public key of the account.
     * @param lamports - The number of lamports to stake.
     * @param oldStakeAccountPubkey -The public key of the old account.
     * @param source - The stake source
     *
     * @throws Throws an error if there's an issue splitting an account.
     *
     * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
     *
     */
    private split;
    /**
     * Claim makes withdrawal from all sender's deactivated accounts.
     *
     * @param sender - The sender solana address.
     *
     * @throws Throws an error if there's an issue while claiming a stake.
     *
     * @returns Returns a promise that resolves with a Versioned Transaction.
     *
     */
    claim(sender: string): Promise<ApiResponse<VersionedTransaction>>;
    getEpochInfo(): Promise<ApiResponse<EpochInfo>>;
    /**
     * Merge two accounts into a new one
     *
     * @param authorityPublicKey - The public key of the account.
     * @param stakeAccount1 - The public key of the first account.
     * @param stakeAccount2 - The public key of the second account.
     *
     * @throws Throws an error if there's an issue while merging an account.
     *
     * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
     *
     */
    private merge;
    /**
     * Generate a unique source for crating an account.
     *
     * @param source - source ID.
     *
     * @returns Returns a unique source for an account.
     *
     */
    private formatSource;
    /**
     * Generate timestamp in seconds.
     *
     * @returns Returns a timestamp in seconds.
     *
     */
    private timestampInSec;
}

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */
declare function CheckToken(token: string): Promise<boolean>;
interface SetStatsParams {
    token: string;
    action: string;
    amount: number;
    address: string;
    chain: string;
}
declare function SetStats({ token, action, amount, address, chain, }: SetStatsParams): Promise<void>;
declare function CreateToken(name: string, type: string): Promise<any>;
declare function GetAssets(chain: string): Promise<any>;

/**
 * Copyright (c) 2025, Everstake.
 * Licensed under the BSD-3-Clause License. See LICENSE file for details.
 */

declare const ETH_NETWORK_ADDRESSES: EthNetworkAddressesMap;
declare const ETH_GAS_RESERVE: BigNumber;
declare const UINT16_MAX: number;
declare const ETH_MIN_AMOUNT: BigNumber;
declare const MULTICALL_CONTRACT_ADDRESS = "0xca11bde05977b3631167028862be2a173976ca11";

export { ABI_CONTRACT_ACCOUNTING, ABI_CONTRACT_POOL, type AggregatedBalances, type ApiResponse, Blockchain, CheckToken, CreateToken, ETH_GAS_RESERVE, ETH_MIN_AMOUNT, ETH_NETWORK_ADDRESSES, type EthNetworkAddresses, type EthNetworkAddressesMap, type EthNetworkType, type EthTransaction, Ethereum, FILTER_DATA_SIZE, FILTER_OFFSET, GetAssets, MULTICALL_CONTRACT_ADDRESS, ParseStakeAccountError, SOL_CHAIN, SOL_DEVNET_VALIDATOR_ADDRESS, SOL_MAINNET_VALIDATOR_ADDRESS, SOL_MIN_AMOUNT, SetStats, type SolAccount, type SolAccountToSplit, type SolCreateAccountResponse, type SolDelegation, SolNetwork, Solana, StakeAccount, StakeAccountType, StakeState, UINT16_MAX, ValidatorStatus, WalletSDKError };
