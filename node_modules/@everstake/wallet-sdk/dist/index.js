"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ABI_CONTRACT_ACCOUNTING: () => ABI_CONTRACT_ACCOUNTING,
  ABI_CONTRACT_POOL: () => ABI_CONTRACT_POOL,
  Blockchain: () => Blockchain,
  CheckToken: () => CheckToken,
  CreateToken: () => CreateToken,
  ETH_GAS_RESERVE: () => ETH_GAS_RESERVE,
  ETH_MIN_AMOUNT: () => ETH_MIN_AMOUNT,
  ETH_NETWORK_ADDRESSES: () => ETH_NETWORK_ADDRESSES,
  Ethereum: () => Ethereum,
  FILTER_DATA_SIZE: () => FILTER_DATA_SIZE,
  FILTER_OFFSET: () => FILTER_OFFSET,
  GetAssets: () => GetAssets,
  MULTICALL_CONTRACT_ADDRESS: () => MULTICALL_CONTRACT_ADDRESS,
  ParseStakeAccountError: () => ParseStakeAccountError,
  SOL_CHAIN: () => SOL_CHAIN,
  SOL_DEVNET_VALIDATOR_ADDRESS: () => SOL_DEVNET_VALIDATOR_ADDRESS,
  SOL_MAINNET_VALIDATOR_ADDRESS: () => SOL_MAINNET_VALIDATOR_ADDRESS,
  SOL_MIN_AMOUNT: () => SOL_MIN_AMOUNT,
  SetStats: () => SetStats,
  SolNetwork: () => SolNetwork,
  Solana: () => Solana,
  StakeAccount: () => StakeAccount2,
  StakeAccountType: () => StakeAccountType,
  StakeState: () => StakeState,
  UINT16_MAX: () => UINT16_MAX,
  ValidatorStatus: () => ValidatorStatus,
  WalletSDKError: () => WalletSDKError
});
module.exports = __toCommonJS(src_exports);

// src/ethereum/index.ts
var import_web3 = __toESM(require("web3"));
var import_bignumber2 = __toESM(require("bignumber.js"));
var import_ethereum_multicall = require("ethereum-multicall");
var import_web32 = require("web3");

// src/ethereum/constants/index.ts
var import_bignumber = __toESM(require("bignumber.js"));
var ETH_NETWORK_ADDRESSES = {
  mainnet: {
    addressContractAccounting: "0x7a7f0b3c23C23a31cFcb0c44709be70d4D545c6e",
    addressContractPool: "0xD523794C879D9eC028960a231F866758e405bE34",
    addressContractWithdrawTreasury: "0x19449f0f696703Aa3b1485DfA2d855F33659397a",
    rpcUrl: "https://mainnet.infura.io/v3/f583d4f04d384b9e8c59a7ff1c9f68f1"
  },
  holesky: {
    addressContractAccounting: "0x624087DD1904ab122A32878Ce9e933C7071F53B9",
    addressContractPool: "0xAFA848357154a6a624686b348303EF9a13F63264",
    addressContractWithdrawTreasury: "0x66cb3AeD024740164EBcF04e292dB09b5B63A2e1",
    rpcUrl: "https://ethereum-holesky.publicnode.com"
  }
};
var ETH_GAS_RESERVE = new import_bignumber.default(22e4);
var UINT16_MAX = 65535 | 0;
var ETH_MIN_AMOUNT = new import_bignumber.default("100000000000000000");
var MULTICALL_CONTRACT_ADDRESS = "0xca11bde05977b3631167028862be2a173976ca11";

// src/ethereum/abi.ts
var ABI_CONTRACT_ACCOUNTING = [
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "InvalidParam",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "InvalidValue",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "ZeroValue",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "round",
        type: "uint256"
      }
    ],
    name: "ActivateRound",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "AddWithdrawRequest",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Autocompound",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "int256", name: "", type: "int256" }
    ],
    name: "ChangeExpectValidatorsToStop",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "ClaimPoolFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "ClaimWithdrawRequest",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "DepositPending",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "newFee",
        type: "uint256"
      }
    ],
    name: "FeeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldGovernor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newGovernor",
        type: "address"
      }
    ],
    name: "GovernorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "InterchangeDeposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "InterchangeWithdraw",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "superAdmin",
        type: "address"
      }
    ],
    name: "SetSuperAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "rewarderBalance",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reward",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "fee",
        type: "uint256"
      }
    ],
    name: "Update",
    type: "event"
  },
  {
    inputs: [],
    name: "BEACON_AMOUNT",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FEE_DENOMINATOR",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "governor",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "value", type: "address" }],
    name: "setSuperAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "superAdmin",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "poolFee", type: "uint256" },
      { internalType: "address", name: "rewardsTreasury", type: "address" },
      { internalType: "address", name: "withdrawTreasury", type: "address" },
      {
        internalType: "address",
        name: "accountingGovernor",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      {
        internalType: "uint256",
        name: "depositToPendingValue",
        type: "uint256"
      }
    ],
    name: "deposit",
    outputs: [
      {
        internalType: "uint256",
        name: "interchangedAmount",
        type: "uint256"
      },
      { internalType: "uint256", name: "activatedSlots", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "balance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingDepositedBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "autocompoundBalanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "autocompoundBalance",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "depositedBalanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "pendingDepositedBalanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "pendingBalanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "withdrawPending",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "staker", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "withdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "withdrawFromPendingAmount",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "claimPoolFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "update",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "feeValue", type: "uint256" }],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "autocompound",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingRestakedRewards",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "pendingRestakedRewardOf",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "restakedRewardOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "withdrawRequestQueueParams",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "staker", type: "address" }],
    name: "withdrawRequest",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "claimWithdrawRequest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "readyforAutocompoundRewardsAmount",
    outputs: [
      { internalType: "uint256", name: "unclaimedReward", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "closeValidatorsStat",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "stakeAmount", type: "uint256" }],
    name: "setMinRestakeAmount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "activatedValidatorNum",
        type: "uint256"
      }
    ],
    name: "activateValidators",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var ABI_CONTRACT_POOL = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "InvalidAmount",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "InvalidParam",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "InvalidValue",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "Paused",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "field", type: "string" }],
    name: "ZeroValue",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldGovernor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newGovernor",
        type: "address"
      }
    ],
    name: "GovernorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint8", name: "version", type: "uint8" }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [{ indexed: false, internalType: "bool", name: "", type: "bool" }],
    name: "PauseStaking",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [{ indexed: false, internalType: "bool", name: "", type: "bool" }],
    name: "PauseWithdraw",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes",
        name: "oldPendingValidatorPubKey",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "newPendingValidatorPubKey",
        type: "bytes"
      }
    ],
    name: "PendingValidatorReplaced",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "Restake",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "SetMinStakeAmount",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "superAdmin",
        type: "address"
      }
    ],
    name: "SetSuperAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "StakeActivated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "source",
        type: "uint64"
      }
    ],
    name: "StakeAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "StakeCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes",
        name: "validator",
        type: "bytes"
      }
    ],
    name: "StakeDeposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "staker",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "source",
        type: "uint64"
      }
    ],
    name: "Unstake",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes",
        name: "validator",
        type: "bytes"
      }
    ],
    name: "ValidatorMarkedAsExited",
    type: "event"
  },
  {
    inputs: [],
    name: "BEACON_AMOUNT",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "governor",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "value", type: "address" }],
    name: "setSuperAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "superAdmin",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "depositContract", type: "address" },
      { internalType: "address", name: "accountingContract", type: "address" },
      { internalType: "address", name: "withdrawTreasury", type: "address" },
      { internalType: "address", name: "rewardsTreasury", type: "address" },
      { internalType: "address", name: "poolGovernor", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint64", name: "source", type: "uint64" }],
    name: "stake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    name: "unstakePending",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint16", name: "allowedInterchangeNum", type: "uint16" },
      { internalType: "uint64", name: "source", type: "uint64" }
    ],
    name: "unstake",
    outputs: [
      {
        internalType: "uint256",
        name: "unstakeFromPendingValue",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "activateStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "activatedSlots", type: "uint256" }
    ],
    name: "restake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "bytes", name: "pubkey", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" },
          {
            internalType: "bytes32",
            name: "deposit_data_root",
            type: "bytes32"
          }
        ],
        internalType: "struct ValidatorList.DepositData[]",
        name: "pendingValidators",
        type: "tuple[]"
      }
    ],
    name: "setPendingValidators",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getPendingValidatorCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
    name: "getPendingValidator",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getValidatorCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
    name: "getValidator",
    outputs: [
      { internalType: "bytes", name: "", type: "bytes" },
      {
        internalType: "enum ValidatorList.ValidatorStatus",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "index", type: "uint256" },
      {
        components: [
          { internalType: "bytes", name: "pubkey", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" },
          {
            internalType: "bytes32",
            name: "deposit_data_root",
            type: "bytes32"
          }
        ],
        internalType: "struct ValidatorList.DepositData",
        name: "pendingValidator",
        type: "tuple"
      }
    ],
    name: "replacePendingValidator",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "num", type: "uint256" }],
    name: "markValidatorsAsExited",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
    name: "markValidatorAsExited",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "reorderPending",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "pause", type: "bool" }],
    name: "pauseStaking",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "pause", type: "bool" }],
    name: "pauseWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newGovernor", type: "address" }],
    name: "setGovernor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "minStakeAmount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "stakeAmount", type: "uint256" }],
    name: "setMinStakeAmount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/ethereum/constants/errors.ts
var ERROR_MESSAGES = {
  BALANCE_ERROR: "An error occurred while getting the balance",
  PENDING_BALANCE_ERROR: "An error occurred while getting the pending balance",
  PENDING_DEPOSITED_BALANCE_ERROR: "An error occurred while getting the pending deposited balance",
  PENDING_RESTAKED_REWARDS_ERROR: "An error occurred while getting the pending restaked rewards",
  READY_FOR_AUTOCOMPOUND_REWARDS_AMOUNT_ERROR: "An error occurred while getting the ready for autocompound rewards amount",
  PENDING_BALANCE_OF_ERROR: "An error occurred while getting the pending balance of an address",
  PENDING_DEPOSITED_BALANCE_OF_ERROR: "An error occurred while getting the pending deposited balance of an address",
  DEPOSITED_BALANCE_OF_ERROR: "An error occurred while getting the deposited balance of an address",
  PENDING_RESTAKED_REWARD_OF_ERROR: "An error occurred while getting the pending restaked reward of an address",
  RESTAKED_REWARD_OF_ERROR: "An error occurred while getting the restaked reward of an address",
  GET_POOL_FEE_ERROR: "An error occurred while getting the pool fee",
  MIN_STAKE_AMOUNT_ERROR: "An error occurred while getting the minimum stake amount",
  GET_VALIDATOR_ERROR: "An error occurred while getting the validator",
  GET_VALIDATOR_COUNT_ERROR: "An error occurred while getting the validator count",
  GET_PENDING_VALIDATOR_ERROR: "An error occurred while getting the pending validator",
  GET_PENDING_VALIDATOR_COUNT_ERROR: "An error occurred while getting the pending validator count",
  ACTIVATE_STAKE_ERROR: "An error occurred while activating the stake",
  MIN_AMOUNT_ERROR: "Min Amount {0} wei",
  UNSTAKE_PENDING_ERROR: "An error occurred while unstaking the pending amount",
  INSUFFICIENT_PENDING_BALANCE_ERROR: `Pending balance less than min stake amount {0}`,
  ZERO_UNSTAKE_MESSAGE: "Zero pending balance",
  AMOUNT_GREATER_THAN_PENDING_BALANCE_ERROR: `Amount greater than pending balance {0}`,
  NETWORK_NOT_SUPPORTED: `Unsupported network {0}`,
  NO_REWARDS_MESSAGE: "No active rewards for claim",
  AUTOCOMPOUND_ERROR: "An error occurred while performing the autocompound operation",
  AUTOCOMPOUND_BALANCE_OF_ERROR: "An error occurred while getting the autocompound balance of an address",
  WITHDRAW_REQUEST_QUEUE_PARAMS_ERROR: "An error occurred while getting the withdraw request queue parameters",
  WITHDRAW_REQUEST_ERROR: "An error occurred while getting the withdraw request info for an address",
  ZERO_UNSTAKE_ERROR: "No amount requested for unstake",
  NOT_FILLED_UNSTAKE_MESSAGE: "Unstake request not filled yet",
  WRONG_TYPE_MESSAGE: "Wrong input type",
  CLAIM_WITHDRAW_REQUEST_ERROR: "An error occurred while claiming the withdraw request for an address",
  CLOSE_VALIDATORS_STAT_ERROR: "An error occurred while getting the number of validators expected to stop",
  STAKE_ERROR: "An error occurred while staking funds into the pool",
  UNSTAKE_ERROR: "An error occurred while unstaking funds from the pool",
  SIMULATE_UNSTAKE_ERROR: "An error occurred while simulating the unstake transaction",
  MAX_AMOUNT_FOR_UNSTAKE_ERROR: "Max Amount For Unstake {0}",
  ADDRESS_FORMAT_ERROR: "Invalid Ethereum address format",
  USER_BALANCES_ERROR: "An error occurred while getting the user balances",
  POOL_BALANCES_ERROR: "An error occurred while getting the pool balances"
};
var ORIGINAL_ERROR_MESSAGES = {
  "InvalidValue: remainder": "The remainder is less than the minimum stake amount.",
  "InvalidValue: amount": `The requested amount is greater than the pool's pending balance.`,
  "InvalidValue: pending balance": "The user has no pending balance or it is less than the requested amount.",
  "ZeroValue: pending": `The pool's pending balance is zero.`,
  "ZeroValue: claim": "There is nothing to claim.",
  "InvalidParam: index": "The provided index is out of range.",
  "InvalidParam: caller": "This action is not allowed for the current user.",
  "InvalidValue: zero amount": "There is nothing to activate.",
  "InvalidValue: share": "The requested amount is less than one share.",
  "InvalidValue: withdrawable balance": "The requested amount is greater than the active balance.",
  "Paused: withdraw claim": "Claiming unstake is currently paused.",
  "Paused: staking": "Staking is currently paused.",
  "Paused: withdraw": "Unstaking is currently paused.",
  "InvalidAmount: small stake": "The staked amount is less than the minimum stake amount.",
  "Pending validator": "There are not enough pending validators to activate.",
  "Returned error: execution reverted": "The operation failed. Please try again."
};

// src/ethereum/types/index.ts
var ValidatorStatus = /* @__PURE__ */ ((ValidatorStatus2) => {
  ValidatorStatus2[ValidatorStatus2["Unknown"] = 0] = "Unknown";
  ValidatorStatus2[ValidatorStatus2["Pending"] = 1] = "Pending";
  ValidatorStatus2[ValidatorStatus2["Deposited"] = 2] = "Deposited";
  return ValidatorStatus2;
})(ValidatorStatus || {});

// utils/constants/errors.ts
var COMMON_ERROR_MESSAGES = {
  UNKNOWN_ERROR: "An unknown error occurred",
  TOKEN_ERROR: "Please create or use correct token"
};

// utils/index.ts
var WalletSDKError = class extends Error {
  constructor(message, code, originalError) {
    super(message);
    this.code = code;
    this.originalError = originalError;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var Blockchain = class {
  /**
   * Handles errors that occur within the Ethereum class.
   *
   * @param {keyof typeof ERROR_MESSAGES} code - The error code associated with the error.
   * @param {Error | WalletSDKError | unknown} originalError - The original error that was thrown.
   *
   * If the original error is an instance of WalletSDKError, it is thrown as is.
   * If the original error is an instance of the built-in Error class, a new WalletSDKError is thrown with the original error as the cause.
   * If the original error is not an instance of WalletSDKError or Error, a new WalletSDKError is thrown with a generic message and code.
   */
  handleError(code, originalError) {
    const message = this.ERROR_MESSAGES[code];
    if (originalError instanceof WalletSDKError || !message || !code) {
      throw originalError;
    }
    if (originalError instanceof Error) {
      const newMessage = Object.entries(this.ORIGINAL_ERROR_MESSAGES).find(
        ([originalMessage]) => originalError.message.includes(originalMessage)
      )?.[1];
      const errorMessage = newMessage || this.ERROR_MESSAGES[code] || COMMON_ERROR_MESSAGES["UNKNOWN_ERROR"];
      throw new WalletSDKError(errorMessage, String(code), originalError);
    }
    throw new WalletSDKError(
      COMMON_ERROR_MESSAGES["UNKNOWN_ERROR"],
      "UNKNOWN_ERROR"
    );
  }
  /**
   * Throws a WalletSDKError with a specified error code and message.
   *
   * @param {keyof typeof ERROR_MESSAGES} code - The error code associated with the error.
   * @param {...string[]} values - The values to be inserted into the error message.
   *
   * The method retrieves the error message template associated with the provided code from the ERROR_MESSAGES object.
   * It then replaces placeholders in the message template with provided values and throws a WalletSDKError with the final message and the provided code.
   */
  throwError(code, ...values) {
    let message = this.ERROR_MESSAGES[code];
    values.forEach((value, index) => {
      message = message?.replace(`{${index}}`, value);
    });
    if (!message) {
      throw new WalletSDKError(
        COMMON_ERROR_MESSAGES["UNKNOWN_ERROR"],
        "UNKNOWN_ERROR"
      );
    }
    throw new WalletSDKError(message, String(code));
  }
  /**
   * Check if the URL is valid
   *
   * @param {string} url - URL
   * @returns a bool type result.
   *
   */
  isValidURL(url) {
    let urlClass;
    try {
      urlClass = new URL(url);
    } catch (_) {
      return false;
    }
    return urlClass.protocol === "http:" || urlClass.protocol === "https:";
  }
};

// src/ethereum/index.ts
var Ethereum = class extends Blockchain {
  addressContractAccounting;
  addressContractPool;
  addressContractWithdrawTreasury;
  contractAccounting;
  contractPool;
  rpcUrl;
  web3;
  minAmount = new import_bignumber2.default(ETH_MIN_AMOUNT);
  ERROR_MESSAGES = ERROR_MESSAGES;
  ORIGINAL_ERROR_MESSAGES = ORIGINAL_ERROR_MESSAGES;
  constructor(network = "mainnet", url) {
    super();
    this.initializeNetwork(network, url);
  }
  /**
   * Retrieves the balance of the contract.
   *
   * This method calls the `balance` method on the `contractAccounting` contract,
   * converts the result from Wei to Ether, and returns the result as a `BigNumber`.
   *
   * @returns A promise that resolves to the balance of the contract as a `BigNumber`.
   *
   * @throws Will throw an error if the contract call fails.
   */
  async balance() {
    try {
      const result = await this.contractAccounting.methods.balance().call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("BALANCE_ERROR", error);
    }
  }
  /**
   * Fetches the pool pending balance. This balance is always less than 32 ETH.
   *
   * @returns A Promise that resolves to the pending balance in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async pendingBalance() {
    try {
      const result = await this.contractAccounting.methods.pendingBalance().call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("PENDING_BALANCE_ERROR", error);
    }
  }
  /**
   * Fetches the pool pending deposited balance. This is the balance deposited into the Beacon deposit contract but validators are still not active.
   *
   * @returns A Promise that resolves to the pending deposited balance in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async pendingDepositedBalance() {
    try {
      const result = await this.contractAccounting.methods.pendingDepositedBalance().call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("PENDING_DEPOSITED_BALANCE_ERROR", error);
    }
  }
  /**
   * Fetches the pool restaked rewards which are in pending status.
   *
   * @returns A Promise that resolves to the pending restaked rewards amount in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async pendingRestakedRewards() {
    try {
      const result = await this.contractAccounting.methods.pendingRestakedRewards().call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("PENDING_RESTAKED_REWARDS_ERROR", error);
    }
  }
  /**
   * Fetches the pool unclaimed rewards amount which can be restaked.
   *
   * @returns A Promise that resolves to the unclaimed rewards amount in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async readyforAutocompoundRewardsAmount() {
    try {
      const result = await this.contractAccounting.methods.readyforAutocompoundRewardsAmount().call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError(
        "READY_FOR_AUTOCOMPOUND_REWARDS_AMOUNT_ERROR",
        error
      );
    }
  }
  /**
   * Fetches the pending balance of a given address.
   *
   * @param address - The address to fetch the pending balance for.
   *
   * @returns A Promise that resolves to the pending balance in ether.
   *
   * @throws Will throw an Error if the contract call fails or address is not valid.
   */
  async pendingBalanceOf(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.pendingBalanceOf(address).call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("PENDING_BALANCE_OF_ERROR", error);
    }
  }
  /**
   * Fetches the user's pending deposited balance. This is the balance deposited into the validator but not active yet.
   * Pending deposited balance can't be unstaked till validator activation.
   *
   * @param address - The address to fetch the pending deposited balance for.
   *
   * @returns A Promise that resolves to the pending deposited balance in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async pendingDepositedBalanceOf(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.pendingDepositedBalanceOf(address).call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("PENDING_DEPOSITED_BALANCE_OF_ERROR", error);
    }
  }
  /**
   * Fetches the user's active origin deposited balance.
   *
   * @param address - The address to fetch the deposited balance for.
   *
   * @returns A Promise that resolves to the deposited balance in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async depositedBalanceOf(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.depositedBalanceOf(address).call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("DEPOSITED_BALANCE_OF_ERROR", error);
    }
  }
  /**
   * Fetches the user's restaked rewards in pending state.
   *
   * @param address - The address to fetch the pending restaked rewards for.
   *
   * @returns A Promise that resolves to the pending restaked rewards in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async pendingRestakedRewardOf(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.pendingRestakedRewardOf(address).call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("PENDING_RESTAKED_REWARD_OF_ERROR", error);
    }
  }
  /**
   * Returns total user restaked rewards. Includes rewards in pending state.
   *
   * @param address - The address to fetch the restaked rewards for.
   *
   * @returns A Promise that resolves to the restaked rewards in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async restakedRewardOf(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.restakedRewardOf(address).call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("RESTAKED_REWARD_OF_ERROR", error);
    }
  }
  /**
   * Fetches the pool fee in bips (1/10000).
   *
   * @returns A Promise that resolves to the pool fee.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async getPoolFee() {
    try {
      const result = await this.contractAccounting.methods.getPoolFee().call().toString();
      return new import_bignumber2.default(result).div(1e4);
    } catch (error) {
      throw this.handleError("GET_POOL_FEE_ERROR", error);
    }
  }
  /**
   * Claims all pool rewards and restakes it into the pool.
   *
   * @param address - The address to perform the autocompound operation for.
   *
   * @returns A Promise that resolves to a transaction object.
   *
   * @throws Will throw an Error if the contract call fails or there are no rewards.
   */
  async autocompound(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const rewards = await this.readyforAutocompoundRewardsAmount();
      if (rewards.isZero()) this.throwError("NO_REWARDS_MESSAGE");
      const gasConsumption = await this.contractAccounting.methods.autocompound().estimateGas({ from: address });
      return {
        from: address,
        to: this.addressContractAccounting,
        value: 0,
        gasLimit: this.calculateGasLimit(gasConsumption),
        data: this.contractAccounting.methods.autocompound().encodeABI()
      };
    } catch (error) {
      throw this.handleError("AUTOCOMPOUND_ERROR", error);
    }
  }
  /**
   * Returns total user autocompound balance. Part of this balance could be in pending state after rewards autocompound.
   *
   * @param address - The address to fetch the autocompound balance for.
   *
   * @returns A Promise that resolves to the autocompound balance in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async autocompoundBalanceOf(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.autocompoundBalanceOf(address).call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("AUTOCOMPOUND_BALANCE_OF_ERROR", error);
    }
  }
  /**
   * Returns info about withdraw requests queue.
   * Includes totally all-time requested withdraw amount,
   * actual allowed for interchange with deposits amount,
   * all-time withdraw treasury filled amount,
   * and all-time claimed by users amount.
   *
   * @returns A Promise that resolves to an object containing the withdraw request queue parameters.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async withdrawRequestQueueParams() {
    try {
      const result = await this.contractAccounting.methods.withdrawRequestQueueParams().call();
      return {
        // Totally all-time requested withdraw amount.
        withdrawRequested: this.fromWeiToEther(result[0]),
        // Actual allowed for interchange with deposits amount.
        interchangeAllowed: this.fromWeiToEther(result[1]),
        // All-time withdraw treasury filled amount.
        filled: this.fromWeiToEther(result[2]),
        // All-time claimed by users amount
        claimed: this.fromWeiToEther(result[3])
      };
    } catch (error) {
      throw this.handleError("WITHDRAW_REQUEST_QUEUE_PARAMS_ERROR", error);
    }
  }
  /**
   * Returns user withdraw request info. Includes the actual requested amount and the amount ready for claim.
   *
   * @param address - The address to fetch the withdraw request info for.
   *
   * @returns A Promise that resolves to an object containing the requested amount and the amount ready for claim in ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async withdrawRequest(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const result = await this.contractAccounting.methods.withdrawRequest(address).call();
      return {
        requested: this.fromWeiToEther(result[0]),
        readyForClaim: this.fromWeiToEther(result[1])
      };
    } catch (error) {
      throw this.handleError("WITHDRAW_REQUEST_ERROR", error);
    }
  }
  /**
   * Returns aggregated pool balances using multicall contract.
   *
   * @returns A Promise that resolves to a AggregatedBalances object.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async poolBalances() {
    const methods = [
      "balance",
      "pendingBalance",
      "pendingDepositedBalance",
      "pendingRestakedRewards",
      "readyforAutocompoundRewardsAmount"
    ];
    const result = {};
    try {
      const multicall = new import_ethereum_multicall.Multicall({
        multicallCustomContractAddress: MULTICALL_CONTRACT_ADDRESS,
        web3Instance: this.web3,
        tryAggregate: true
      });
      const contractCallContext = [];
      methods.forEach(
        (method) => contractCallContext.push({
          reference: method,
          contractAddress: this.addressContractAccounting,
          /* eslint-disable @typescript-eslint/no-explicit-any */
          abi: ABI_CONTRACT_ACCOUNTING,
          // TODO check it
          calls: [
            { reference: method, methodName: method, methodParameters: [] }
          ]
        })
      );
      const results = await multicall.call(contractCallContext);
      for (const [key, value] of Object.entries(results.results)) {
        result[key] = this.web3.utils.fromWei(
          value.callsReturnContext[0]?.returnValues[0].hex,
          "ether"
        );
      }
    } catch (error) {
      throw this.handleError("POOL_BALANCES_ERROR", error);
    }
    return result;
  }
  /**
   * Returns aggregated user balances using multicall contract.
   *
   * @param address - The user address.
   *
   * @returns A Promise that resolves to a AggregatedBalances object.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async userBalances(address) {
    const methods = [
      "pendingBalanceOf",
      "pendingDepositedBalanceOf",
      "pendingRestakedRewardOf",
      "autocompoundBalanceOf",
      "depositedBalanceOf"
    ];
    const result = {};
    try {
      const multicall = new import_ethereum_multicall.Multicall({
        multicallCustomContractAddress: MULTICALL_CONTRACT_ADDRESS,
        web3Instance: this.web3,
        tryAggregate: true
      });
      const contractCallContext = [];
      methods.forEach(
        (method) => contractCallContext.push({
          reference: method,
          contractAddress: this.addressContractAccounting,
          /* eslint-disable @typescript-eslint/no-explicit-any */
          abi: ABI_CONTRACT_ACCOUNTING,
          // TODO check it
          calls: [
            {
              reference: method,
              methodName: method,
              methodParameters: [address]
            }
          ]
        })
      );
      const results = await multicall.call(contractCallContext);
      for (const [key, value] of Object.entries(results.results)) {
        result[key] = this.web3.utils.fromWei(
          value.callsReturnContext[0]?.returnValues[0].hex,
          "ether"
        );
      }
    } catch (error) {
      throw this.handleError("USER_BALANCES_ERROR", error);
    }
    return result;
  }
  /**
   * Claims funds requested by withdraw.
   *
   * @param address - The address to perform the claim operation for.
   *
   * @returns A Promise that resolves to a transaction object.
   *
   * @throws Will throw an Error if the contract call fails, there are no funds to claim, or the claim is not yet filled.
   */
  async claimWithdrawRequest(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const rewards = await this.withdrawRequest(address);
      if (rewards.requested.isZero()) {
        this.throwError("ZERO_UNSTAKE_ERROR");
      }
      if (!rewards.readyForClaim.eq(rewards.requested)) {
        this.throwError("NOT_FILLED_UNSTAKE_MESSAGE");
      }
      const gasConsumption = await this.contractAccounting.methods.claimWithdrawRequest().estimateGas({ from: address });
      return {
        from: address,
        to: this.addressContractAccounting,
        value: 0,
        gasLimit: this.calculateGasLimit(gasConsumption),
        data: this.contractAccounting.methods.claimWithdrawRequest().encodeABI()
      };
    } catch (error) {
      throw this.handleError("CLAIM_WITHDRAW_REQUEST_ERROR", error);
    }
  }
  /**
   * Returns the number of validators expected to stop.
   *
   * @returns A Promise that resolves to the number of validators expected to stop.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async closeValidatorsStat() {
    try {
      const result = await this.contractAccounting.methods.closeValidatorsStat().call();
      return Number(result);
    } catch (error) {
      throw this.handleError("CLOSE_VALIDATORS_STAT_ERROR", error);
    }
  }
  /**
   * Stakes funds into pool.
   *
   * @param address - Sender address.
   * @param amount - Stake amount in ETH
   * @param source - Stake source. Default is '0'.
   *
   * @returns A Promise that resolves to the unsigned ETH transaction object.
   *
   * @throws Will throw an Error if the amount is not a valid, the amount is less than the minimum, or the contract call fails.
   */
  async stake(address, amount, source = "0") {
    if (!this.isAddress(address)) {
      this.throwError("ADDRESS_FORMAT_ERROR");
    }
    if (typeof amount !== "string") {
      this.throwError("WRONG_TYPE_MESSAGE");
    }
    const amountWei = this.web3.utils.toWei(amount, "ether");
    if (new import_bignumber2.default(amountWei).lt(this.minAmount)) {
      this.throwError("MIN_AMOUNT_ERROR", this.minAmount.toString());
    }
    try {
      const gasConsumption = await this.contractPool.methods.stake(source).estimateGas({ from: address, value: amountWei });
      return {
        from: address,
        to: this.addressContractPool,
        value: Number(amount),
        gasLimit: this.calculateGasLimit(gasConsumption),
        data: this.contractPool.methods.stake(source).encodeABI()
      };
    } catch (error) {
      throw this.handleError("STAKE_ERROR", error);
    }
  }
  /**
   * Unstake value from active autocompound balance.
   * AllowedInterchangeNum is max allowed number interchanges with pending stakers.
   * Unstaked immediately if value <= pool pending balance or create withdraw request.
   * Interchange disallowed as default.
   *
   * @param address - Sender address.
   * @param amount - Unstake amount in ETH.
   * @param allowedInterchangeNum - Max allowed number of interchanges. Default is 0.
   * @param source - Unstake source. Default is '0'.
   *
   * @returns A Promise that resolves to the unsigned ETH transaction object.
   *
   * @throws Will throw an Error if the amount is not a string, the balance is less than the amount, or the contract call fails.
   */
  async unstake(address, amount, allowedInterchangeNum = 0, source = "0") {
    if (!this.isAddress(address)) {
      this.throwError("ADDRESS_FORMAT_ERROR");
    }
    if (typeof amount !== "string") {
      this.throwError("WRONG_TYPE_MESSAGE");
    }
    try {
      const balance = await this.autocompoundBalanceOf(address);
      if (allowedInterchangeNum > UINT16_MAX) {
        allowedInterchangeNum = UINT16_MAX;
      }
      if (balance.lt(new import_bignumber2.default(amount))) {
        this.throwError("MAX_AMOUNT_FOR_UNSTAKE_ERROR", balance.toString());
      }
      const amountWei = this.web3.utils.toWei(amount, "ether");
      const gasConsumption = await this.contractPool.methods.unstake(amountWei, allowedInterchangeNum, source).estimateGas({ from: address });
      return {
        from: address,
        value: 0,
        to: this.addressContractPool,
        gasLimit: this.calculateGasLimit(gasConsumption),
        data: this.contractPool.methods.unstake(amountWei, allowedInterchangeNum, source).encodeABI()
      };
    } catch (error) {
      throw this.handleError("UNSTAKE_ERROR", error);
    }
  }
  /**
   * Simulate unstake transaction and return amount of instant unstake.
   * Required to compare evaluation of allowedInterchangeNum parameter.
   *
   * @param address - Sender address.
   * @param amount - Unstake amount in ETH.
   * @param allowedInterchangeNum - Max allowed number of interchanges. Default is 1.
   * @param source - Unstake source. Default is '0'.
   *
   * @returns A Promise that resolves to a BigNumber representing the instant unstake amount in ETH.
   *
   * @throws Will throw an Error if the balance is less than the amount or the contract call fails.
   */
  async simulateUnstake(address, amount, allowedInterchangeNum = 1, source = "0") {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const balance = await this.autocompoundBalanceOf(address);
      if (allowedInterchangeNum > UINT16_MAX) {
        allowedInterchangeNum = UINT16_MAX;
      }
      if (balance.lt(amount)) {
        this.throwError("MAX_AMOUNT_FOR_UNSTAKE_ERROR", balance.toString());
      }
      const amountWei = this.web3.utils.toWei(amount, "ether");
      const result = await this.contractPool.methods.unstake(amountWei, allowedInterchangeNum, source).call({ from: address });
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("SIMULATE_UNSTAKE_ERROR", error);
    }
  }
  /**
   * Unstakes the pending amount from Autocompound.
   *
   * @param address - The address from which the amount will be unstaked.
   * @param amount - The amount to unstake.
   *
   * @returns A Promise that resolves to a transaction object.
   *
   * @throws Will throw an Error if the pending balance is zero, the amount is greater than the pending balance,
   * or the pending balance is less than the minimum stake amount.
   */
  async unstakePending(address, amount) {
    if (!this.isAddress(address)) {
      this.throwError("ADDRESS_FORMAT_ERROR");
    }
    let pendingBalance = await this.pendingBalanceOf(address);
    if (pendingBalance.isZero()) {
      this.throwError("ZERO_UNSTAKE_MESSAGE");
    }
    const bnAmount = new import_bignumber2.default(amount);
    if (bnAmount.gt(pendingBalance)) {
      this.throwError(
        "AMOUNT_GREATER_THAN_PENDING_BALANCE_ERROR",
        pendingBalance.toString()
      );
    }
    try {
      pendingBalance = pendingBalance.minus(bnAmount);
      if (!pendingBalance.isZero()) {
        const minStake = await this.minStakeAmount();
        if (pendingBalance.lt(minStake)) {
          this.throwError(
            "INSUFFICIENT_PENDING_BALANCE_ERROR",
            minStake.toString()
          );
        }
      }
      const amountWei = this.web3.utils.toWei(amount.toString(), "ether");
      const gasConsumption = await this.contractPool.methods.unstakePending(amountWei).estimateGas({ from: address });
      return {
        from: address,
        value: 0,
        to: this.addressContractPool,
        gasLimit: this.calculateGasLimit(gasConsumption),
        data: this.contractPool.methods.unstakePending(amountWei).encodeABI()
      };
    } catch (error) {
      throw this.handleError("UNSTAKE_PENDING_ERROR", error);
    }
  }
  /**
   * Activates pending stake by interchange with withdraw request.
   *
   * @param address - The address from which the stake will be activated.
   *
   * @returns A Promise that resolves to a transaction object.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async activateStake(address) {
    try {
      if (!this.isAddress(address)) {
        this.throwError("ADDRESS_FORMAT_ERROR");
      }
      const gasAmount = await this.contractPool.methods.activateStake().estimateGas({ from: address });
      return {
        from: address,
        to: this.addressContractPool,
        value: 0,
        gasLimit: this.calculateGasLimit(gasAmount),
        data: this.contractPool.methods.activateStake().encodeABI()
      };
    } catch (error) {
      throw this.handleError("ACTIVATE_STAKE_ERROR", error);
    }
  }
  /**
   * Fetches the number of validators prepared for deposit from the contract pool.
   *
   * @returns A Promise that resolves to the number of validators prepared for deposit.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async getPendingValidatorCount() {
    try {
      const result = await this.contractPool.methods.getPendingValidatorCount().call();
      return Number(result);
    } catch (error) {
      throw this.handleError("GET_PENDING_VALIDATOR_COUNT_ERROR", error);
    }
  }
  /**
   * Fetches a pending validator's public key by index from the contract pool.
   * Note: The list of pending validators is dynamic so ordering is unstable.
   *
   * @param index - The index of the pending validator to fetch.
   *
   * @returns A Promise that resolves to the public key of the pending validator.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async getPendingValidator(index) {
    try {
      const result = await this.contractPool.methods.getPendingValidator(index).call();
      return result.toString();
    } catch (error) {
      throw this.handleError("GET_PENDING_VALIDATOR_ERROR", error);
    }
  }
  /**
   * Fetches the total number of known validators from the contract pool.
   * A validator can be in one of the following statuses: pending, deposited, exited.
   * Exited validators will be overwritten by new pending validators to optimize memory usage.
   *
   * @returns A Promise that resolves to the total number of known validators.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async getValidatorCount() {
    try {
      const result = await this.contractPool.methods.getValidatorCount().call();
      return Number(result);
    } catch (error) {
      throw this.handleError("GET_VALIDATOR_COUNT_ERROR", error);
    }
  }
  /**
   * Fetches a validator from the contract pool by its index.
   * The result is an object containing the validator's public key and status.
   *
   * @param index - The index of the validator to fetch.
   *
   * @returns A Promise that resolves to an object with the validator's public key and status.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async getValidator(index) {
    try {
      const result = await this.contractPool.methods.getValidator(index).call();
      return {
        pubkey: result[0].toString(),
        status: this.getStatusFromCode(Number(result[1]))
      };
    } catch (error) {
      throw this.handleError("GET_VALIDATOR_ERROR", error);
    }
  }
  /**
   * Fetches the minimum stake amount from the contract pool.
   * The result is converted from Wei to Ether using Web3 utilities.
   *
   * @returns A Promise that resolves to a BigNumber representing the minimum stake amount in Ether.
   *
   * @throws Will throw an Error if the contract call fails.
   */
  async minStakeAmount() {
    try {
      const result = await this.contractPool.methods.minStakeAmount().call();
      return this.fromWeiToEther(result);
    } catch (error) {
      throw this.handleError("MIN_STAKE_AMOUNT_ERROR", error);
    }
  }
  /**
   * Selects and initializes a new network.
   *
   * This method calls `initializeNetwork` with the provided parameters and returns the current instance,
   * allowing for method chaining.
   *
   * @param network - The network type. This should be one of the keys in `NETWORK_ADDRESSES`.
   * @param url - The RPC URL of the network. If not provided, the method will use the URL from `NETWORK_ADDRESSES`.
   *
   * @returns The current instance of the `Ethereum` class.
   */
  selectNetwork(network, url) {
    this.initializeNetwork(network, url);
    return this;
  }
  /**
   * Initializes the network.
   *
   * This method sets the RPC URL, contract addresses, and initializes the Web3 instance and contracts.
   *
   * @param network - The network type. This should be one of the keys in `NETWORK_ADDRESSES`.
   * @param url - The RPC URL of the network. If not provided, the method will use the URL from `NETWORK_ADDRESSES`.
   *
   * @throws Will throw an error if the provided network is not supported (i.e., not a key in `NETWORK_ADDRESSES`).
   */
  initializeNetwork(network, url) {
    const networkAddresses = ETH_NETWORK_ADDRESSES[network];
    if (!networkAddresses) {
      this.throwError("NETWORK_NOT_SUPPORTED", network);
    }
    const providerUrl = url ?? networkAddresses.rpcUrl;
    this.rpcUrl = new import_web32.HttpProvider(providerUrl);
    this.addressContractAccounting = networkAddresses.addressContractAccounting;
    this.addressContractPool = networkAddresses.addressContractPool;
    this.addressContractWithdrawTreasury = networkAddresses.addressContractWithdrawTreasury;
    this.web3 = new import_web3.default(this.rpcUrl);
    this.contractAccounting = new this.web3.eth.Contract(
      ABI_CONTRACT_ACCOUNTING,
      this.addressContractAccounting
    );
    this.contractPool = new this.web3.eth.Contract(
      ABI_CONTRACT_POOL,
      this.addressContractPool
    );
  }
  /**
   * Converts a status code into a human-readable status.
   *
   * @param code - The status code to convert. '0' means 'unknown', '1' means 'pending', any other value means 'deposited'.
   *
   * @returns The human-readable status corresponding to the given code.
   */
  getStatusFromCode(code) {
    return ValidatorStatus[code] ? ValidatorStatus[code].toLowerCase() : "invalid status";
  }
  /**
   * Converts the given amount from Wei to Ether.
   *
   * @param amount - The amount in Wei to convert to Ether.
   *
   * @returns The converted amount in Ether as a BigNumber.
   */
  fromWeiToEther(amount) {
    return new import_bignumber2.default(this.web3.utils.fromWei(amount, "ether"));
  }
  /**
   * Calculates the gas limit by adding a predefined GAS_RESERVE to the given gas consumption.
   *
   * @param gasConsumption - The amount of gas consumed.
   *
   * @returns The calculated gas limit as a number.
   */
  calculateGasLimit(gasConsumption) {
    return new import_bignumber2.default(gasConsumption.toString()).plus(ETH_GAS_RESERVE).toNumber();
  }
  /**
   * Checks if a given address has the basic requirements of an Ethereum address format.
   *
   * @param address - The Ethereum address to validate.
   *
   * @returns `true` if the address meets basic requirements, otherwise `false`.
   */
  isAddress(address) {
    return /^(0x)?([0-9a-f]{40})$/.test(address.toLowerCase());
  }
};

// src/solana/index.ts
var import_web35 = require("@solana/web3.js");

// src/solana/constants/errors.ts
var ERROR_MESSAGES2 = {
  CONNECTION_ERROR: "An error occurred while connecting to the network",
  MIN_AMOUNT_ERROR: "Min Amount {0}",
  CREATE_ACCOUNT_ERROR: "An error occurred while creating the account",
  DELEGATE_ERROR: "An error occurred while delegating the stake",
  DEACTIVATE_ERROR: "An error occurred while deactivating the stake",
  WITHDRAW_ERROR: "An error occurred while withdrawing the stake",
  GET_DELEGATIONS_ERROR: "An error occurred while fetching the delegations",
  STAKE_ERROR: "An error occurred while staking",
  INVALID_RPC_ERROR: "Invalid RPC URL",
  UNSUPPORTED_NETWORK_ERROR: "Unsupported Network",
  CLAIM_ERROR: "An error occurred while claim SOL",
  UNSTAKE_ERROR: "An error occurred while unstaking the stake",
  NOTHING_TO_CLAIM_ERROR: "Nothing to claim while claiming",
  NOT_ENOUGH_ACTIVE_STAKE_ERROR: "Active stake less than requested",
  GET_EPOCH_INFO_ERROR: "An error occurred while fetching epoch information"
};

// src/solana/constants/index.ts
var import_web33 = require("@solana/web3.js");
var import_superstruct = require("superstruct");
var SOL_CHAIN = "solana";
var SOL_MIN_AMOUNT = 1e7;
var SOL_MAINNET_VALIDATOR_ADDRESS = new import_web33.PublicKey(
  "9QU2QSxhb24FUX3Tu2FpczXjpK3VYrvRudywSZaM29mF"
);
var SOL_DEVNET_VALIDATOR_ADDRESS = new import_web33.PublicKey(
  "GkqYQysEGmuL6V2AJoNnWZUz2ZBGWhzQXsJiXm2CLKAN"
);
var FILTER_DATA_SIZE = 200;
var FILTER_OFFSET = 44;
var SolNetwork = /* @__PURE__ */ ((SolNetwork2) => {
  SolNetwork2["Mainnet"] = "mainnet-beta";
  SolNetwork2["Devnet"] = "devnet";
  return SolNetwork2;
})(SolNetwork || {});
var StakeState = {
  inactive: "inactive",
  activating: "activating",
  active: "active",
  deactivating: "deactivating",
  deactivated: "deactivated"
};
var StakeAccountType = (0, import_superstruct.enums)([
  "uninitialized",
  "initialized",
  "delegated",
  "rewardsPool"
]);

// src/solana/index.ts
var import_bignumber5 = __toESM(require("bignumber.js"));

// src/solana/types/stakeAccount.ts
var import_web34 = require("@solana/web3.js");
var import_superstruct2 = require("superstruct");
var import_bignumber3 = __toESM(require("bignumber.js"));
var BigNumFromString = (0, import_superstruct2.coerce)(
  (0, import_superstruct2.instance)(import_bignumber3.default),
  (0, import_superstruct2.string)(),
  (value) => {
    if (typeof value === "string") return new import_bignumber3.default(value, 10);
    throw new Error("invalid big num");
  }
);
var PublicKeyFromString = (0, import_superstruct2.coerce)(
  (0, import_superstruct2.instance)(import_web34.PublicKey),
  (0, import_superstruct2.string)(),
  (value) => new import_web34.PublicKey(value)
);
var StakeMeta = (0, import_superstruct2.type)({
  rentExemptReserve: BigNumFromString,
  authorized: (0, import_superstruct2.type)({
    staker: PublicKeyFromString,
    withdrawer: PublicKeyFromString
  }),
  lockup: (0, import_superstruct2.type)({
    unixTimestamp: (0, import_superstruct2.number)(),
    epoch: (0, import_superstruct2.number)(),
    custodian: PublicKeyFromString
  })
});
var StakeAccountInfo = (0, import_superstruct2.type)({
  meta: StakeMeta,
  stake: (0, import_superstruct2.nullable)(
    (0, import_superstruct2.type)({
      delegation: (0, import_superstruct2.type)({
        voter: PublicKeyFromString,
        stake: BigNumFromString,
        activationEpoch: BigNumFromString,
        deactivationEpoch: BigNumFromString,
        warmupCooldownRate: (0, import_superstruct2.number)()
      }),
      creditsObserved: (0, import_superstruct2.number)()
    })
  )
});
var StakeAccount = (0, import_superstruct2.type)({
  type: StakeAccountType,
  info: StakeAccountInfo
});

// src/solana/stakeAccount.ts
var import_superstruct3 = require("superstruct");
var import_bignumber4 = __toESM(require("bignumber.js"));
var ParseStakeAccountError = class extends Error {
};
var StakeAccount2 = class {
  account;
  constructor({
    executable,
    owner,
    lamports,
    data,
    rentEpoch
  }) {
    if (!("parsed" in data)) {
      throw new ParseStakeAccountError(
        "Raw AccountInfo<Buffer>, data not parsed"
      );
    }
    try {
      const parsedData = (0, import_superstruct3.create)(data.parsed, StakeAccount);
      this.account = {
        executable,
        owner,
        lamports,
        data: parsedData,
        rentEpoch
      };
    } catch (e) {
      throw new ParseStakeAccountError(e.message);
    }
  }
  /**
   * Check if lockup is in force
   * @param currEpoch current epoch.
   * @param currUnixTimestamp current unix timetamp.
   * @returns a bool type result.
   */
  isLockupInForce(currEpoch, currUnixTimestamp) {
    return this.account.data.info.meta.lockup.unixTimestamp > currUnixTimestamp || this.account.data.info.meta.lockup.epoch > currEpoch;
  }
  /**
   * Determins the current state of a stake account given the current epoch
   * @param currentEpoch
   * @returns `stakeAccount`'s stake state`string`
   */
  stakeAccountState(currentEpoch) {
    const {
      type: type2,
      info: { stake }
    } = this.account.data;
    if (type2 !== "delegated" || stake === null) {
      return StakeState.inactive;
    }
    const currentEpochBN = new import_bignumber4.default(currentEpoch);
    const activationEpoch = new import_bignumber4.default(stake.delegation.activationEpoch);
    const deactivationEpoch = new import_bignumber4.default(stake.delegation.deactivationEpoch);
    if (activationEpoch.gt(currentEpochBN)) {
      return StakeState.inactive;
    }
    if (activationEpoch.eq(currentEpochBN)) {
      if (deactivationEpoch.eq(activationEpoch)) return StakeState.inactive;
      return StakeState.activating;
    }
    if (deactivationEpoch.gt(currentEpochBN)) return StakeState.active;
    if (deactivationEpoch.eq(currentEpochBN)) return StakeState.deactivating;
    return StakeState.deactivated;
  }
};

// src/solana/index.ts
var Solana = class extends Blockchain {
  connection;
  validator;
  ERROR_MESSAGES = ERROR_MESSAGES2;
  ORIGINAL_ERROR_MESSAGES = {};
  constructor(network = "mainnet-beta" /* Mainnet */, rpc = null) {
    super();
    if (rpc && !this.isValidURL(rpc)) {
      throw this.throwError("INVALID_RPC_ERROR");
    }
    rpc = rpc || (0, import_web35.clusterApiUrl)(network);
    try {
      this.connection = new import_web35.Connection(rpc, "confirmed");
    } catch (error) {
      throw this.handleError("CONNECTION_ERROR", error);
    }
    switch (network) {
      case "mainnet-beta" /* Mainnet */:
        this.validator = SOL_MAINNET_VALIDATOR_ADDRESS;
        break;
      case "devnet" /* Devnet */:
        this.validator = SOL_DEVNET_VALIDATOR_ADDRESS;
        break;
      default:
        throw this.throwError("UNSUPPORTED_NETWORK_ERROR");
    }
  }
  /**
   * Creates a new stake account.
   *
   * @param address - The public key of the account as PublicKey.
   * @param lamports  - The amount to stake in lamports.
   * @param source  - stake source
   * @param lockup - stake account lockup
   *
   * @throws  Throws an error if the lamports is less than the minimum amount.
   * @throws  Throws an error if there's an issue creating the stake account.
   *
   * @returns Returns a promise that resolves with the versioned transaction of the stake account creation and the public key of the stake account.
   *
   */
  async createAccount(address, lamports, source, lockup = import_web35.Lockup.default) {
    if (lamports < SOL_MIN_AMOUNT) {
      this.throwError("MIN_AMOUNT_ERROR", SOL_MIN_AMOUNT.toString());
    }
    try {
      const publicKey = new import_web35.PublicKey(address);
      const minimumRent = await this.connection.getMinimumBalanceForRentExemption(
        import_web35.StakeProgram.space
      );
      lockup = lockup || import_web35.Lockup.default;
      const [createStakeAccountTx, stakeAccountPublicKey, externalSigners] = source === null ? await this.createAccountTx(
        publicKey,
        lamports + minimumRent,
        lockup
      ) : await this.createAccountWithSeedTx(
        publicKey,
        lamports + minimumRent,
        source,
        lockup
      );
      const versionedTX = await this.prepareTransaction(
        createStakeAccountTx.instructions,
        publicKey,
        externalSigners
      );
      return {
        result: {
          createStakeAccountVerTx: versionedTX,
          stakeAccount: stakeAccountPublicKey
        }
      };
    } catch (error) {
      throw this.handleError("CREATE_ACCOUNT_ERROR", error);
    }
  }
  /**
   * Prepares a transaction with the given instructions and payer.
   *
   * @param instructions - An array of TransactionInstruction objects.
   * @param payer - The public key of the payer.
   * @param externalSigners - an array of external signers.
   * @returns A promise that resolves to a VersionedTransaction object.
   */
  async prepareTransaction(instructions, payer, externalSigners) {
    const blockhash = await this.getBlockhash();
    const messageV0 = new import_web35.TransactionMessage({
      payerKey: payer,
      recentBlockhash: blockhash,
      instructions
    }).compileToV0Message();
    const tx = new import_web35.VersionedTransaction(messageV0);
    if (externalSigners.length > 0) {
      tx.sign(externalSigners);
    }
    return tx;
  }
  /**
   * Retrieves the latest blockhash.
   *
   * @returns A promise that resolves to a string representing the blockhash.
   */
  async getBlockhash() {
    const res = await this.connection.getLatestBlockhash({
      commitment: "max"
    });
    return res.blockhash;
  }
  /**
   * Delegates a specified amount from a stake account to a validator.
   *
   * @param address - The public key of the account.
   * @param lamports - The amount in lamports to be delegated.
   * @param stakeAccount - The public key of the stake account.
   *
   * @throws Throws an error if the amount is less than the minimum amount, or if there's an issue during the delegation process.
   *
   * @returns Returns a promise that resolves with the delegation transaction.
   *
   */
  async delegate(address, lamports, stakeAccount) {
    if (lamports < SOL_MIN_AMOUNT) {
      this.throwError("MIN_AMOUNT_ERROR", SOL_MIN_AMOUNT.toString());
    }
    try {
      const publicKey = new import_web35.PublicKey(address);
      const stakeAccountPublicKey = new import_web35.PublicKey(stakeAccount);
      const delegateTx = new import_web35.Transaction().add(
        import_web35.StakeProgram.delegate({
          stakePubkey: stakeAccountPublicKey,
          authorizedPubkey: publicKey,
          votePubkey: this.validator
        })
      );
      const delegateVerTx = await this.prepareTransaction(
        delegateTx.instructions,
        publicKey,
        []
      );
      return { result: delegateVerTx };
    } catch (error) {
      throw this.handleError("DELEGATE_ERROR", error);
    }
  }
  /**
   * Deactivates a stake account.
   *
   * @param address - The public key of the account.
   * @param stakeAccountPublicKey - The public key of the stake account.
   * @throws Throws an error if there's an issue during the deactivation process.
   * @returns Returns a promise that resolves with the deactivation transaction.
   *
   */
  async deactivate(address, stakeAccountPublicKey) {
    try {
      const publicKey = new import_web35.PublicKey(address);
      const stakeAccount = new import_web35.PublicKey(stakeAccountPublicKey);
      const deactivateTx = new import_web35.Transaction().add(
        import_web35.StakeProgram.deactivate({
          stakePubkey: stakeAccount,
          authorizedPubkey: publicKey
        })
      );
      const deactivateVerTx = await this.prepareTransaction(
        deactivateTx.instructions,
        publicKey,
        []
      );
      return { result: deactivateVerTx };
    } catch (error) {
      throw this.handleError("DEACTIVATE_ERROR", error);
    }
  }
  /**
   * Withdraws a specified amount from a stake account.
   *
   * @param address - The public key of the account.
   * @param stakeAccountPublicKey - The public key of the stake account.
   * @param stakeBalance - The amount in lamports to be withdrawn from the stake account.
   *
   * @throws Throws an error if there's an issue during the withdrawal process.
   *
   * @returns Returns a promise that resolves with the withdrawal transaction.
   *
   */
  async withdraw(address, stakeAccountPublicKey, stakeBalance) {
    try {
      const publicKey = new import_web35.PublicKey(address);
      const stakeAccount = new import_web35.PublicKey(stakeAccountPublicKey);
      const withdrawTx = new import_web35.Transaction().add(
        import_web35.StakeProgram.withdraw({
          stakePubkey: stakeAccount,
          authorizedPubkey: publicKey,
          toPubkey: publicKey,
          lamports: stakeBalance
        })
      );
      const withdrawVerTx = await this.prepareTransaction(
        withdrawTx.instructions,
        publicKey,
        []
      );
      return { result: withdrawVerTx };
    } catch (error) {
      throw this.handleError("WITHDRAW_ERROR", error);
    }
  }
  /**
   * Fetches the delegations of a given account.
   *
   * @param address - The public key of the account.
   *
   * @throws Throws an error if there's an issue fetching the delegations.
   *
   * @returns Returns a promise that resolves with the delegations of the account.
   *
   */
  async getDelegations(address) {
    try {
      const filters = [
        { dataSize: FILTER_DATA_SIZE },
        { memcmp: { offset: FILTER_OFFSET, bytes: address } }
      ];
      const accounts = await this.connection.getParsedProgramAccounts(
        import_web35.StakeProgram.programId,
        { filters }
      );
      return { result: accounts };
    } catch (error) {
      throw this.handleError("GET_DELEGATIONS_ERROR", error);
    }
  }
  /**
   * Stakes a certain amount of lamports.
   *
   * @param sender - The public key of the sender.
   * @param lamports - The number of lamports to stake.
   * @param source  - stake source
   * @param lockup - stake account lockup
   * @returns A promise that resolves to a VersionedTransaction object.
   */
  async stake(sender, lamports, source, lockup = import_web35.Lockup.default) {
    try {
      const senderPublicKey = new import_web35.PublicKey(sender);
      const minimumRent = await this.connection.getMinimumBalanceForRentExemption(
        import_web35.StakeProgram.space
      );
      lockup = lockup || import_web35.Lockup.default;
      const [createStakeAccountTx, stakeAccountPublicKey, externalSigners] = source === null ? await this.createAccountTx(
        senderPublicKey,
        lamports + minimumRent,
        lockup
      ) : await this.createAccountWithSeedTx(
        senderPublicKey,
        lamports + minimumRent,
        source,
        lockup
      );
      const stakeTx = new import_web35.Transaction().add(
        import_web35.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 50 }),
        createStakeAccountTx,
        import_web35.StakeProgram.delegate({
          stakePubkey: stakeAccountPublicKey,
          authorizedPubkey: senderPublicKey,
          votePubkey: this.validator
        })
      );
      const stakeVerTx = await this.prepareTransaction(
        stakeTx.instructions,
        senderPublicKey,
        externalSigners
      );
      return { result: stakeVerTx };
    } catch (error) {
      throw this.handleError("STAKE_ERROR", error);
    }
  }
  /**
   * Create account Tx, public key and array of keypair.
   *
   * @param address - The public key of the account.
   * @param lamports - The number of lamports to stake.
   * @param lockup - The stake account lockup
   *
   * @throws Throws an error if there's an issue creating an account.
   *
   * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
   *
   */
  async createAccountTx(address, lamports, lockup) {
    const blockhash = await this.getBlockhash();
    const stakeAccount = import_web35.Keypair.generate();
    const createStakeAccountTx = import_web35.StakeProgram.createAccount({
      authorized: new import_web35.Authorized(address, address),
      fromPubkey: address,
      lamports,
      stakePubkey: stakeAccount.publicKey,
      lockup
    });
    createStakeAccountTx.recentBlockhash = blockhash;
    createStakeAccountTx.sign(stakeAccount);
    return [createStakeAccountTx, stakeAccount.publicKey, [stakeAccount]];
  }
  /**
   * Create account Tx, public key and array of keypair using seed.
   *
   * @param authorityPublicKey - The public key of the account.
   * @param lamports - The number of lamports to stake.
   * @param source - The stake source
   * @param lockup - The stake account lockup
   *
   * @throws Throws an error if there's an issue creating an account.
   *
   * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
   *
   */
  async createAccountWithSeedTx(authorityPublicKey, lamports, source, lockup) {
    const seed = this.formatSource(source);
    const stakeAccountPubkey = await import_web35.PublicKey.createWithSeed(
      authorityPublicKey,
      seed,
      import_web35.StakeProgram.programId
    );
    const createStakeAccountTx = new import_web35.Transaction().add(
      import_web35.StakeProgram.createAccountWithSeed({
        authorized: new import_web35.Authorized(authorityPublicKey, authorityPublicKey),
        fromPubkey: authorityPublicKey,
        basePubkey: authorityPublicKey,
        stakePubkey: stakeAccountPubkey,
        lockup,
        seed,
        lamports
      })
    );
    return [createStakeAccountTx, stakeAccountPubkey, []];
  }
  /** unstake - unstake
   * @param {string} sender - account blockchain address (staker)
   * @param {number} lamports - lamport amount
   * @param {string} source - stake source
   * @returns {Promise<object>} Promise object with Versioned Tx
   */
  async unstake(sender, lamports, source) {
    try {
      const delegations = await this.getDelegations(sender);
      const stakeAccounts = delegations.result.map((delegationAcc) => {
        return {
          pubkey: delegationAcc.pubkey,
          account: new StakeAccount2(delegationAcc.account)
        };
      });
      const epochInfo = await this.connection.getEpochInfo();
      const tm = this.timestampInSec();
      let totalActiveStake = new import_bignumber5.default(0);
      const activeStakeAccounts = stakeAccounts.filter((acc) => {
        const isActive = !(acc.account.isLockupInForce(epochInfo.epoch, tm) || acc.account.stakeAccountState(epochInfo.epoch) !== StakeState.active);
        if (isActive && acc.account.account.data.info.stake) {
          totalActiveStake = totalActiveStake.plus(
            acc.account.account.data.info.stake.delegation.stake
          );
        }
        return isActive;
      });
      let lamportsBN = new import_bignumber5.default(lamports);
      if (totalActiveStake.lt(lamportsBN))
        throw this.throwError("NOT_ENOUGH_ACTIVE_STAKE_ERROR");
      activeStakeAccounts.sort((a, b) => {
        const stakeA = a.account.account.data.info.stake?.delegation.stake;
        const stakeB = b.account.account.data.info.stake?.delegation.stake;
        if (!stakeA || !stakeB) return 0;
        return stakeA.minus(stakeB).toNumber();
      });
      const accountsToDeactivate = [];
      const accountsToSplit = [];
      let i = 0;
      while (lamportsBN.gt(new import_bignumber5.default(0)) && i < activeStakeAccounts.length) {
        const acc = activeStakeAccounts[i];
        if (acc === void 0 || acc.account.account.data.info.stake === null) {
          i++;
          continue;
        }
        const stakeAmount = acc.account.account.data.info.stake.delegation.stake;
        const isBelowThreshold = stakeAmount.lte(lamportsBN) || stakeAmount.minus(lamportsBN).lt(SOL_MIN_AMOUNT);
        if (isBelowThreshold) {
          accountsToDeactivate.push(acc);
          lamportsBN = lamportsBN.minus(stakeAmount);
          i++;
          continue;
        }
        accountsToSplit.push({ account: acc, lamports: lamportsBN.toNumber() });
        break;
      }
      const senderPublicKey = new import_web35.PublicKey(sender);
      let instructions = [
        import_web35.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 50 })
      ];
      const minimumRent = await this.connection.getMinimumBalanceForRentExemption(
        import_web35.StakeProgram.space
      );
      for (const acc of accountsToSplit) {
        const [tx, newStakeAccountPubkey] = await this.split(
          senderPublicKey,
          acc.lamports,
          acc.account.pubkey,
          source,
          minimumRent
        );
        const deactivateTx = import_web35.StakeProgram.deactivate({
          stakePubkey: newStakeAccountPubkey,
          authorizedPubkey: senderPublicKey
        });
        instructions.push(...tx.instructions, ...deactivateTx.instructions);
      }
      for (const acc of accountsToDeactivate) {
        const deactivateTx = import_web35.StakeProgram.deactivate({
          stakePubkey: acc.pubkey,
          authorizedPubkey: senderPublicKey
        });
        instructions.push(...deactivateTx.instructions);
      }
      instructions = instructions.map((instruction) => {
        return new import_web35.TransactionInstruction(instruction);
      });
      const versionedTX = await this.prepareTransaction(
        instructions,
        senderPublicKey,
        []
      );
      return { result: versionedTX };
    } catch (error) {
      throw this.handleError("UNSTAKE_ERROR", error);
    }
  }
  /**
   * Split existing account to create a new one
   *
   * @param authorityPublicKey - The public key of the account.
   * @param lamports - The number of lamports to stake.
   * @param oldStakeAccountPubkey -The public key of the old account.
   * @param source - The stake source
   *
   * @throws Throws an error if there's an issue splitting an account.
   *
   * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
   *
   */
  async split(authorityPublicKey, lamports, oldStakeAccountPubkey, source, rentExemptReserve) {
    const seed = this.formatSource(source);
    const newStakeAccountPubkey = await import_web35.PublicKey.createWithSeed(
      authorityPublicKey,
      seed,
      import_web35.StakeProgram.programId
    );
    const splitStakeAccountTx = new import_web35.Transaction().add(
      import_web35.StakeProgram.splitWithSeed(
        {
          stakePubkey: oldStakeAccountPubkey,
          authorizedPubkey: authorityPublicKey,
          splitStakePubkey: newStakeAccountPubkey,
          basePubkey: authorityPublicKey,
          seed,
          lamports
        },
        rentExemptReserve
      )
    );
    return [splitStakeAccountTx, newStakeAccountPubkey, []];
  }
  /**
   * Claim makes withdrawal from all sender's deactivated accounts.
   *
   * @param sender - The sender solana address.
   *
   * @throws Throws an error if there's an issue while claiming a stake.
   *
   * @returns Returns a promise that resolves with a Versioned Transaction.
   *
   */
  async claim(sender) {
    try {
      const delegations = await this.getDelegations(sender);
      const stakeAccounts = delegations.result.map((delegationAcc) => {
        return {
          pubkey: delegationAcc.pubkey,
          account: new StakeAccount2(delegationAcc.account)
        };
      });
      const epochInfo = await this.connection.getEpochInfo();
      const tm = this.timestampInSec();
      let totalClaimableStake = new import_bignumber5.default(0);
      const deactivatedStakeAccounts = stakeAccounts.filter((acc) => {
        const { data } = acc.account.account;
        const { info } = data;
        const isDeactivated = !acc.account.isLockupInForce(epochInfo.epoch, tm) && acc.account.stakeAccountState(epochInfo.epoch) === StakeState.deactivated;
        if (info.stake && isDeactivated) {
          totalClaimableStake = totalClaimableStake.plus(
            info.stake.delegation.stake
          );
        }
        return isDeactivated;
      });
      if (deactivatedStakeAccounts.length === 0)
        throw this.throwError("NOTHING_TO_CLAIM_ERROR");
      const senderPublicKey = new import_web35.PublicKey(sender);
      let instructions = [
        import_web35.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 50 })
      ];
      for (const acc of deactivatedStakeAccounts) {
        const withdrawTx = import_web35.StakeProgram.withdraw({
          stakePubkey: acc.pubkey,
          authorizedPubkey: senderPublicKey,
          toPubkey: senderPublicKey,
          lamports: acc.account.account.lamports
        });
        instructions.push(...withdrawTx.instructions);
      }
      instructions = instructions.map((instruction) => {
        return new import_web35.TransactionInstruction(instruction);
      });
      const versionedTX = await this.prepareTransaction(
        instructions,
        senderPublicKey,
        []
      );
      return { result: versionedTX };
    } catch (error) {
      throw this.handleError("CLAIM_ERROR", error);
    }
  }
  async getEpochInfo() {
    try {
      const epochInfo = await this.connection.getEpochInfo();
      return { result: epochInfo };
    } catch (error) {
      throw this.handleError("GET_EPOCH_INFO_ERROR", error);
    }
  }
  /**
   * Merge two accounts into a new one
   *
   * @param authorityPublicKey - The public key of the account.
   * @param stakeAccount1 - The public key of the first account.
   * @param stakeAccount2 - The public key of the second account.
   *
   * @throws Throws an error if there's an issue while merging an account.
   *
   * @returns Returns a promise that resolves with the Transaction, PublicKey and array of Keypair.
   *
   */
  async merge(authorityPublicKey, stakeAccount1, stakeAccount2) {
    const mergeStakeAccountTx = import_web35.StakeProgram.merge({
      stakePubkey: stakeAccount1,
      sourceStakePubKey: stakeAccount2,
      authorizedPubkey: authorityPublicKey
    });
    return [mergeStakeAccountTx];
  }
  /**
   * Generate a unique source for crating an account.
   *
   * @param source - source ID.
   *
   * @returns Returns a unique source for an account.
   *
   */
  formatSource(source) {
    const timestamp = (/* @__PURE__ */ new Date()).getTime();
    source = `everstake ${source}:${timestamp}`;
    return source;
  }
  /**
   * Generate timestamp in seconds.
   *
   * @returns Returns a timestamp in seconds.
   *
   */
  timestampInSec() {
    return Date.now() / 1e3 | 0;
  }
};

// utils/constants/index.ts
var API_URL = "https://wallet-sdk-api.everstake.one";
var ASSETS_API = "https://dashboard-api.everstake.one";

// utils/api.ts
async function CheckToken(token) {
  try {
    const response = await fetch(`${API_URL}/token/check/${token}`, {
      method: "GET",
      headers: { "Content-Type": "application/json" }
    });
    if (!response.ok) {
      throw new Error(`Error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.result;
  } catch (error) {
    console.error("Failed to check token:", error);
    throw error;
  }
}
async function SetStats({
  token,
  action,
  amount,
  address,
  chain
}) {
  try {
    const response = await fetch(`${API_URL}/stats/set`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        token,
        action,
        amount,
        address,
        chain
      })
    });
    if (!response.ok) {
      throw new Error(`Error: ${response.statusText}`);
    }
  } catch (error) {
    console.error("Failed to set stats:", error);
    throw error;
  }
}
async function CreateToken(name, type2) {
  try {
    const response = await fetch(`${API_URL}/token/create`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name, type: type2 })
    });
    if (!response.ok) {
      throw new Error(`Error: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to create token:", error);
    throw error;
  }
}
async function GetAssets(chain) {
  try {
    const response = await fetch(
      `${ASSETS_API}/chain?name=${chain.toLowerCase()}`,
      {
        method: "GET"
      }
    );
    if (!response.ok) {
      throw new Error(`Error: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to get assets:", error);
    throw error;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ABI_CONTRACT_ACCOUNTING,
  ABI_CONTRACT_POOL,
  Blockchain,
  CheckToken,
  CreateToken,
  ETH_GAS_RESERVE,
  ETH_MIN_AMOUNT,
  ETH_NETWORK_ADDRESSES,
  Ethereum,
  FILTER_DATA_SIZE,
  FILTER_OFFSET,
  GetAssets,
  MULTICALL_CONTRACT_ADDRESS,
  ParseStakeAccountError,
  SOL_CHAIN,
  SOL_DEVNET_VALIDATOR_ADDRESS,
  SOL_MAINNET_VALIDATOR_ADDRESS,
  SOL_MIN_AMOUNT,
  SetStats,
  SolNetwork,
  Solana,
  StakeAccount,
  StakeAccountType,
  StakeState,
  UINT16_MAX,
  ValidatorStatus,
  WalletSDKError
});
