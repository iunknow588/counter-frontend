{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/core/exception-types.ts", "../../src/core/json-rpc-types.ts", "../../src/core/message-types.ts", "../../src/core/deep-link-pages.ts", "../../src/modules/auth-types.ts", "../../src/modules/rpc-provider-types.ts", "../../src/modules/user-types.ts", "../../src/modules/nft-types.ts", "../../src/modules/wallet-types.ts", "../../src/modules/common-types.ts"],
  "sourcesContent": ["// Only re-export types that are intended for the public API from this file.\n// Deprecate test API key in v7.0.0\n\nexport * from './core/exception-types';\nexport * from './core/i18n';\nexport * from './core/json-rpc-types';\nexport * from './core/message-types';\nexport * from './core/query-types';\nexport * from './core/deep-link-pages';\n\nexport * from './modules/auth-types';\nexport * from './modules/rpc-provider-types';\nexport * from './modules/user-types';\nexport * from './modules/intermediary-types';\nexport * from './modules/nft-types';\nexport * from './modules/wallet-types';\nexport * from './modules/common-types';\n", "export enum SDKErrorCode {\n  MissingApiKey = 'MISSING_API_KEY',\n  ModalNotReady = 'MODAL_NOT_READY',\n  ConnectionLost = 'CONNECTION_WAS_LOST',\n  MalformedResponse = 'MALFORMED_RESPONSE',\n  InvalidArgument = 'INVALID_ARGUMENT',\n  ExtensionNotInitialized = 'EXTENSION_NOT_INITIALIZED',\n  IncompatibleExtensions = 'INCOMPATIBLE_EXTENSIONS',\n}\n\nexport enum SDKWarningCode {\n  SyncWeb3Method = 'SYNC_WEB3_METHOD',\n  DuplicateIframe = 'DUPLICATE_IFRAME',\n  ReactNativeEndpointConfiguration = 'REACT_NATIVE_ENDPOINT_CONFIGURATION',\n  DeprecationNotice = 'DEPRECATION_NOTICE',\n  ProductAnnouncement = 'ANNOUNCEMENT',\n}\n\nexport enum RPCErrorCode {\n  // Standard JSON RPC 2.0 Error Codes\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n\n  // Custom RPC Error Codes\n  MagicLinkFailedVerification = -10000,\n  MagicLinkExpired = -10001,\n  MagicLinkRateLimited = -10002,\n  MagicLinkInvalidRedirectURL = -10006,\n  UserAlreadyLoggedIn = -10003,\n  UpdateEmailFailed = -10004,\n  UserRequestEditEmail = -10005,\n  InactiveRecipient = -10010,\n  AccessDeniedToUser = -10011,\n  RedirectLoginComplete = -10015,\n  DpopInvalidated = -10019,\n}\n\nexport type ErrorCode = SDKErrorCode | RPCErrorCode;\nexport type WarningCode = SDKWarningCode;\n", "import { RPCErrorCode } from './exception-types';\n\n// --- Request interfaces\n\nexport interface JsonRpcRequestPayload<TParams = any> {\n  jsonrpc: string;\n  id: string | number | null;\n  method: string;\n  params?: TParams;\n}\n\nexport interface JsonRpcRequestCallback {\n  /** Callback executed upon JSON RPC response. */\n  (err: JsonRpcError | null, result?: JsonRpcResponsePayload | null): void;\n}\n\nexport interface JsonRpcBatchRequestCallback {\n  /** Callback executed upon JSON RPC response. */\n  (err: JsonRpcError | null, result?: (JsonRpcResponsePayload | null)[] | null): void;\n}\n\n// --- Response interfaces\n\nexport interface JsonRpcError {\n  message: string;\n  code: RPCErrorCode;\n  data?: any;\n}\n\nexport interface JsonRpcResponsePayload<ResultType = any> {\n  jsonrpc: string;\n  id: string | number | null;\n  result?: ResultType | null;\n  error?: JsonRpcError | null;\n}\n\nexport interface UserInfo {\n  email?: string;\n}\n\nexport type ShowUIPromiEvents = {\n  disconnect: () => void;\n};\n\nexport interface WalletInfo {\n  walletType: string;\n}\n\nexport interface RequestUserInfoScope {\n  scope?: {\n    email?: 'required' | 'optional';\n  };\n}\n\nexport enum LocalStorageKeys {\n  PROVIDER = 'magic_3pw_provider',\n  ADDRESS = 'magic_3pw_address',\n  CHAIN_ID = 'magic_3pw_chainId',\n}\n\nexport enum ThirdPartyWalletEvents {\n  WalletConnected = 'wallet_connected',\n  WalletRejected = 'wallet_rejected',\n  Web3ModalSelected = 'web3modal_selected',\n}\n\nexport interface ConnectWithUIOptions {\n  autoPromptThirdPartyWallets?: boolean;\n}\n\nexport type ConnectWithUiEvents = {\n  'id-token-created': (params: { idToken: string }) => void;\n} & { [key in ThirdPartyWalletEvents]: () => void };\n\n// --- Payload methods\n\n/**\n * Enum of JSON RPC methods for interacting with the Magic SDK authentication\n * relayer.\n */\nexport enum MagicPayloadMethod {\n  LoginWithSms = 'magic_auth_login_with_sms',\n  LoginWithEmailOTP = 'magic_auth_login_with_email_otp',\n  LoginWithMagicLink = 'magic_auth_login_with_magic_link',\n  LoginWithCredential = 'magic_auth_login_with_credential',\n  SetAuthorizationToken = 'magic_auth_set_authorization_token',\n  GetIdToken = 'magic_auth_get_id_token',\n  GenerateIdToken = 'magic_auth_generate_id_token',\n  GetMetadata = 'magic_auth_get_metadata',\n  IsLoggedIn = 'magic_is_logged_in',\n  Logout = 'magic_auth_logout',\n  UpdateEmail = 'magic_auth_update_email',\n  UserSettings = 'magic_auth_settings',\n  UserSettingsTestMode = 'magic_auth_settings_testing_mode',\n  LoginWithSmsTestMode = 'magic_auth_login_with_sms_testing_mode',\n  LoginWithEmailOTPTestMode = 'magic_auth_login_with_email_otp_testing_mode',\n  LoginWithMagicLinkTestMode = 'magic_login_with_magic_link_testing_mode',\n  LoginWithCredentialTestMode = 'magic_auth_login_with_credential_testing_mode',\n  GetIdTokenTestMode = 'magic_auth_get_id_token_testing_mode',\n  GenerateIdTokenTestMode = 'magic_auth_generate_id_token_testing_mode',\n  GetMetadataTestMode = 'magic_auth_get_metadata_testing_mode',\n  IsLoggedInTestMode = 'magic_auth_is_logged_in_testing_mode',\n  LogoutTestMode = 'magic_auth_logout_testing_mode',\n  UpdateEmailTestMode = 'magic_auth_update_email_testing_mode',\n  IntermediaryEvent = 'magic_intermediary_event',\n  RequestAccounts = 'eth_requestAccounts',\n  GetInfo = 'magic_get_info',\n  ShowUI = 'magic_wallet',\n  NFTPurchase = 'magic_nft_purchase',\n  NFTCheckout = 'magic_nft_checkout',\n  NFTTransfer = 'magic_nft_transfer',\n  RequestUserInfoWithUI = 'mc_request_user_info',\n  Disconnect = 'mc_disconnect',\n  // UpdatePhoneNumber = 'magic_auth_update_phone_number',\n  // UpdatePhoneNumberTestMode = 'magic_auth_update_phone_number_testing_mode',\n  RecoverAccount = 'magic_auth_recover_account',\n  RecoverAccountTestMode = 'magic_auth_recover_account_testing_mode',\n  MagicBoxHeartBeat = 'magic_box_heart_beat',\n  AutoConnect = 'mc_auto_connect',\n  Login = 'mc_login',\n  EncryptV1 = 'magic_auth_encrypt_v1',\n  DecryptV1 = 'magic_auth_decrypt_v1',\n  ShowNFTs = 'magic_show_nfts',\n  ShowOnRamp = 'magic_show_fiat_onramp',\n  ShowSendTokensUI = 'magic_show_send_tokens_ui',\n  ShowAddress = 'magic_show_address',\n  ShowBalances = 'magic_show_balances',\n  SendGaslessTransaction = 'eth_sendGaslessTransaction',\n  RevealPK = 'magic_reveal_key',\n  EnableMFA = 'magic_auth_enable_mfa_flow',\n  DisableMFA = 'magic_auth_disable_mfa_flow',\n}\n\n// Methods to not route if connected to third party wallet\nexport const routeToMagicMethods = [\n  MagicPayloadMethod.IntermediaryEvent,\n  MagicPayloadMethod.NFTCheckout,\n  MagicPayloadMethod.Login,\n];\n", "import { JsonRpcResponsePayload, JsonRpcError, JsonRpcRequestPayload } from './json-rpc-types';\n\nexport enum MagicIncomingWindowMessage {\n  MAGIC_HANDLE_RESPONSE = 'MAGIC_HANDLE_RESPONSE',\n  MAGIC_OVERLAY_READY = 'MAGIC_OVERLAY_READY',\n  MAGIC_SHOW_OVERLAY = 'MAGIC_SHOW_OVERLAY',\n  MAGIC_HIDE_OVERLAY = 'MAGIC_HIDE_OVERLAY',\n  MAGIC_HANDLE_EVENT = 'MAGIC_HANDLE_EVENT',\n  MAGIC_MG_BOX_SEND_RECEIPT = 'MAGIC_MG_BOX_SEND_RECEIPT',\n  MAGIC_SEND_PRODUCT_ANNOUNCEMENT = 'MAGIC_SEND_PRODUCT_ANNOUNCEMENT',\n  MAGIC_PONG = 'MAGIC_PONG',\n  MAGIC_POPUP_RESPONSE = 'MAGIC_POPUP_RESPONSE',\n  MAGIC_POPUP_OAUTH_VERIFY_RESPONSE = 'MAGIC_POPUP_OAUTH_VERIFY_RESPONSE',\n}\n\nexport enum MagicOutgoingWindowMessage {\n  MAGIC_HANDLE_REQUEST = 'MAGIC_HANDLE_REQUEST',\n  MAGIC_PING = 'MAGIC_PING',\n}\n\n/** The shape of responding window message datas from the Magic iframe context. */\nexport interface MagicMessageRequest {\n  msgType: string;\n  payload: JsonRpcRequestPayload | JsonRpcRequestPayload[];\n  rt?: string;\n  jwt?: string;\n  deviceShare?: string;\n}\n\n/** The shape of responding window message datas from the Magic iframe context. */\nexport interface MagicMessageResponse<ResultType = any> {\n  msgType: string;\n  response: Partial<JsonRpcError> & Partial<JsonRpcResponsePayload<ResultType>>;\n  rt?: string;\n  deviceShare?: string;\n}\n\n/** The expected message event returned by the Magic iframe context. */\nexport interface MagicMessageEvent extends Partial<MessageEvent> {\n  data: MagicMessageResponse;\n}\n", "export enum DeepLinkPage {\n  UpdateEmail = 'update-email',\n  MFA = 'mfa',\n  Recovery = 'recovery',\n}\n", "import { WalletEventOnReceived } from './wallet-types';\n\nexport interface LoginWithMagicLinkConfiguration {\n  /**\n   * The email address of the user attempting to login.\n   */\n  email: string;\n\n  /**\n   * When `true`, a pre-built modal interface will show to the user, directing\n   * them to check their email for the \"magic link\" to complete their\n   * authentication.\n   */\n  showUI?: boolean;\n\n  /**\n   * You can optionally provide a redirect URI that will be followed at the end\n   * of the magic link flow. Don't forget to invoke\n   * `magic.auth.loginWithCredential()` to complete the login from the route you\n   * configure here.\n   */\n  redirectURI?: string;\n\n  /**\n   * Enterprise users with a custom SMTP can create custom email templates\n   * from their dashboard. The default Magic loginWithMagicLink email will be\n   * overridden when a variation is passed here.\n   */\n  overrides?: {\n    variation?: string;\n  };\n\n  /**\n   * The number of seconds until the generated Decenteralized ID token will expire.\n   */\n  lifespan?: number;\n}\n\nexport interface LoginWithSmsConfiguration {\n  /**\n   * Specify the phone number of the user attempting to login.\n   */\n  phoneNumber: string;\n\n  /**\n   * When `true`, a pre-built modal interface will show to the user, directing\n   * them to check their SMS for the one time passcode (OTP) to complete their\n   * authentication.\n   *\n   * When `false`, developers will be able to implement their own custom UI to\n   * continue the SMS OTP flow.\n   */\n  showUI?: boolean;\n\n  /*\n   * The number of seconds until the generated Decenteralized ID token will expire.\n   */\n  lifespan?: number;\n}\nexport interface LoginWithEmailOTPConfiguration {\n  /**\n   * Specify the email address of the user attempting to login.\n   */\n  email: string;\n\n  /**\n   * When `true`, a pre-built modal interface will show to the user, directing\n   * them to check their email for the one time passcode (OTP) to complete their\n   * authentication.\n   *\n   * When `false`, developers will be able to implement their own custom UI to\n   * continue the email OTP flow.\n   */\n  showUI?: boolean;\n\n  /**\n   * Device Unrecognized UI will enforce showing up to secure user's login\n   *\n   * When set to true (default), an improved device recognition UI will be displayed to the user,\n   * prompting them to verify their login by checking their email for device approval. This feature\n   * enhances authentication security.\n   *\n   * This param will only be affect if showUI is false. When set to false,\n   * developers have the flexibility to implement their own customized UI to\n   * handle device check events, providing a more tailored user experience.\n   */\n  deviceCheckUI?: boolean;\n\n  /**\n   * Enterprise users with a custom SMTP can create custom email templates\n   * from their dashboard. The default Magic loginWithOTP email will be\n   * overridden when a variation is passed here.\n   */\n  overrides?: {\n    variation?: string;\n  };\n\n  /**\n   * The number of seconds until the generated Decenteralized ID token will expire.\n   */\n  lifespan?: number;\n}\n\nexport interface LoginWithCredentialConfiguration {\n  /**\n   * A credential token or a valid query string (prefixed with ? or #)\n   */\n  credentialOrQueryString?: string;\n\n  /**\n   * The number of seconds until the generated Decenteralized ID token will expire.\n   */\n  lifespan?: number;\n}\n\nexport interface EnableMFAConfiguration {\n  /**\n   * When `true`, a pre-built modal interface will show to the user, directing\n   * them to enable MFA usign Google Authenticator app.\n   *\n   * When `false`, developers will be able to implement their own custom UI to\n   * continue the enable MFA flow.\n   */\n  showUI?: boolean;\n}\n\nexport interface DisableMFAConfiguration {\n  /**\n   * When `true`, a pre-built modal interface will show to the user, directing\n   * them to disable MFA.\n   *\n   * When `false`, developers will be able to implement their own custom UI to\n   * continue the disable MFA flow.\n   */\n  showUI?: boolean;\n}\n\n/**\n * Auth Events Enum\n */\nexport enum LoginWithMagicLinkEventEmit {\n  Retry = 'retry',\n}\n\nexport enum LoginWithMagicLinkEventOnReceived {\n  EmailSent = 'email-sent',\n  EmailNotDeliverable = 'email-not-deliverable',\n}\n\nexport enum LoginWithEmailOTPEventEmit {\n  VerifyEmailOtp = 'verify-email-otp',\n  VerifyMFACode = 'verify-mfa-code',\n  LostDevice = 'lost-device',\n  VerifyRecoveryCode = 'verify-recovery-code',\n  Cancel = 'cancel',\n}\n\nexport enum LoginWithSmsOTPEventEmit {\n  VerifySmsOtp = 'verify-sms-otp',\n  Cancel = 'cancel',\n  Retry = 'retry',\n}\n\nexport enum LoginWithSmsOTPEventOnReceived {\n  SmsOTPSent = 'sms-otp-sent',\n  InvalidSmsOtp = 'invalid-sms-otp',\n  ExpiredSmsOtp = 'expired-sms-otp',\n}\n\nexport enum LoginWithEmailOTPEventOnReceived {\n  EmailOTPSent = 'email-otp-sent',\n  InvalidEmailOtp = 'invalid-email-otp',\n  InvalidMfaOtp = 'invalid-mfa-otp',\n  ExpiredEmailOtp = 'expired-email-otp',\n  MfaSentHandle = 'mfa-sent-handle',\n  RecoveryCodeSentHandle = 'recovery-code-sent-handle',\n  InvalidRecoveryCode = 'invalid-recovery-code',\n  RecoveryCodeSuccess = 'recovery-code-success',\n  LoginThrottled = 'login-throttled',\n}\n\nexport enum DeviceVerificationEventEmit {\n  Retry = 'device-retry',\n}\n\nexport enum DeviceVerificationEventOnReceived {\n  DeviceApproved = 'device-approved',\n  DeviceNeedsApproval = 'device-needs-approval',\n  DeviceVerificationLinkExpired = 'device-verification-link-expired',\n  DeviceVerificationEmailSent = 'device-verification-email-sent',\n}\n\nexport enum RecencyCheckEventEmit {\n  Retry = 'Recency/auth-factor-retry',\n  Cancel = 'Recency/auth-factor-verification-cancel',\n  VerifyEmailOtp = 'Recency/auth-factor-verify-email-otp',\n  VerifyMFACode = 'Recency/verify-mfa-code',\n}\n\nexport enum RecencyCheckEventOnReceived {\n  PrimaryAuthFactorNeedsVerification = 'Recency/auth-factor-needs-verification',\n  PrimaryAuthFactorVerified = 'Recency/auth-factor-verified',\n  InvalidEmailOtp = 'Recency/auth-factor-invalid-email-otp',\n  EmailExpired = 'Recency/auth-factor-verification-email-expired',\n  EmailSent = 'Recency/auth-factor-verification-email-sent',\n  EmailNotDeliverable = 'Recency/auth-factor-verification-email-not-deliverable',\n}\n\nexport enum UpdateEmailEventEmit {\n  RetryWithNewEmail = 'UpdateEmail/retry-with-new-email',\n  Cancel = 'UpdateEmail/new-email-verification-cancel',\n  VerifyEmailOtp = 'UpdateEmail/new-email-verify-otp',\n}\n\nexport enum UpdateEmailEventOnReceived {\n  NewAuthFactorNeedsVerification = 'UpdateEmail/new-email-needs-verification',\n  EmailUpdated = 'UpdateEmail/email-updated',\n  InvalidEmailOtp = 'UpdateEmail/new-email-invalid-email-otp',\n  EmailExpired = 'UpdateEmail/new-email-verification-email-expired',\n  EmailSent = 'UpdateEmail/new-email-verification-email-sent',\n  EmailNotDeliverable = 'UpdateEmail/new-email-verification-email-not-deliverable',\n  InvalidEmail = 'UpdateEmail/new-email-invalid',\n  EmailAlreadyExists = 'UpdateEmail/new-email-already-exists',\n}\n\nexport enum AuthEventOnReceived {\n  IDTokenCreated = 'Auth/id-token-created',\n}\n\nexport enum FarcasterLoginEventEmit {\n  Cancel = 'Farcaster/cancel',\n}\n\nexport enum EnableMFAEventOnReceived {\n  MFASecretGenerated = 'mfa-secret-generated',\n  InvalidMFAOtp = 'invalid-mfa-otp',\n  MFARecoveryCodes = 'mfa-recovery-codes',\n}\nexport enum EnableMFAEventEmit {\n  VerifyMFACode = 'verify-mfa-code',\n  Cancel = 'cancel-mfa-setup',\n}\n\nexport enum DisableMFAEventOnReceived {\n  MFACodeRequested = 'mfa-code-requested',\n  InvalidMFAOtp = 'invalid-mfa-otp',\n  InvalidRecoveryCode = 'invalid-recovery-code',\n}\n\nexport enum DisableMFAEventEmit {\n  VerifyMFACode = 'verify-mfa-code',\n  LostDevice = 'lost-device',\n  Cancel = 'cancel-mfa-disable',\n}\n\n/**\n * EventHandlers\n */\nexport type LoginWithMagicLinkEventHandlers = {\n  // Event Received\n  [LoginWithMagicLinkEventOnReceived.EmailSent]: () => void;\n  [LoginWithMagicLinkEventOnReceived.EmailNotDeliverable]: () => void;\n\n  // Event sent\n  [LoginWithMagicLinkEventEmit.Retry]: () => void;\n} & DeviceVerificationEventHandlers;\n\nexport type LoginWithSmsOTPEventHandlers = {\n  // Event sent\n  [LoginWithSmsOTPEventEmit.VerifySmsOtp]: (otp: string) => void;\n  [LoginWithSmsOTPEventEmit.Cancel]: () => void;\n  [LoginWithSmsOTPEventEmit.Retry]: () => void;\n\n  // Event received\n  [LoginWithSmsOTPEventOnReceived.SmsOTPSent]: () => void;\n  [LoginWithSmsOTPEventOnReceived.InvalidSmsOtp]: () => void;\n  [LoginWithSmsOTPEventOnReceived.ExpiredSmsOtp]: () => void;\n} & DeviceVerificationEventHandlers;\n\nexport type LoginWithEmailOTPEventHandlers = {\n  // Event Received\n  [LoginWithEmailOTPEventOnReceived.EmailOTPSent]: () => void;\n  [LoginWithEmailOTPEventOnReceived.LoginThrottled]: () => void;\n  [LoginWithEmailOTPEventOnReceived.InvalidEmailOtp]: () => void;\n  [LoginWithEmailOTPEventOnReceived.InvalidMfaOtp]: () => void;\n  [LoginWithEmailOTPEventOnReceived.ExpiredEmailOtp]: () => void;\n  [LoginWithEmailOTPEventOnReceived.MfaSentHandle]: () => void;\n  [LoginWithEmailOTPEventOnReceived.RecoveryCodeSentHandle]: () => void;\n  [LoginWithEmailOTPEventOnReceived.InvalidRecoveryCode]: () => void;\n  [LoginWithEmailOTPEventOnReceived.RecoveryCodeSuccess]: () => void;\n  [AuthEventOnReceived.IDTokenCreated]: (idToken: string) => void;\n  [WalletEventOnReceived.WalletInfoFetched]: () => void;\n\n  // Event sent\n  [LoginWithEmailOTPEventEmit.VerifyEmailOtp]: (otp: string) => void;\n  [LoginWithEmailOTPEventEmit.VerifyMFACode]: (mfa: string) => void;\n  [LoginWithEmailOTPEventEmit.LostDevice]: () => void;\n  [LoginWithEmailOTPEventEmit.VerifyRecoveryCode]: (recoveryCode: string) => void;\n  [LoginWithEmailOTPEventEmit.Cancel]: () => void;\n} & DeviceVerificationEventHandlers;\n\ntype DeviceVerificationEventHandlers = {\n  // Event Received\n  [DeviceVerificationEventOnReceived.DeviceNeedsApproval]: () => void;\n  [DeviceVerificationEventOnReceived.DeviceVerificationEmailSent]: () => void;\n  [DeviceVerificationEventOnReceived.DeviceVerificationLinkExpired]: () => void;\n  [DeviceVerificationEventOnReceived.DeviceApproved]: () => void;\n\n  // Event sent\n  [DeviceVerificationEventEmit.Retry]: () => void;\n};\n\n/**\n * Update Email\n */\n\nexport type RecencyCheckEventHandlers = {\n  [RecencyCheckEventOnReceived.PrimaryAuthFactorNeedsVerification]: () => void;\n  [RecencyCheckEventOnReceived.PrimaryAuthFactorVerified]: () => void;\n  [RecencyCheckEventOnReceived.InvalidEmailOtp]: () => void;\n  [RecencyCheckEventOnReceived.EmailNotDeliverable]: () => void;\n  [RecencyCheckEventOnReceived.EmailExpired]: () => void;\n  [RecencyCheckEventOnReceived.EmailSent]: () => void;\n\n  [RecencyCheckEventEmit.Cancel]: () => void;\n  [RecencyCheckEventEmit.Retry]: () => void;\n  [RecencyCheckEventEmit.VerifyEmailOtp]: (otp: string) => void;\n  [RecencyCheckEventEmit.VerifyMFACode]: (mfa: string) => void;\n};\n\nexport type UpdateEmailEventHandlers = {\n  [UpdateEmailEventOnReceived.NewAuthFactorNeedsVerification]: () => void;\n  [UpdateEmailEventOnReceived.EmailUpdated]: () => void;\n  [UpdateEmailEventOnReceived.InvalidEmailOtp]: () => void;\n  [UpdateEmailEventOnReceived.EmailNotDeliverable]: () => void;\n  [UpdateEmailEventOnReceived.EmailExpired]: () => void;\n  [UpdateEmailEventOnReceived.EmailSent]: () => void;\n  [UpdateEmailEventOnReceived.InvalidEmail]: () => void;\n  [UpdateEmailEventOnReceived.EmailAlreadyExists]: () => void;\n\n  [UpdateEmailEventEmit.Cancel]: () => void;\n  [UpdateEmailEventEmit.RetryWithNewEmail]: (email?: string) => void;\n  [UpdateEmailEventEmit.VerifyEmailOtp]: (otp: string) => void;\n} & RecencyCheckEventHandlers;\n\n/**\n * Enable MFA\n */\n\nexport type EnableMFAEventHandlers = {\n  // Event Received\n  [EnableMFAEventOnReceived.MFASecretGenerated]: ({ QRCode, key }: { QRCode: string; key: string }) => void;\n  [EnableMFAEventOnReceived.InvalidMFAOtp]: ({ errorCode }: { errorCode: string }) => void;\n  [EnableMFAEventOnReceived.MFARecoveryCodes]: ({ recoveryCode }: { recoveryCode: string }) => void;\n\n  // Event sent\n  [EnableMFAEventEmit.VerifyMFACode]: (totp: string) => void;\n  [EnableMFAEventEmit.Cancel]: () => void;\n};\n\n/**\n * Disable MFA\n */\n\nexport type DisableMFAEventHandlers = {\n  // Event Received\n  [DisableMFAEventOnReceived.MFACodeRequested]: () => void;\n  [DisableMFAEventOnReceived.InvalidMFAOtp]: ({ errorCode }: { errorCode: string }) => void;\n  [DisableMFAEventOnReceived.InvalidRecoveryCode]: () => void;\n\n  // Event sent\n  [DisableMFAEventEmit.VerifyMFACode]: (totp: string) => void;\n  [DisableMFAEventEmit.LostDevice]: (recoveryCode: string) => void;\n  [DisableMFAEventEmit.Cancel]: () => void;\n};\n", "export type EthNetworkName = 'mainnet' | 'goerli' | 'sepolia';\n\nexport enum EthChainType {\n  Harmony = 'HARMONY',\n}\n\nexport interface CustomNodeConfiguration {\n  rpcUrl: string;\n  chainId?: number;\n  chainType?: EthChainType;\n}\n\nexport type EthNetworkConfiguration = EthNetworkName | CustomNodeConfiguration;\n\nexport type ProviderEnableEvents = {\n  'id-token-created': (params: { idToken: string }) => void;\n};\n", "import { RecencyCheckEventHandlers } from './auth-types';\nimport { DeepLinkPage } from '../core/deep-link-pages';\n\nexport interface GetIdTokenConfiguration {\n  /**\n   * The number of seconds until the generated ID token will expire.\n   */\n  lifespan?: number;\n}\n\nexport interface GenerateIdTokenConfiguration extends GetIdTokenConfiguration {\n  /**\n   * An optional piece of data to sign with the token. Note, however, that the\n   * unsigned data _will not_ be encoded in the token, only an encrypted\n   * signature of the data.\n   */\n  attachment?: string;\n}\n\nexport enum UserEventsEmit {\n  ClosedByUser = 'closed-by-user',\n}\n\nexport enum UserEventsOnReceived {\n  ClosedByUser = 'closed-by-user-on-received',\n}\n\nexport interface MagicUserMetadata {\n  issuer: string | null;\n  publicAddress: string | null;\n  email: string | null;\n  phoneNumber: string | null;\n  isMfaEnabled: boolean;\n  recoveryFactors: [RecoveryFactor] | [];\n  walletType: string;\n  firstLoginAt: string | null;\n}\n\nexport enum RecoveryFactorEventOnReceived {\n  EnterNewPhoneNumber = 'enter-new-phone-number',\n  EnterOtpCode = 'enter-otp-code',\n  RecoveryFactorAlreadyExists = 'recovery-factor-already-exists',\n  MalformedPhoneNumber = 'malformed-phone-number',\n  InvalidOtpCode = 'invalid-otp-code',\n  RecoveryFactorUpdated = 'recovery-factor-updated',\n  RecoveryFactorDeleted = 'recovery-factor-deleted',\n}\n\nexport enum RecoveryFactorEventEmit {\n  SendNewPhoneNumber = 'send-new-phone-number',\n  SendOtpCode = 'send-otp-code',\n  Cancel = 'cancel',\n  StartEditPhoneNumber = 'start-edit-phone-number',\n}\n\ntype RecoveryFactor = {\n  type: RecoveryMethodType;\n  value: string;\n};\n\nexport type RecoveryFactorEventHandlers = {\n  // Event Received\n  [RecoveryFactorEventEmit.SendNewPhoneNumber]: (phone_number: string) => void;\n  [RecoveryFactorEventEmit.SendOtpCode]: (otp: string) => void;\n  [RecoveryFactorEventEmit.StartEditPhoneNumber]: () => void;\n  [RecoveryFactorEventEmit.Cancel]: () => void;\n\n  // Event sent\n  [RecoveryFactorEventOnReceived.EnterNewPhoneNumber]: () => void;\n  [RecoveryFactorEventOnReceived.EnterOtpCode]: () => void;\n  [RecoveryFactorEventOnReceived.RecoveryFactorAlreadyExists]: () => void;\n  [RecoveryFactorEventOnReceived.MalformedPhoneNumber]: () => void;\n  [RecoveryFactorEventOnReceived.InvalidOtpCode]: () => void;\n  [RecoveryFactorEventOnReceived.RecoveryFactorUpdated]: (updatedFactor: { type: string, value: string }) => void;\n  [RecoveryFactorEventOnReceived.RecoveryFactorDeleted]: () => void;\n} & RecencyCheckEventHandlers;\n\nexport enum RecoveryMethodType {\n  PhoneNumber = 'phone_number',\n}\n\nexport interface UpdateEmailConfiguration {\n  /**\n   * The new email address to update to\n   */\n  email: string;\n\n  /**\n   * When `true`, a pre-built pending modal interface will\n   * guide the user to check their new, followed by old emails\n   * for confirmation emails.\n   */\n  showUI?: boolean;\n}\n\nexport interface UpdateWebAuthnInfoConfiguration {\n  /**\n   *  WebAuthn info id\n   */\n  id: string;\n\n  /**\n   *  nickname that user attempts to update to the webauth device associate to the id.\n   */\n  nickname: string;\n}\n\nexport interface RecoverAccountConfiguration {\n  /**\n   * The email to recover\n   */\n  email: string;\n  showUI: boolean;\n}\n\nexport interface ShowSettingsConfiguration {\n  /**\n   * deep linking destination\n   */\n  page: DeepLinkPage;\n  showUI?: boolean;\n}\n\nexport enum RecoverAccountEventOnReceived {\n  SmsOtpSent = 'sms-otp-sent',\n  LoginThrottled = 'login-throttled',\n  InvalidSmsOtp = 'invalid-sms-otp',\n  SmsVerified = 'sms-verified',\n  AccountRecovered = 'account-recovered',\n  UpdateEmailRequired = 'update-email-required',\n}\n\nexport enum RecoverAccountEventEmit {\n  Cancel = 'cancel',\n  VerifyOtp = 'verify-otp-code',\n  ResendSms = 'resend-sms-otp',\n  UpdateEmail = 'update-email',\n}\n\nexport type RecoverAccountEventHandlers = {\n  // Event Received\n  [RecoverAccountEventEmit.Cancel]: () => void;\n  [RecoverAccountEventEmit.VerifyOtp]: (otp: string) => void;\n  [RecoverAccountEventEmit.ResendSms]: () => void;\n  [RecoverAccountEventEmit.UpdateEmail]: (email: string) => void;\n\n  // Event sent\n  [RecoverAccountEventOnReceived.SmsOtpSent]: ({ phoneNumber }: { phoneNumber: string }) => void;\n  [RecoverAccountEventOnReceived.LoginThrottled]: (error: string) => void;\n  [RecoverAccountEventOnReceived.InvalidSmsOtp]: ({\n    errorMessage,\n    errorCode,\n  }: {\n    errorMessage: string;\n    errorCode: string;\n  }) => void;\n  [RecoverAccountEventOnReceived.SmsVerified]: () => void;\n  [RecoverAccountEventOnReceived.AccountRecovered]: () => void;\n  [RecoverAccountEventOnReceived.UpdateEmailRequired]: () => void;\n};\n", "export type NFTResponseStatus = 'cancelled' | 'pending' | 'processed' | 'declined' | 'expired';\n\nexport type NFTResponse = {\n  status: NFTResponseStatus;\n};\n\nexport interface NFTPurchaseRequest {\n  nft: {\n    name: string;\n    imageUrl: string;\n    blockchainNftId: string;\n    contractAddress: string;\n    network: string;\n    platform: string;\n    type: string;\n  };\n  identityPrefill: {\n    firstName: string;\n    lastName: string;\n    dateOfBirth: string; // YYYY-MM-DD\n    emailAddress: string;\n    phone: string;\n    address: {\n      street1: string;\n      street2: string;\n      city: string;\n      regionCode: string;\n      postalCode: string;\n      countryCode: string;\n    };\n  };\n}\n\nexport type NFTPurchaseResponse = NFTResponse & {\n  errorMessage?: string;\n};\n\nexport interface NFTCheckoutRequest {\n  // given by magic / found in the developer dashboard in future\n  contractId: string;\n  // in contract, if ERC1155\u2026 for ERC721, use token ID = 0\n  tokenId: string;\n  name: string;\n  imageUrl: string;\n  quantity?: number; // default is 1\n  walletAddress?: string; // default is user's wallet address\n  // If enabled, the user will be able to pay with crypto. the default is false\n  isCryptoCheckoutEnabled?: boolean;\n  walletProvider?: 'magic' | 'web3modal';\n}\n\nexport type NFTCheckoutResponse = NFTResponse;\n\nexport type NFTCheckoutEvents = {\n  disconnect: () => void;\n  'nft-checkout-initiated': (rawTransaction: string) => void;\n};\n\nexport interface NFTTransferRequest {\n  tokenId: string;\n  contractAddress: string;\n  quantity?: number;\n  recipient?: string;\n}\n\nexport type NFTTransferResponse = NFTResponse;\n\nexport enum NftCheckoutIntermediaryEvents {\n  Success = 'nft-checkout-success',\n  Failure = 'nft-checkout-failure',\n  Initiated = 'nft-checkout-initiated',\n  Disconnect = 'disconnect',\n}\n\nexport type NftCheckoutEventHandler = {\n  [NftCheckoutIntermediaryEvents.Initiated]: (rawTransaction: string) => void;\n  [NftCheckoutIntermediaryEvents.Success]: (signedTransaction: string) => void;\n  [NftCheckoutIntermediaryEvents.Failure]: () => void;\n};\n", "export type GasApiResponse = {\n  request_id: string;\n  state: string;\n  success: boolean;\n};\n\nexport type AccessListEntry = { address: string; storageKeys: Array<string> };\n\n/**\n *  An ordered collection of [[AccessList]] entries.\n */\nexport type AccessList = Array<AccessListEntry>;\n\nexport interface GaslessTransactionRequest {\n  /**\n   *  The transaction type.\n   */\n  type?: number;\n\n  /**\n   *  The target of the transaction.\n   */\n  to?: string;\n\n  /**\n   *  The sender of the transaction.\n   */\n  from?: string;\n\n  /**\n   *  The nonce of the transaction, used to prevent replay attacks.\n   */\n\n  nonce?: number;\n\n  /**\n   *  The maximum amount of gas to allow this transaction to consime.\n   */\n  gasLimit?: bigint;\n\n  /**\n   *  The gas price to use for legacy transactions or transactions on\n   *  legacy networks.\n   *\n   *  Most of the time the ``max*FeePerGas`` is preferred.\n   */\n  gasPrice?: bigint;\n\n  /**\n   *  The [[link-eip-1559]] maximum priority fee to pay per gas.\n   */\n  maxPriorityFeePerGas?: bigint;\n\n  /**\n   *  The [[link-eip-1559]] maximum total fee to pay per gas. The actual\n   *  value used is protocol enforced to be the block's base fee.\n   */\n  maxFeePerGas?: bigint;\n\n  /**\n   *  The transaction data.\n   */\n  data?: string;\n\n  /**\n   *  The transaction value (in wei).\n   */\n  value?: bigint;\n\n  /**\n   *  The chain ID for the network this transaction is valid on.\n   */\n  chainId?: bigint;\n\n  /**\n   *  The [[link-eip-2930]] access list. Storage slots included in the access\n   *  list are //warmed// by pre-loading them, so their initial cost to\n   *  fetch is guaranteed, but then each additional access is cheaper.\n   */\n  accessList?: AccessList;\n\n  /**\n   *  A custom object, which can be passed along for network-specific\n   *  values.\n   */\n  customData?: any;\n}\n\nexport enum WalletEventOnReceived {\n  WalletInfoFetched = 'Wallet/wallet-info-fetched',\n}\n", "export enum UiEventsEmit {\n  CloseMagicWindow = 'close-magic-window',\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "AuthEventOnReceived", "DeepLinkPage", "DeviceVerificationEventEmit", "DeviceVerificationEventOnReceived", "DisableMFAEventEmit", "DisableMFAEventOnReceived", "EnableMFAEventEmit", "EnableMFAEventOnReceived", "EthChainType", "FarcasterLoginEventEmit", "LocalStorageKeys", "LoginWithEmailOTPEventEmit", "LoginWithEmailOTPEventOnReceived", "LoginWithMagicLinkEventEmit", "LoginWithMagicLinkEventOnReceived", "LoginWithSmsOTPEventEmit", "LoginWithSmsOTPEventOnReceived", "MagicIncomingWindowMessage", "MagicOutgoingWindowMessage", "MagicPayloadMethod", "NftCheckoutIntermediaryEvents", "RPCErrorCode", "RecencyCheckEventEmit", "RecencyCheckEventOnReceived", "RecoverAccountEventEmit", "RecoverAccountEventOnReceived", "RecoveryFactorEventEmit", "RecoveryFactorEventOnReceived", "RecoveryMethodType", "SDKErrorCode", "SDKWarningCode", "ThirdPartyWalletEvents", "UiEventsEmit", "UpdateEmailEventEmit", "UpdateEmailEventOnReceived", "UserEventsEmit", "UserEventsOnReceived", "WalletEventOnReceived", "routeToMagicMethods", "__toCommonJS", "SDKErrorCode", "SDKWarningCode", "RPCErrorCode", "LocalStorageKeys", "ThirdPartyWalletEvents", "MagicPayloadMethod", "routeToMagicMethods", "MagicIncomingWindowMessage", "MagicOutgoingWindowMessage", "DeepLinkPage", "LoginWithMagicLinkEventEmit", "LoginWithMagicLinkEventOnReceived", "LoginWithEmailOTPEventEmit", "LoginWithSmsOTPEventEmit", "LoginWithSmsOTPEventOnReceived", "LoginWithEmailOTPEventOnReceived", "DeviceVerificationEventEmit", "DeviceVerificationEventOnReceived", "RecencyCheckEventEmit", "RecencyCheckEventOnReceived", "UpdateEmailEventEmit", "UpdateEmailEventOnReceived", "AuthEventOnReceived", "FarcasterLoginEventEmit", "EnableMFAEventOnReceived", "EnableMFAEventEmit", "DisableMFAEventOnReceived", "DisableMFAEventEmit", "EthChainType", "UserEventsEmit", "UserEventsOnReceived", "RecoveryFactorEventOnReceived", "RecoveryFactorEventEmit", "RecoveryMethodType", "RecoverAccountEventOnReceived", "RecoverAccountEventEmit", "NftCheckoutIntermediaryEvents", "WalletEventOnReceived", "UiEventsEmit"]
}
